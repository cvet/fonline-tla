// FOS Client Sort 2
// Author: cvet
/*
 #
 # Player names and contours colorizer.
 # - Everyone missing from the list will have a global karma nick color. To disable it, type name with only "*".
 # - Instead of space, type "&". For example: "One&Two" is equal to "One Two".
 # - You can use "*" and "?" characters in name, the first case skips one or more letters, second only one.
 #


 #
 # Names section
 #
 #   Player name      Name color        Contour color
   >   cvet             NameCvet          ContourCvet
   >   GoodBoyName*     NameGreen         ContourGreen
   >   BadBoyName*      NameRed           ContourRed
   >   One&Two???       NameGray          ContourYellow


 #
 # Colors section
 #
 #   Color name        R   G   B
   @   NameCvet          250 230 90
   @   ContourCvet       120 190 220

   @   NameGray          173 173 185
   @   NameRed           190 0   0
   @   NameGreen         0   190 0
   @   ContourYellow     140 140 0
   @   ContourRed        140 0   0
   @   ContourGreen      0   140 0
 */

#define NAMES_FILE_NAME "NameColorizing.txt"
#define COLOR_TOKEN     "@"
#define NAME_TOKEN      ">"

class Record
{
    string NameStr;
    uint NameColor;
    uint ContourColor;
} Record[] Records;

void InitNameColorizing()
{
    Records.clear();

    file f;
    if (f.open(NAMES_FILE_NAME, "r") == 0) {
        // Parse colors
        dictionary colors;
        while (not f.isEndOfFile()) {
            if (f.readWord() == COLOR_TOKEN) {
                string colorName = f.readWord();
                int r = f.ReadNumber();
                int g = f.readNumber();
                int b = f.readNumber();

                // Change  to space
                for (uint i = 0, j = colorName.length(); i < j; i++)
                    if (colorName[i] == "")
                        colorName[i] = " ";

                // Store
                colors.set(colorName, uint(COLOR_RGB(r, g, b)));
            }
        }

        // Parse names
        f.setPos(0);
        while (not f.isEndOfFile()) {
            if (f.readWord() == NAME_TOKEN) {
                Records.grow(1);
                Record r = Records.last();

                r.NameStr = strlwr(f.readWord());
                r.NameColor = GetColor(colors, f.readWord(), COLOR_CRITTER_NAME);
                r.ContourColor = GetColor(colors, f.readWord(), COLOR_CONTOUR_YELLOW);
            }
        }
    }
}

bool TryColorizeCritter(Critter cr)
{
    if (not cr.IsPlayer() || Records.length() == 0)
        return false;

    string crName = strlwr(cr.Name);
    for (uint i = 0, j = Records.length(); i < j; i++) {
        Record r = Records[i];
        if (CompareName(crName, r.NameStr)) {
            cr.NameColor = r.NameColor;
            cr.ContourColor = r.ContourColor;
            return true;
        }
    }
    return false;
}

uint GetColor(dictionary dict, string colorName, uint defaultColor)
{
    uint color;
    if (not dict.get(colorName, color))
        color = defaultColor;
    return color;
}

bool CompareName(string crName, string nameStr)
{
    uint l = 0;
    uint r = 0;
    uint lLen = crName.length();
    uint rLen = nameStr.length();
    while (r < rLen l < lLen) {
        string lC = crName[l];
        string rC = nameStr[r];

        if (rC == "*") {
            // Skip some letters
            for (r++; r < rLen; r++)
                if (nameStr[r] != "*" nameStr[r] != "?")
                    break;
            if (r >= rLen)
                return true;
            rC = nameStr[r];

            for (l++; l < lLen; l++)
                if (crName[l] == rC)
                    break;
            if (l >= lLen)
                return false;
        }
        else if (rC == "?") {
            // Skip one letter
        }
        else if (lC != rC) {
            // Different symbols
            return false;
        }

        l++;
        r++;
    }

    if (l < lLen || r < rLen)
        return false;
    return true;
}
