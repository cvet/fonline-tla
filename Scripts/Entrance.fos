namespace Entrance
{

#if SERVER

class Entry
{
    hstring Name;
    mpos Hex;
};

Entry GetEntry(Map map, int entry, int skip)
{
    return GetEntry(map, hstring("" + entry), skip);
}

Entry GetEntry(Map map, hstring entry, int skip)
{
    Entry ent = Entry();
    if (!MapGetEntryCoords(map, entry, skip, ent.Hex)) {
        return null;
    }

    ent.Name = entry;
    return ent;
}

Entry[] ParseEntries(Map map, int entry)
{
    return ParseEntries(map, hstring("" + entry));
}

Entry[] ParseEntries(Map map, hstring entry)
{
    Entry[] entries = {};
    int count = MapCountEntry(map, entry);
    for (int i = 0; i < count; i++) {
        Entry ent = Entry();
        ent.Name = entry;
        MapGetEntryCoords(map, entry, i, ent.Hex);
        entries.insertLast(ent);
    }
    return entries;
}

bool GetEntryFreeHex(Map map, int entry, mpos& hex)
{
    return GetEntryFreeHex(map, hstring("" + entry), hex);
}

// ищет свободный гекс рядом с указанными координатами
// если найдет - возвращает true
// иначе - false
// карта - где ищем гекс
// радиус на котором нужно искать
// hex координаты нового гекса
bool GetFreeHex(Map map, int radius, mpos& hex)
{
    if (hex.x == 0 || hex.y == 0 || hex.x + radius >= int(map.Size.width) || hex.y + radius >= int(map.Size.height)) {
        return false; // Check borders
    }
    int numTry = 10; // число попыток найти свободный гекс
    int xDelta = 0;
    int yDelta = 0;

    for (int i = 0; i < numTry; i++) {
        xDelta = Game.Random(0, radius * 2) - radius;
        yDelta = Game.Random(0, radius * 2) - radius;
        if (map.IsHexMovable(mpos(hex.x + xDelta, hex.y + yDelta))) {
            hex = mpos(hex.x + xDelta, hex.y + yDelta);
            return true;
        }
    }
    return false;
}

bool GetEntryFreeHex(Map map, hstring entry, mpos& hex)
{
    int count = MapCountEntry(map, entry);

    // Fisrt check direct coords
    for (int i = 0; i < count; i++) {
        if (MapGetEntryCoords(map, entry, i, hex) && map.IsHexMovable(hex)) {
            return true;
        }
    }

    // Check borders
    if (hex.x == 0 || hex.y == 0 || hex.x >= map.Size.width - 1 || hex.y >= map.Size.height - 1) {
        return false;
    }

    // Second check coords with offsets
    for (int i = 0; i < count; i++) {
        if (MapGetEntryCoords(map, entry, i, hex)) {
            for (int x = -1; x <= 1; x++) {
                for (int y = -1; y <= 1; y++) {
                    if (x == 0 && y == 0) {
                        continue; // Skip direct position
                    }

                    if (Settings.MapHexagonal) {
                        if ((hex.x % 2) == 1 && ((x == -1 && y == 1) || (x == 1 && y == 1))) {
                            continue;
                        }
                        if ((hex.x % 2) == 0 && ((x == -1 && y == -1) || (x == 1 && y == -1))) {
                            continue;
                        }
                    }

                    if (map.IsHexMovable(mpos(hex.x + x, hex.y + y))) {
                        hex = mpos(hex.x + x, hex.y + y);
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

bool GetNearEntry(Map map, int entry, mpos& hex)
{
    return GetNearEntry(map, hstring("" + entry), hex);
}

bool GetNearEntry(Map map, hstring entry, mpos& hex)
{
    auto hexBase = hex;

    Entry[] entries = ParseEntries(map, entry);
    if (entries.isEmpty()) {
        return false;
    }

    hex = entries[0].Hex;
    for (int i = 1; i < entries.length(); i++) {
        Entry ent = entries[i];
        if (Game.GetDistance(hexBase, ent.Hex) < Game.GetDistance(hexBase, hex)) {
            hex = ent.Hex;
        }
    }

    return true;
}

// * ******************************************* Мертвая зона, заданная EntryHex'ами ******************************************* */
/*
   Всякая простая замкнутая ломаная на плоскости разбивает точки плоскости на две области – внутреннюю и внешнюю.

   из координат игрока пускается горизонтальный луч
   если луч пересекает ломаную закрытой зоны нечетное число раз - он находится во внутренней зоне ломаной, иначе в наружной

   cr - криттер, которого проверяем
   map - карта, на которой имеется мертвая зона
   dir - направление луча (лучше использовать горизонталь по х - dir = 0\
   hexFirst - номер первого из гексов, ограничивающих мертвую зону
   hexEnd - номер последнего гекса, ограничивающего мертвую зону

   номера гексов должны возрастать для каждой последующей точки.
   нельзя поставить общий номер всем гексам, иначе для общего случая (невыпуклого многоугольника мертвой зоны) будет найдено множество решений
*/
bool IsCritterInDeadZone(Critter cr, Map map, uint8 dir, int hexFirst, int hexEnd)
{
    int crossNum = 0; // число пересечений луча и ломанных, ограничивающих многоугольник мертвой зоны
    for (int i = hexFirst; i <= hexEnd; i++) {
        if (BeamCrossing2Section(map, i, i == hexEnd ? hexFirst : i + 1, cr.Hex, dir)) {
            crossNum++;
        }
    }
    return crossNum % 2 == 1;
}

// Признак: луч пересекает некий отрезок между двумя Entry гексами
// map - карта
// hexNum1 - начальный гекс отрезка
// hexNum2 - конечный гекс отрезка
// beamHex - координата начала луча
// dir - направление луча
// если не найдены гексы, или нет пересечения луча и отрезка между гексами - вернет false
// если луч пересекает отрезок - вернет true
bool BeamCrossing2Section(Map map, int hexNum1, int hexNum2, mpos beamHex, uint8 dir)
{
    // 1. вычисляем координаты конечной точки луча
    mpos hex0 = beamHex;
    mpos beamHex2 = beamHex;
    int steps = 0;

    while (hex0.x != beamHex2.x || hex0.y != beamHex2.y || steps == 0) {
        steps += 1;
        hex0 = beamHex2;
        map.MoveHexByDir(beamHex2, dir, steps);
    }

    // координаты конечной точки высчитаны beamHex2
    mpos hex1, hex2;
    // координаты начальной и конечной точки отрезка между двумя гексами
    if (!MapGetEntryCoords(map, hexNum1, 0, hex1)) {
        return false;
    }
    if (!MapGetEntryCoords(map, hexNum2, 0, hex2)) {
        return false;
    }

    // Знаменатель
    float z = (hex1.x - hex2.x) * (beamHex2.y - beamHex.y) - (hex1.y - hex2.y) * (beamHex2.x - beamHex.x);
    // числитель 1
    float ch = (hex1.x - beamHex.x) * (beamHex2.y - beamHex.y) - (hex1.y - beamHex.y) * (beamHex2.x - beamHex.x);
    // числитель 2
    float cbeam = (hex1.x - hex2.x) * (hex1.y - beamHex.y) - (hex1.y - hex2.y) * (hex1.x - beamHex.x);
    // если числители и знаменатель = 0, прямые совпадают, считаем что это не пересечение
    if (z == 0 && ch == 0 && cbeam == 0) {
        return false;
    }
    // если знаменатель = 0, отрезок и луч = параллельны, не пересекаются
    if (z == 0) {
        return false;
    }
    // точка пересечения на отрезке
    float crossS = ch / z;
    // точка пересечения на луче
    float crossB = cbeam / z;
    return 0 < crossS && crossS < 1 && 0 < crossB && crossB < 1;
}

int MapCountEntry(Map map, int entry)
{
    return MapCountEntry(map, hstring("" + entry));
}

int MapCountEntry(Map map, hstring entry)
{
    int total = 0;
    if (valid(map)) {
        auto staticItems = map.GetStaticItems();
        for (int i = 0; i < staticItems.length(); i++) {
            StaticItem staticItem = staticItems[i];
            if (EntryMatch(entry, staticItem)) {
                total++;
            }
        }
    }
    return total;
}

bool EntryMatch(hstring entry, StaticItem entrance)
{
    if (valid(entrance) && entrance.Type == ItemType::Grid && entrance.ProtoId == Content::Item::Entrance) {
        if (entrance.Grid_ToMapEntry == entry) {
            return true;
        }
        if (entry == "0" && entrance.Grid_ToMapEntry.str.isEmpty()) {
            return true;
        }
    }

    return false;
}

bool MapGetEntryCoords(Map map, int entry, int skip, mpos& hex)
{
    return MapGetEntryCoords(map, hstring("" + entry), skip, hex);
}

bool MapGetEntryCoords(Map map, hstring entry, int skip, mpos& hex)
{
    if (valid(map)) {
        auto staticItems = map.GetStaticItems();
        int skipped = 0;
        for (int i = 0; i < staticItems.length(); i++) {
            StaticItem staticItem = staticItems[i];
            if (EntryMatch(entry, staticItem)) {
                if (skipped == skip) {
                    hex = staticItem.Hex;
                    return true;
                }
                skipped++;
            }
        }
    }
    return false;
}

hstring[] MapGetAllEntries(Map map)
{
    hstring[] entryNames = {};
    if (valid(map)) {
        auto staticItems = map.GetStaticItems();
        int skipped = 0;
        for (int i = 0; i < staticItems.length(); i++) {
            StaticItem staticItem = staticItems[i];
            if (staticItem.Type == ItemType::Grid && staticItem.ProtoId == Content::Item::Entrance) {
                entryNames.insertLast(staticItem.Grid_ToMapEntry);
            }
        }
    }

    return entryNames;
}

bool CritterTransferToMapEntry(Critter cr, ident mapId, hstring entry)
{
    Map map = Game.GetMap(mapId);
    if (valid(cr) && valid(map)) {
        int entries = Entrance::MapCountEntry(map, entry);
        if (entries > 0) {
            int skip = Game.Random(0, entries - 1);
            mpos hex;
            if (Entrance::MapGetEntryCoords(map, entry, skip, hex)) {
                cr.TransferToMap(map, hex, Game.Random(0, 5));
                return true;
            }
        }
    }
    Game.Log("CritterTransferToMapEntry failed");
    return false;
}

#endif

}
