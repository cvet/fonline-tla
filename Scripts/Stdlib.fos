// FOS Server
// Author: heX, cvet, Tab10id

// Npc scan radius
#define WARN_DIST (10)

// Roll vs skill
#define ROLL_CRITICAL_FAILURE (0)
#define ROLL_FAILURE          (1)
#define ROLL_SUCCESS          (2)
#define ROLL_CRITICAL_SUCCESS (3)

int RollVsSkill(Critter cr, CritterProperty skill, int bonus)
{
    int skVal = cr.GetAsInt(skill);
    int r = Random(1, 100);

    if (skVal + bonus >= r) {
        if (Random(1, 100) <= (((skVal - r) / 10) + cr.CriticalChanceBase))
            return ROLL_CRITICAL_SUCCESS;
        else
            return ROLL_SUCCESS;
    }
    else {
        if (Random(1, 100) <= (r - skVal) / 10)
            return ROLL_CRITICAL_FAILURE;
        else
            return ROLL_FAILURE;
    }
}

bool IsSuccessRvS(int val)
{
    return val == ROLL_CRITICAL_SUCCESS || val == ROLL_SUCCESS;
}

bool IsCriticalRvS(int val)
{
    return val == ROLL_CRITICAL_SUCCESS || val == ROLL_CRITICAL_FAILURE;
}

void HealCritter(Critter player)
{
    if (player.IsDead())
        CritterState::ToLife(player);
    player.CurrentHp = player.MaxLife;
}

bool TransitToLoc(Critter cr, hstring locPid, uint mapIndex, uint entranceNum)
{
    Location loc = GetLocationByPid(locPid, 0);
    if (not valid(loc))
        return false;

    Map map = loc.GetMapByIndex(mapIndex);
    if (not valid(map))
        return false;

    Effects::FlushScreen(cr, true, 3000);
    return Obsolete::CritterTransitToMapEntire(cr, map.Id, HASHI(entranceNum));
}

bool TransitToMap(Critter cr, hstring mapPid, uint entranceNum)
{
    Map map = GetMapByPid(mapPid, 0);
    if (not valid(map))
        return false;

    Effects::FlushScreen(cr, true, 3000);
    return Obsolete::CritterTransitToMapEntire(cr, map.Id, HASHI(entranceNum));
}

bool TransitToNewLocation(Critter cr, hstring locPid)
{
    Critter[] group = {cr};

    Location loc = CreateLocation(locPid, cr.WorldX, cr.WorldY, group);
    if (!valid(loc))
        return false;

    loc.Hidden = true;
    loc.GeckVisible = false;
    loc.AutoGarbage = true;

    Effects::FlushScreen(cr, true, 3000);
    return Obsolete::CritterTransitToMapEntire(cr, loc.GetMapByIndex(0).Id, HASHI(0));
}

void InfoMessage(Critter player, Critter npc, uint strNum)
{
    player.SayMsg(SAY_NETMSG, TEXTMSG_DLG, DLGSTR(npc.DialogId, strNum));
}

void NpcMessageNorm(Critter npc, uint strNum)
{
    npc.SayMsg(SAY_NORM_ON_HEAD, TEXTMSG_DLG, DLGSTR(npc.DialogId, strNum));
}

void NpcMessageShout(Critter npc, uint strNum)
{
    npc.SayMsg(SAY_SHOUT_ON_HEAD, TEXTMSG_DLG, DLGSTR(npc.DialogId, strNum));
}

void NpcMessageWhisp(Critter npc, uint strNum)
{
    npc.SayMsg(SAY_WHISP_ON_HEAD, TEXTMSG_DLG, DLGSTR(npc.DialogId, strNum));
}

void NpcMessageEmo(Critter npc, uint strNum)
{
    npc.SayMsg(SAY_EMOTE_ON_HEAD, TEXTMSG_DLG, DLGSTR(npc.DialogId, strNum));
}

void TimeoutSet(Critter npc, uint gameHours)
{
    npc.DialogTimeout = GetFullSecond() + gameHours * 60 * 60;
}

void TimeoutSub(Critter npc, uint gameHoursSub)
{
    npc.DialogTimeout -= gameHoursSub * 60 * 60;
}

void TimeoutAdd(Critter npc, uint gameHoursAdd)
{
    npc.DialogTimeout += gameHoursAdd * 60 * 60;
}

void Warn(Critter player, int npcRole)
{
    if (not player.IsPlayer())
        return;

    Critter npc = GetNearCritterWithRole(player.GetMap(), player.HexX, player.HexY, WARN_DIST, npcRole);
    if (not valid(npc))
        return;

    npc.SayMsg(SAY_NORM_ON_HEAD, TEXTMSG_TEXT, 1001);
}

void DoorControl(Critter player, uint entireNum, bool toOpen)
{
    Map map = player.GetMap();
    uint16 x = 0, y = 0;
    if (valid(map) && Entire::MapGetEntireCoords(map, hstring("" + entireNum), 0, x, y)) {
        Item door = Obsolete::MapGetDoor(map, x, y);
        if (valid(door)) {
            Lockers::SwitchLocker(door, toOpen);
        }
    }
}

bool DialogNpc(Critter player, int role)
{
    if (not player.IsPlayer())
        return false;

    Critter npc = GetNearCritterWithRole(player.GetMap(), player.HexX, player.HexY, WARN_DIST, role);
    if (not valid(npc))
        return false;

    player.Wait(0);
    return RunDialog(player, npc, true);
}

Critter GetNearCritterWithRole(Map map, uint16 hexX, int hexY, uint radius, int role)
{
    Critter[] critters = {};
    uint count = Obsolete::GetCrittersHex(map, hexX, hexY, radius, FIND_LIFE, critters);
    uint minDist = 10000;
    Critter nearCrit = null;
    for (uint i = 0; i < count; i++) {
        if (critters[i].NpcRole == uint(role)) {
            uint d = GetDistantion(hexX, hexY, critters[i].HexX, critters[i].HexY);
            if (d < minDist) {
                minDist = d;
                nearCrit = critters[i];
            }
        }
    }
    return nearCrit;
}

/**
   атаковать игрока
   Использовать этот тригер для охраны серьезных обьектов не рекомендуеться.
   param=1
 */
void Attack(Critter player, int npcRole)
{
    if (not player.IsPlayer())
        return;
    Map map = player.GetMap();
    uint count = map.GetNpcCount(npcRole, FIND_LIFE_AND_KO | FIND_ONLY_NPC);
    for (uint i = 0; i < count; i++)
        NpcPlanes::AddAttackPlane(map.GetNpc(npcRole, FIND_LIFE_AND_KO | FIND_ONLY_NPC, i), AI_PLANE_ATTACK_PRIORITY + 1, player);
    return;
}

/**
   охрана останавливает атаку
   param=1
 */
void AttackStop(Critter player, int npcRole)
{
    if (not player.IsPlayer())
        return;
    Map map = player.GetMap();
    uint npcCount = map.GetNpcCount(npcRole, FIND_LIFE_AND_KO | FIND_ONLY_NPC);
    NpcPlanes::NpcPlane[] planes = {};
    for (uint i = 0; i < npcCount; i++) {
        Critter npc = map.GetNpc(npcRole, FIND_LIFE_AND_KO | FIND_ONLY_NPC, i);
        planes.clear();
        uint count = NpcPlanes::GetPlanes(npc, planes);
        // проходимся по списку планов в поисках маркированного плана
        for (uint j = 0; j < count; j++)
            if ((planes[j].Attack_TargId == player.Id) and (planes[j].Priority == AI_PLANE_ATTACK_PRIORITY + 1))
                if (NpcPlanes::ErasePlane(npc, j))
                    EnemyStack::EraseEnemyFromStack(npc, player.Id);
    }
    return;
}

/**
   убивает игрока особой смертью
   type - тип смерти (Dead_*)
 */
void Kill(Critter player, int type)
{
    if (not player.IsPlayer())
        return;
    CritterState::ToDead(player, type, null);
    return;
}

/**
   повреждает игрока
   dmg - сколько
   type - тип повреждения (DAMAGE_*)
 */
void Damage(Critter player, int dmg, int type, int dir)
{
    if (not player.IsPlayer())
        return;
    Combat::InjureCritter(player, dmg, type, dir, 0);
    return;
}

/** Телепортирует игрока на указанную точке на карте в рамках указанной локации.
 *
 * param  cr           Перемещаемый криттер.
 * param  locPid       PID локации (см. b CITY.TXT).
 * param  mapIndex     Номер карты на локации.
 * param  entranceNum  Номер точки входа.
 *
 */
bool TransitToMap(Critter cr, int locPid, int mapIndex, int entranceNum)
{
    Location location = GetLocationByPid(locPid, 0);

    if (location is null) {
        Log("Location with given PID (" + locPid + ") isn't found");
        return false;
    }

    Map map = location.GetMapByIndex(mapIndex);

    if (map is null) {
        Log("Map with given index (" + mapIndex + ") isn't found on location with PID (" + locPid + ")");
        return false;
    }

    if (cr.IsPlayer()) {
        Effects::FlushScreen(cr, true, 3000);
    }

    return Obsolete::CritterTransitToMapEntire(cr, map.Id, HASHI(entranceNum));
}

// Динамическая награда за квесты
// base = база расчета опыта в процентах от уровня, от 1 до 25 макс
void QuestRewardExperience(Critter cr, uint8 base)
{
    cr.Experience += CLAMP((cr.Level * 1000) * CLAMP(base, 1, 100) / 100, 0, 100000);
}

// Устанавливает прирост навыка в зависимости от уровня навыка криттера
#define STR_SKILL_UP (15)
void SkillUp(Critter player, CritterProperty skill)
{
    uint value = 9; // Базовый прирост, навык меньше 81
    if (player.GetAsInt(skill) > 80 && player.GetAsInt(skill) < 101)
        value = 7;
    if (player.GetAsInt(skill) > 100)
        value = 5;
    player.SetAsInt(skill, player.GetAsInt(skill) + value);
    player.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_SKILL_UP, "$skill @msg GAME " + ((10000 + skill) * 10 + 1) + "@" + "$value" + value);
}
