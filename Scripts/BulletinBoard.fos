namespace BulletinBoard
{

#if SERVER

// Author: rifleman17
// Доска объявлений с возможностью оставлять сообщения

///@ Property Critter PrivateServer int32 BBMsgPage
///@ Property Critter PrivateServer int32 BBSelectedMsg
///@ Property Critter PrivateServer int32 KlamAldoBusy
///@ Property Critter PrivateServer ident KlamAldoListenId
///@ Property Critter PrivateServer ident KlamAldoReaderId
///@ Property Critter PrivateServer ident=>int32 BBMsgCount

///@ Property Map PrivateServer ident KlamAldoId

///@ Property Game PrivateServer uint8[] BulletinBoard

// #define DL#(s) (Game.Log(s))
#define DL #(s)

class BBMessage
{
    int Idx;
    ident MapId;
    ident WriterId;
    ident ReaderId;
    synctime WriteTime;
    string Message;
}

class BBMessenger
{
    int MsgCount;
    BBMessage[] Messages = {};

    BBMessenger()
    {
        MsgCount = 0;
    }

    void ClearExpiredMessages()
    {
        for (int i = 0; i < MsgCount; i++) {
            if (Expired(Messages[i])) {
                Messages.removeAt(i);
                MsgCount = Messages.length();
                i--;
            }
        }
    }

    void AddMessage(ident mapId, ident writer, ident reader, synctime when, string message)
    {
        BBMessage msg;
        msg.Idx = Messages.length();
        msg.MapId = mapId;
        msg.WriterId = writer;
        msg.ReaderId = reader;
        msg.WriteTime = (when == ZERO_SYNCTIME ? Game.SynchronizedTime : when);
        msg.Message = message;
        Messages.insertLast(msg);
        MsgCount = Messages.length();
    }

    void ContinueMessage(ident mapId, ident writer, ident reader, string message)
    {
        BBMessage msg;
        for (int i = 0; i < MsgCount; i++) {
            if (Messages[i].MapId == mapId && Messages[i].WriterId == writer && Messages[i].ReaderId == reader) {
                Messages[i].Message += message;
                return;
            }
        }
    }

    void Save()
    {
        ClearExpiredMessages();

        MsgCount = Messages.length();

        auto save = Serializator::Serializator();
        save.Set(MsgCount);

        for (int i = 0; i < MsgCount; i++) {
            save.Set(Messages[i].MapId);
            save.Set(Messages[i].WriterId);
            save.Set(Messages[i].ReaderId);
            save.Set(Messages[i].WriteTime);
            save.Set(Messages[i].Message);
        }

        Game.BulletinBoard = save.GetData();
    }

    void Load()
    {
        ident mapId, writer, reader;
        synctime when;
        string message;

        auto load = Serializator::Serializator();
        if (load.SetData(Game.BulletinBoard) == 0) {
            return;
        }
        Messages.clear();

        load.Get(MsgCount);
        for (int i = 0; i < MsgCount; i++) {
            load.Get(mapId);
            load.Get(writer);
            load.Get(reader);
            load.Get(when);
            load.Get(message);
            AddMessage(mapId, writer, reader, when, message);
        }
        ClearExpiredMessages();
    }

    BBMessage GetMessage(int idx)
    {
        if (idx < MsgCount) {
            return Messages[idx];
        }
        return null;
    }

    BBMessage[] GetPrivateMessages(ident mapId, ident readerId)
    {
        BBMessage[] messages = {};
        for (int i = 0; i < MsgCount; i++) {
            if (Messages[i].MapId == mapId && Messages[i].ReaderId == readerId) {
                messages.insertLast(Messages[i]);
            }
        }
        return messages;
    }

    BBMessage GetSelfMessage(ident mapId, ident writerId)
    {
        for (int i = 0; i < MsgCount; i++) {
            if (Messages[i].MapId == mapId && Messages[i].WriterId == writerId) {
                return Messages[i];
            }
        }
        return null;
    }

    void RemoveSelfMessages(ident mapId, ident writerId)
    {
        BBMessage msg = GetSelfMessage(mapId, writerId);
        if (valid(msg)) {
            Messages.removeAt(msg.Idx);
        }
        MsgCount = Messages.length();
        Reindex();
    }

    void Reindex()
    {
        for (int i = 0; i < MsgCount; i++) {
            Messages[i].Idx = i;
        }
    }

    BBMessage GetRandomMessage(ident mapId)
    {
        BBMessage msg;
        int counter = 0;
        while (counter < 20 && Messages.length() > 0) {
            counter++;
            msg = Messages[Game.Random(0, Messages.length() - 1)];
            if (msg.ReaderId == ZERO_IDENT) {
                return msg;
            }
        }
        return null;
    }

    // readFrom - порядковый номер в уже отобранных публичных объявлениях
    BBMessage[] GetPublicMessages(ident mapId, int readFrom, int count)
    {
        int[] msgIds = {};
        BBMessage[] messages = {};
        for (int i = 0; i < MsgCount; i++) {
            if (Messages[i].ReaderId == ZERO_IDENT) {
                msgIds.insertLast(Messages[i].Idx);
            }
        }
        for (int i = readFrom; i < readFrom + count && i < msgIds.length(); i++) {
            messages.insertLast(Messages[msgIds[i]]);
        }
        return messages;
    }

    int CountPublicMessages(ident mapId)
    {
        int count = 0;
        for (int i = 0; i < MsgCount; i++) {
            if (Messages[i].MapId == mapId && Messages[i].ReaderId == ZERO_IDENT) {
                count++;
            }
        }
        return count;
    }

    bool Expired(BBMessage msg)
    {
        // Персональные сообщения хранятся дольше.
        if (msg.ReaderId == ZERO_IDENT) {
            if (msg.WriteTime + Time::GameDays(20 * 7) < Game.SynchronizedTime) {
                return true;
            }
        }
        else {
            if (msg.WriteTime + Time::GameDays(80 * 7) < Game.SynchronizedTime) {
                return true;
            }
        }
        return false;
    }
}

BBMessenger Messenger;

void StartMessenger()
{
    Messenger.Load();
}

void SaveMessengerData()
{
    Messenger.Save();
}

// Функционал для досок
bool d_IsSelfMsg(Critter cr, Critter npc)
{
    Map map = cr.GetMap();
    if (valid(map)) {
        return valid(Messenger.GetSelfMessage(map.Id, cr.Id));
    }
    return false;
}

bool d_NotSelfMsg(Critter cr, Critter npc)
{
    return !d_IsSelfMsg(cr, npc);
}

bool d_IsPrivateMsg(Critter cr, Critter npc)
{
    Map map = cr.GetMap();
    if (valid(map)) {
        return (Messenger.GetPrivateMessages(map.Id, cr.Id).length() > 0);
    }
    return false;
}

bool d_NotPrivateMsg(Critter cr, Critter npc)
{
    return !d_IsPrivateMsg(cr, npc);
}

bool d_IsPrivateMsg(Critter cr, Critter npc, int numMsg, int msgPerPage)
{
    Map map = cr.GetMap();
    if (valid(map)) {
        return Messenger.GetPrivateMessages(map.Id, cr.Id).length() > int(cr.BBMsgPage * msgPerPage + numMsg);
    }
    return false;
}

// lex msg1
void dlg_PrivateMsg5(Critter cr, Critter npc, string& lexems)
{
    if (!IS_DIALOG_GENERATED(lexems)) {
        return;
    }

    int msgPerPage = 5;
    lexems = "";
    Map map = cr.GetMap();
    BBMessage[] messages = Messenger.GetPrivateMessages(map.Id, cr.Id);
    int msg = 1;
    for (int i = msgPerPage * cr.BBMsgPage; i < messages.length(); i++) {
        lexems += "$msg" + msg + "" + Obsolete::GetPlayerName(messages[i].WriterId);
        msg++;
    }
}

void r_SetPrivateMsg(Critter cr, Critter npc, int numMsg, int msgPerPage)
{
    cr.BBSelectedMsg = Messenger.GetPrivateMessages(cr.GetMap().Id, cr.Id)[msgPerPage * cr.BBMsgPage + numMsg].Idx;
}

void dlg_GetMsg(Critter cr, Critter npc, string& lexems)
{
    if (!IS_DIALOG_GENERATED(lexems)) {
        return;
    }

    BBMessage m = Messenger.GetMessage(cr.BBSelectedMsg);
    lexems = "$fromWho" + Obsolete::GetPlayerName(m.WriterId) + "$msg" + m.Message;
}

bool d_IsPublicMsg(Critter cr, Critter npc)
{
    return Messenger.CountPublicMessages(cr.GetMap().Id) > 0;
}

bool d_NotPublicMsg(Critter cr, Critter npc)
{
    return !d_IsPublicMsg(cr, npc);
}

bool d_IsPublicMsg(Critter cr, Critter npc, int numMsg, int msgPerPage)
{
    return (Messenger.GetPublicMessages(cr.GetMap().Id, cr.BBMsgPage * msgPerPage, msgPerPage + numMsg).length() > int(numMsg));
}

void r_SetPublicMsg(Critter cr, Critter npc, int numMsg, int msgPerPage)
{
    BBMessage[] messages = Messenger.GetPublicMessages(cr.GetMap().Id, cr.BBMsgPage * msgPerPage, msgPerPage + numMsg);
    if (messages.length() > int(numMsg)) {
        cr.BBSelectedMsg = messages[numMsg].Idx;
    }
}

int r_SetRandomMsg(Critter cr, Critter npc)
{
    BBMessage msg = Messenger.GetRandomMessage(cr.GetMap().Id);
    if (valid(msg)) {
        cr.BBSelectedMsg = msg.Idx;
        return 5;
    }
    return 8;
}
// lex msg1
void dlg_PublicMsg5(Critter cr, Critter npc, string& lexems)
{
    if (!IS_DIALOG_GENERATED(lexems)) {
        return;
    }

    int msgPerPage = 5;
    lexems = "";
    Map map = cr.GetMap();
    BBMessage[] messages = Messenger.GetPublicMessages(map.Id, cr.BBMsgPage * 5, 5);
    int msg = 1;
    for (int i = 0; i < messages.length(); i++) {
        lexems += "$msg" + msg + "" + Obsolete::GetPlayerName(messages[i].WriterId);
        msg++;
    }
}

// Альдо и запись текста игрока на доску объявлений
#define ENTRY_ALDO     (31) // Гекс, к которому подходит Альдо перед началом записи
#define STR_CANT_REACH (1)  // Не могу к доске подобраться. Обожди, пока разойдутся все.
#define STR_IN_PLACE   (2) // Давай, говори, чего писать будем... Буду записывать все, что скажешь, после слова "Начали"
#define STR_FINISHED   (3) // Все готово, проверяй...
#define STR_NEXT       (4) // Если чего еще нужно написать, говори. Все после слова "Далее" я занесу сюда. Когда закончишь, скажи "Хватит".
#define DLG_NOTFOUND   (34) // Номер ветки диалога "нет таких..."
#define DLG_FOUND      (35) // Хорошо, напишем персональное объявление... Пойдем со мной, продиктуешь.
#define _RightKeyWord  #(text)(text.length() < KEYWORD.length() ? false : text.substr(0, KEYWORD.length()) == KEYWORD)
#define _RightKeyWord2 #(text)(text.length() < KEYWORD2.length() ? false : text.substr(0, KEYWORD2.length()) == KEYWORD2)
#define _RightKeyWord3 #(text)(text.length() < KEYWORD3.length() ? false : text.substr(0, KEYWORD3.length()) == KEYWORD3)
#define KEYWORD        ("Начали")
#define KEYWORD2       ("Далее")
#define KEYWORD3       ("Хватит")
#define _MsgFromText   #(text)(text.substr(6, text.length() - 1))
#define _MsgFromText2  #(text)(text.substr(5, text.length() - 1))

int dlg_GetReaderId(Critter cr, Critter npc, string& lexems)
{
    if (!IS_DIALOG_SAY_MODE(lexems)) {
        return 0;
    }

    Player player = Game.GetPlayer(lexems);
    if (!valid(player)) {
        return DLG_NOTFOUND;
    }

    npc.KlamAldoReaderId = player.GetControlledCritter().Id;
    return DLG_FOUND;
}

void r_MoveAldo(Critter player, Critter npc)
{
    if (!valid(npc)) {
        return;
    }

    Map map = npc.GetMap();
    if (not valid(map)) {
        return;
    }

    npc.KlamAldoBusy = 1;
    if (!NpcPlanes::AddWalkPlane(npc, ENTRY_ALDO, 0, false)) {
        Messaging::SayOnHead(npc, TextPackName::Dialogs, DLGSTR(npc.DialogId, STR_CANT_REACH));
        npc.KlamAldoBusy = 0;
        return;
    }

    map.KlamAldoId = npc.Id;
    npc.KlamAldoListenId = player.Id;
    npc.KlamAldoBusy = 1;
    npc.OnNpcPlaneEnd.Subscribe(_AldoPlaneEnd);
    if (npc.CountTimeEvent(cte_ClearVars) == 0) {
        npc.StartTimeEvent(Time::Minutes(10), cte_ClearVars);
    }
}

bool _AldoPlaneEnd(Critter cr, int planeId, int reason, Critter someCr, Item someItem)
{
    NpcPlanes::NpcPlane plane = NpcPlanes::GetCritterPlane(cr, planeId);

    if (cr.KlamAldoBusy == 1 && plane.Type == AI_PLANE_WALK && reason == REASON_SUCCESS) {
        cr.KlamAldoBusy = 2;
        Messaging::SayOnHead(cr, TextPackName::Dialogs, DLGSTR(cr.DialogId, STR_IN_PLACE));
        // Todo: Game.AddTextListener(SAY_NORM, KEYWORD, cr.GetMap().ProtoId.hash, listen_FirstMessage);
        NpcPlanes::AddMiscPlane(cr, 0, Game.SynchronizedTime + Time::Minutes(2), BulletinBoard::plane_AldoFinished);
        if (cr.CountTimeEvent(cte_ClearVars) == 0) {
            cr.StartTimeEvent(Time::Minutes(10), cte_ClearVars);
        }
        // cr.SetEvent( CRITTER_EVENT_PLANE_END, "" );
        cr.OnNpcPlaneEnd.Unsubscribe(_AldoPlaneEnd);
        // return PLANE_DISCARD;
        return false;
    }
    // return PLANE_RUN_GLOBAL;
    return true;
}

void listen_Next(Critter player, string text)
{
    Map map = player.GetMap();
    if (not valid(map)) {
        return;
    }

    Critter cr = Game.GetCritter(map.KlamAldoId);
    if (valid(cr) && _RightKeyWord2(text)) {
        dict<ident, int> bbMsgCount = player.BBMsgCount.clone();
        if (bbMsgCount.get(cr.Id, 0) >= 3) {
            ClearTempVariables(cr);
            Messaging::SayOnHead(cr, TextPackName::Dialogs, DLGSTR(cr.DialogId, 6));
            NpcPlanes::AddWalkPlane(cr, 0, cr.HomeHexX, cr.HomeHexY, cr.HomeDir, false, 0);
            return;
        }
        else {
            bbMsgCount[cr.Id] = bbMsgCount.get(cr.Id, 0) + 1;
            player.BBMsgCount = bbMsgCount;
        }

        if (cr.KlamAldoListenId == player.Id) {
            Messenger.ContinueMessage(map.Id, cr.KlamAldoListenId, cr.KlamAldoReaderId, "\n" + _MsgFromText2(text));
            // ClearTempVariables(cr);
            // cr.AddTimeEvent(cte_SayMsgSaved, Settings.TimeMultiplier*2, CTE_CONFIRM_SAVE);
            Messaging::SayOnHead(cr, TextPackName::Dialogs, DLGSTR(cr.DialogId, 5));
        }
    }
}

void listen_End(Critter player, string text)
{
    Map map = player.GetMap();
    if (not valid(map)) {
        return;
    }

    Critter cr = Game.GetCritter(map.KlamAldoId);
    if (valid(cr) && _RightKeyWord3(text)) {
        ClearTempVariables(cr);
        cr.StartTimeEvent(Time::Seconds(2), cte_SayMsgSaved);
    }
}

void listen_FirstMessage(Critter player, string text)
{
    Map map = player.GetMap();
    if (not valid(map)) {
        return;
    }

    Critter cr = Game.GetCritter(map.KlamAldoId);
    if (valid(cr) && _RightKeyWord(text)) {
        if (cr.KlamAldoListenId == player.Id) {
            Messenger.RemoveSelfMessages(map.Id, player.Id);
            Messenger.AddMessage(map.Id, cr.KlamAldoListenId, cr.KlamAldoReaderId, ZERO_SYNCTIME, _MsgFromText(text));
            // ClearTempVariables(cr);
            cr.StartTimeEvent(Time::Seconds(2), cte_SayMsgFirstSaved);
        }
    }
}

void plane_AldoFinished(Critter cr)
{
    ClearTempVariables(cr);
    NpcPlanes::DropPlanes(cr);
}

void cte_SayMsgFirstSaved(Critter cr)
{
    Messaging::Say(cr, TextPackName::Dialogs, DLGSTR(cr.DialogId, STR_NEXT));
    hstring proto = cr.GetMap().ProtoId;
    // Todo: Game.AddTextListener(SAY_NORM, KEYWORD2, proto.hash, listen_Next);
    // Todo: Game.AddTextListener(SAY_NORM, KEYWORD3, proto.hash, listen_End);
    // Todo: Game.RemoveTextListener(SAY_NORM, KEYWORD, proto.hash);
    return;
}

void cte_SayMsgSaved(Critter cr)
{
    hstring proto = cr.GetMap().ProtoId;
    // Todo: Game.RemoveTextListener(SAY_NORM, KEYWORD2, proto.hash);
    // Todo: Game.RemoveTextListener(SAY_NORM, KEYWORD3, proto.hash);
    Messaging::SayOnHead(cr, TextPackName::Dialogs, DLGSTR(cr.DialogId, STR_FINISHED));
    NpcPlanes::AddWalkPlane(cr, 0, cr.HomeHexX, cr.HomeHexY, cr.HomeDir, false, 0);
    return;
}

void cte_ClearVars(Critter cr)
{
    ClearTempVariables(cr);
    return;
}

void ClearTempVariables(Critter cr)
{
    if (cr.KlamAldoBusy > 0) {
        cr.KlamAldoBusy = 0;
    }

    cr.KlamAldoListenId = ZERO_IDENT;
    cr.KlamAldoReaderId = ZERO_IDENT;

    // Todo: Game.RemoveTextListener(SAY_NORM, KEYWORD, cr.GetMap().ProtoId.hash);
    // Todo: Game.RemoveTextListener(SAY_NORM, KEYWORD2, cr.GetMap().ProtoId.hash);
    // Todo: Game.RemoveTextListener(SAY_NORM, KEYWORD3, cr.GetMap().ProtoId.hash);

    if (cr.CountTimeEvent(cte_ClearVars) != 0) {
        cr.StopTimeEvent(cte_ClearVars);
    }

    NpcPlanes::DropPlanes(cr);
}

// debug
void drop_planes(Critter cr, any crId)
{
    Critter npc = Game.GetCritter(crId);
    if (valid(npc)) {
        NpcPlanes::DropPlanes(npc);
        return;
    }
    Messaging::Info(cr, "cr invalid");
}

void add_public_msg(Critter cr, int numMsg, any readerId, any writerId)
{
    if (!valid(cr.GetMap())) {
        return;
    }

    ident mapId = cr.GetMap().Id;
    for (int i = 0; i < numMsg; i++) {
        Messenger.AddMessage(mapId, (ident(writerId) == ZERO_IDENT ? cr.Id : ident(writerId)), readerId, ZERO_SYNCTIME, "message #" + i);
    }
}

void save(Critter cr)
{
    Messenger.Save();
}

void load(Critter cr)
{
    Messenger.Load();
}

void GetMsg(Critter cr, int id)
{
    Messaging::Info(cr, "Idx" + Messenger.Messages[id].Idx + " " + Messenger.Messages[id].Message);
}

void ResetBBMsgCount(Critter cr, Critter npc)
{
    auto values = cr.BBMsgCount.clone();
    values[npc.Id] = 0;
    cr.BBMsgCount = values;
}

#endif

}
