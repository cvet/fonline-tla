namespace HubLab
{

#if SERVER

// Author: rifleman17
// Скрипты для квестовой локации "лаборатория хабологов".

///@ Property Critter Protected     uint8 SFAhs7Escort Group = Quests Quest = 4434 Max = 3
///@ Property Critter PrivateServer ident SFHonomerPlayerId
///@ Property Critter PrivateServer ident SFEscortLocation
///@ Property Critter PrivateServer uint8 SFLabFailed Max = 1
///@ Property Critter PrivateServer bool  QHubLabIsDialogRun

///@ Property Map PrivateServer bool SFLabHonomerInside

#define ENTRY_HONOMER      (HASHI(43)) // Место спавна проводника.
#define ENTRY_LAB_ENTER    (HASHI(1))  // Место, куда приходит нпц с сопровождающим
#define CTE_CLEAR_FOLLOWER (121)
#define LAB_WORLD_X        (532)
#define LAB_WORLD_Y        (1435)
#define DIALOG_GUARD       (2)
#define ROLE_GUARD         (18)
#define ENTRY_DOOR_NEAR    (HASHI(19)) // Гекс перед дверью, на котором будет переходить хономер перед ее открытием
#define ENTRY_REPAIR       (HASHI(20)) // Гекс на котором Хономер останавливается для ремонта
#define ENTRY_DOOR         (HASHI(21)) // Гекс под дверью
#define MSG_DIALOG_END     (4023)
#define ROLE_START_DIALOG  (22) // Роль нпц, который затевает обсуждение произошедшего
#define STR_ALARM          (8030)
#define STR_OPEN           (8031)
#define MSG_OPEN           (4024)
#define ENTRY_HELL         (HASHI(242))

// #define DL #(s) (Game.Log("" + s))
#define DL #(s)

// Квест "Секретная лаборатория хабологов".
bool d_IsHonomerNear(Critter player, Critter npc)
{
    Map map = player.GetMap();
    Critter[] critters = map.GetCritters(Content::Critter::ElronologistFemale, CritterFindType::NonDeadNpc);
    for (int i = 0; i < critters.length(); i++) {
        if (critters[i].DialogId == Content::Dialog::sf_honomer) {
            return true;
        }
    }
    return false;
}

bool d_NoHonomerNear(Critter player, Critter npc)
{
    return !d_IsHonomerNear(player, npc);
}

// Добавление проводника на карту sf_hubb.
void AddNewHonomer()
{
    Map map = Game.GetMap(Content::Map::sf_hubb);
    mpos hex;
    if (valid(map) && Entrance::GetNearEntry(map, ENTRY_HONOMER, hex)) {
        Critter[] critters = map.GetCritters(Content::Critter::ElronologistFemale, CritterFindType::Npc);
        for (int i = 0; i < critters.length(); i++) {
            if (critters[i].DialogId == Content::Dialog::sf_honomer) {
                return;
            }
        }
        int[] props = {CritterProperty::DialogId, Content::Dialog::sf_honomer.hash};
        Critter npc = map.AddCritter(Content::Critter::ElronologistFemale, hex, Game.Random(0, 5), Tla::GetCritPropsDict(props));
        npc.SetupScript(_HonomerInit);
    }
}

void _HonomerInit(Critter cr, bool firstTime)
{
    cr.OnGlobalMapProcess.Subscribe(_HonomerGlobalProcess);
    cr.OnFinish.Subscribe(_HonomerFinish);
    cr.OnDead.Subscribe(_HonomerDead);
    cr.StartTimeEvent(Time::Asap(), Time::Seconds(1), _HonomerIdle);
    cr.OnMessage.Subscribe(_HonomerMessage);
    cr.OnNpcPlaneEnd.Subscribe(_HonomerPlaneEnd);
}

void _HonomerMessage(Critter cr, Critter fromCr, int message, any value)
{
    if (value == 2 || value == 4) {
        NpcDialog::_NpcMessage(cr, fromCr, message, value);
    }
}

bool _HonomerPlaneEnd(Critter cr, int planeId, int reason, Critter someCr, Item someItem)
{
    NpcPlanes::NpcPlane plane = NpcPlanes::GetCritterPlane(cr, planeId);

    if (NpcPlanes::IsNoPlanes(cr) && d_HonomerInLab(cr, cr)) {
        mpos hex;
        Map map = cr.GetMap();
        if (valid(map) && Entrance::MapGetEntryCoords(map, ENTRY_DOOR_NEAR, 0, hex)) {
            if (hex == cr.Hex) {
                // Хономер стоит перед дверью
                // Открываем дверь и даем план на продвижение к компу
                Entrance::MapGetEntryCoords(map, ENTRY_DOOR, 0, hex);
                Item door = map.GetItem(hex, Content::Item::door_2019);
                if (valid(door)) {
                    Lockers::SwitchLocker(door, true);
                    Game.StartTimeEvent(Time::Seconds(1), Item::AutoCloseDoor, door.Id); //SavedDeferredCall
                }
                if (Entrance::MapGetEntryCoords(map, ENTRY_REPAIR, 0, hex)) {
                    cr.HomeMapId = map.Id;
                    cr.HomeHex = hex;
                    cr.HomeDir = 0;
                }
                return true;
            }
        }
        if (valid(map) && Entrance::MapGetEntryCoords(map, ENTRY_REPAIR, 0, hex)) {
            if (plane.Type != AI_PLANE_MISC) {
                if (hex == cr.Hex) {
                    NpcDialog::BeginDialog(cr, 4);
                }
            }
            else {
                if (Game.Random(1, 3) == 1) {
                    _CritAnimateUse(cr);
                }
            }
        }
    }
    return true;
}

void _HonomerDead(Critter cr, Critter killer)
{
    _HonomerIdle(cr);
}

bool _HonomerGlobalProcess(Critter cr, int type, Item car, float x, float y, float toX, float toY, float speed, int encounterDescriptor, bool waitForAnswer)
{
    if (type != Tla::GlobalProcessStartFast && type != Tla::GlobalProcessStart) {
        bool ok = false;
        Critter[] group = GlobalmapGroupExtended::GetGlobalGroup(cr);
        // Проверка что игрок в группе с нпц
        Critter player = Game.GetCritter(cr.SFHonomerPlayerId);
        if (valid(player)) {
            for (int i = 0, l = group.length(); i < l; i++) {
                if (group[i].Id == player.Id) {
                    ok = true;
                    break;
                }
            }
        }

        if (!ok) {
            // Нет игрока в группе
            Game.DestroyCritter(cr);
            return true;
        }
    }

    if (type != Tla::GlobalProcessMove) {
        if (cr.SFEscortLocation != ZERO_IDENT) {
            Location loc = Game.GetLocation(cr.SFEscortLocation);
            if (valid(loc)) {
                if (loc.WorldPos.x == int(x) && loc.WorldPos.y == int(y)) {
                    Map map = loc.GetMapByIndex(1);
                    Obsolete::CritterTransitToMapEntry(cr, map.Id, ENTRY_LAB_ENTER);
                    loc.AutoGarbage = true;
                    cr.StartTimeEvent(Time::Asap(), Time::Seconds(1), _HonomerIdle);
                    if (cr.SFHonomerPlayerId != ZERO_IDENT) {
                        Critter player = Game.GetCritter(cr.SFHonomerPlayerId);
                        if (valid(player) && player.SFAhs7Escort == 2) {
                            player.SFAhs7Escort = 3;
                            player.Experience += 1000;
                        }
                    }
                    NpcDialog::BeginDialog(cr, DIALOG_GUARD);
                }
                else {
                    speed = GLOBAL_MAP_BASE_SPEED;
                    toX = loc.WorldPos.x;
                    toY = loc.WorldPos.y;
                }
                return true;
            }
        }
        // не найдена локация или переменная
        // такого произойти не может, но на всякий случай...
        Game.DestroyCritter(cr);
        return true;
    }
    return false;
}

void _HonomerIdle(Critter cr)
{
    if (valid(cr.GetMap()) && cr.GetMap().Id != cr.HomeMapId) {
        cr.HomeMapId = cr.GetMap().Id;
        cr.HomeHex = cr.Hex;
        cr.HomeDir = 0;
    }

    Game.StopCurrentTimeEvent();
}

void _HonomerFinish(Critter cr)
{
    AddNewHonomer();
}

bool d_HonomerInLab(Critter player, Critter npc)
{
    Map map = npc.GetMap();
    return (valid(map) && (map.GetLocation().ProtoId == Content::Location::hubologists_lab));
}

bool d_NotHonomerInLab(Critter player, Critter npc)
{
    return !d_HonomerInLab(player, npc);
}

bool d_IsMyFollower(Critter player, Critter npc)
{
    return valid(npc) && npc.SFHonomerPlayerId == player.Id;
}

bool d_NotMyFollower(Critter player, Critter npc)
{
    return !d_IsMyFollower(player, npc);
}

void r_SetFollower(Critter player, Critter npc)
{
    if (not valid(npc)) {
        return;
    }

    npc.SFHonomerPlayerId = player.Id;
    // Через игровой день сбрасываем Id
    if (npc.CountTimeEvent(cte_ClearFollower) > 0) {
        npc.StopTimeEvent(cte_ClearFollower);
    }
    npc.StartTimeEvent(Time::GameDays(1), cte_ClearFollower, 0);
}

void cte_ClearFollower(Critter cr, any rate)
{
    cr.SFHonomerPlayerId = ZERO_IDENT;
    return;
}

void r_Travel(Critter player, Critter npc)
{
    Location loc;
    if (player.SFEscortLocation != ZERO_IDENT) {
        loc = Game.GetLocation(player.SFEscortLocation);
    }

    if (not valid(loc)) {
        loc = Location::CreateLocation(Content::Location::hubologists_lab, ipos(LAB_WORLD_X, LAB_WORLD_Y), null);
        if (!valid(loc)) {
            return;
        }

        loc.Hidden = true;
        loc.AutoGarbage = false;
    }

    npc.SFEscortLocation = loc.Id;
    player.SFEscortLocation = loc.Id;

    Critter[] grp = {};
    grp.insertLast(npc);
    grp.insertLast(player);
    npc.TransitToGlobal();
}

void AttackPlayer(Critter target)
{
    Map map = target.GetMap();
    if (!valid(map)) {
        return;
    }

    Location loc = map.GetLocation();
    int maps = loc.GetMapCount();
    for (int i = 0; i < maps; i++) {
        map = loc.GetMapByIndex(i);
        Critter[] critters = map.GetCritters(CritterFindType::Npc);
        for (int j = 0; j < critters.length(); j++) {
            Critter cr = critters[j];
            if (NpcRevenge::IsLocalNpc(cr, map) && !EnemyStack::CheckEnemyInStack(cr, target.Id)) {
                EnemyStack::AddEnemyToStack(cr, target.Id);
                NpcPlanes::AddAttackPlane(cr, 0, target);
            }
        }
    }
}

// Охранник лабы
void _DoorGuardInit(Critter cr, bool firstTime)
{
    cr.OnMessage.Subscribe(_DoorGuardMessage);
    cr.OnAttacked.Subscribe(_HubAttacked);
    cr.NpcRole = ROLE_GUARD;
}

bool _HubAttacked(Critter cr, Critter attacker)
{
    AttackPlayer(cr);
    return false;
}

void _DoorGuardMessage(Critter cr, Critter fromCr, int message, any value)
{
    if (value == 2) {
        NpcDialog::_NpcMessage(cr, fromCr, message, value);
    }

    if (message == MSG_DIALOG_END && value == 2) {
        mpos hex;
        if (Entrance::MapGetEntryCoords(cr.GetMap(), ENTRY_DOOR_NEAR, 0, hex) && hex != fromCr.HomeHex) {
            fromCr.HomeHex = hex;
        }
    }
}

// Дверь
void _DoorInit(Item item, bool firstTime)
{
    item.OnCritterUseSkill.Subscribe(_DoorSkill);
}

bool _DoorSkill(Item item, Critter cr, CritterProperty skill)
{
    if (cr.ControlledByPlayer && !cr.InSneakMode) {
        return Item::_GuardedItemSkill(item, cr, skill);
    }
    return false;
}

// Лаборанты
void _HubInit(Critter cr, bool firstTime)
{
    if (cr.NpcRole == ROLE_START_DIALOG) {
        cr.OnMessage.Subscribe(_HubMessage);
    }
    cr.OnAttacked.Subscribe(_HubAttacked);
}

void _HubMessage(Critter cr, Critter fromCr, int message, any value)
{
    if (value == 3) {
        NpcDialog::_NpcMessage(cr, fromCr, message, value);
    }
}

// Начало диалога между хабологами, когда игрок наступит на триггер
void t_NpcDialog(Critter player, StaticItem trigger, bool entered, uint8 dir)
{
    Map map = player.GetMap();
    Critter cr = player.GetMap().GetCritter(CritterProperty::NpcRole, ROLE_START_DIALOG, CritterFindType::NonDeadNpc);
    if (valid(cr) && not cr.QHubLabIsDialogRun && NpcPlanes::IsNoPlanes(cr)) {
        cr.QHubLabIsDialogRun = true;
        NpcDialog::BeginDialog(cr, 3);
    }
}

// Автоматическое закрытие двери, если Хономер вышел
void t_CloseDoor(Critter cr, StaticItem trigger, bool entered, uint8 dir)
{
    if (!cr.ControlledByPlayer && cr.DialogId == Content::Dialog::sf_honomer) {
        Map map = cr.GetMap();
        if (!map.SFLabHonomerInside) {
            map.SFLabHonomerInside = true;
            mpos hex;
            if (Entrance::MapGetEntryCoords(map, ENTRY_DOOR, 0, hex)) {
                Item door = map.GetItem(hex, Content::Item::door_2019);
                if (valid(door)) {
                    Lockers::SwitchLocker(door, false);
                }
            }
        }
    }
    // TODO: сделать открытие двери, если игрок наступил на триггер, дверь закрыта, и игрок в робе
}

// Если игрок не в робе наступил на триггер, будет атакован
void t_Attack(Critter cr, StaticItem trigger, bool entered, uint8 dir)
{
    if (cr.InSneakMode) {
        return;
    }

    hstring pid;
    Item item = _CritGetItemArmor(cr);
    if (valid(item)) {
        pid = item.ProtoId;
    }

    if (cr.ControlledByPlayer && pid != Content::Item::purple_robe && pid != Content::Item::keepbrige_robe && pid != Content::Item::black_robe) {
        Map map = cr.GetMap();
        if (valid(map) && cr.SFLabFailed == 0) {
            AttackPlayer(cr);
            Critter[] critters = map.GetCritters(trigger.Hex, map.Size.width, CritterFindType::NonDeadNpc);
            if (!critters.isEmpty()) {
                Messaging::SayShout(critters[0], TextPackName::Text, STR_ALARM);
            }
        }
    }
}

bool d_InRobe(Critter cr, Critter npc)
{
    hstring pid;
    Item item = _CritGetItemArmor(cr);
    if (valid(item)) {
        pid = item.ProtoId;
    }
    return (pid == Content::Item::purple_robe || pid == Content::Item::keepbrige_robe || pid == Content::Item::black_robe);
}

bool d_NotRobe(Critter player, Critter npc)
{
    return !d_InRobe(player, npc);
}

void r_ShowHell(Critter player, Critter npc)
{
    Map map = Game.GetMap(Content::Map::repl_hell);
    if (valid(map)) {
        mpos hex;
        if (Entrance::MapGetEntryCoords(map, ENTRY_HELL, 0, hex)) {
            player.ViewMap(map, 50, hex, 5);
        }
    }
}

#endif

}
