// FOS Server Sort -8

// TODO:: void FOServer::ProcessAI( Npc* npc ) from ServerNpc.cpp engine 1519

///@ Property Critter PrivateServer int[] Planes

///@ Event Server Game OnNpcPlaneBegin(Critter critter, int planeId, int reason, Critter someCr, Item someItem)
///@ Event Server Game OnNpcPlaneEnd(Critter critter, int planeId, int reason, Critter someCr, Item someItem)
///@ Event Server Game OnNpcPlaneRun(Critter critter, int planeId, int reason, any& result0, any& result1, any& result2)
///@ Event Server Critter OnNpcPlaneBegin(int planeId, int reason, Critter someCr, Item someItem)
///@ Event Server Critter OnNpcPlaneEnd(int planeId, int reason, Critter someCr, Item someItem)
///@ Event Server Critter OnNpcPlaneRun(int planeId, int reason, any& result0, any& result1, any& result2)

#define MAX_PLANES_PER_CRITTER (10)

// Planes types
#define AI_PLANE_MISC    (0)
#define AI_PLANE_ATTACK  (1)
#define AI_PLANE_WALK    (2)
#define AI_PLANE_PICK    (3)
#define AI_PLANE_PATROL  (4) // WIP
#define AI_PLANE_COURIER (5) // WIP

// Planes deault priority
#define AI_PLANE_MISC_PRIORITY    (10)
#define AI_PLANE_ATTACK_PRIORITY  (50)
#define AI_PLANE_WALK_PRIORITY    (20)
#define AI_PLANE_PICK_PRIORITY    (35)
#define AI_PLANE_PATROL_PRIORITY  (25)
#define AI_PLANE_COURIER_PRIORITY (30)

// Plane begin/end/run reasons
// Begin
#define REASON_GO_HOME              (10)
#define REASON_FOUND_IN_ENEMY_STACK (11)
#define REASON_FROM_DIALOG          (12)
#define REASON_FROM_SCRIPT          (13)
#define REASON_RUN_AWAY             (14)
// End
#define REASON_SUCCESS            (30)
#define REASON_HEX_TOO_FAR        (31)
#define REASON_HEX_BUSY           (32)
#define REASON_HEX_BUSY_RING      (33)
#define REASON_DEADLOCK           (34)
#define REASON_TRACE_FAIL         (35)
#define REASON_POSITION_NOT_FOUND (36)
#define REASON_FIND_PATH_ERROR    (37)
#define REASON_CANT_WALK          (38)
#define REASON_TARGET_DISAPPEARED (39)
#define REASON_USE_ITEM_NOT_FOUND (40)
#define REASON_GAG_CRITTER        (41)
#define REASON_GAG_ITEM           (42)
#define REASON_NO_UNARMED         (43)
// Run
#define REASON_ATTACK_TARGET     (50)
#define REASON_ATTACK_WEAPON     (51)
#define REASON_ATTACK_DISTANTION (52)
#define REASON_ATTACK_USE_AIM    (53)

void NL(Critter npc, string str)
{
    Game.Log(npc.Name + " - " + str);
    npc.Say(SAY_NORM_ON_HEAD, str);
}

funcdef void NpcPlaneMiscFunc(Critter cr);

void ModuleInit()
{
    Game.OnCritterIdle.Subscribe(OnCritterIdle);
}

void OnCritterIdle(Critter npc)
{
    if (npc.IsControlledByPlayer || CritterState::IsBusy(npc)) {
        return;
    }

    if (npc.IsAlive()) {
        const uint wait = ProcessAi(npc);
        if (wait != 0) {
            CritterState::Wait(npc, wait);
        }
    }
}

bool CheckHasEnoughAP(Critter cr, int ap)
{
    return cr.CurrentAp >= int(ap);
}

uint ProcessAi(Critter npc)
{
    // Check busy
    if (CritterState::IsBusy(npc)) {
        return 1000;
    }

    // Global map
    if (npc.MapId == ZERO_IDENT) {
        // TODO: global and groups
        /*if( !npc->GroupMove )
            return;
           MapMngr.GM_GlobalProcess( npc, npc->GroupMove, GLOBAL_PROCESS_NPC_IDLE );
           if( !npc->GetMapId() && !npc->IsWait() )
            npc->SetWait( GameOpt.CritterIdleTick );*/
        return 5000;
    }

    // Get map
    Map map = Game.GetMap(npc.MapId);
    if (map == null) {
        return 5000;
    }

    // Check turn based
    // TODO: turnbased
    // if( map->IsTurnBasedOn && !map->IsCritterTurn( npc ) )
    //    return;

    // Check wait
    // r17:
    /*if( npc->IsWait() )
       {
        if( map->IsTurnBasedOn )
            map->EndCritterTurn();
        return;
       }*/

    // Get current plane
    NpcPlane plane = GetCurPlane(npc);
    // Begin
    if (plane == null) {
        // Check talking
        if (npc.GetTalkingCritters().length() > 0) {
            return 2000;
        }

        // Enemy stack
        Critter enemy = EnemyStack::ScanEnemyStack(npc);
        if (enemy != null) {
            if (AddAttackPlane(npc, 0, enemy)) {
                return 0;
            }
        }

        // Go home
        if (!npc.IsNoHome && map.Id == npc.HomeMapId && (npc.HexX != npc.HomeHexX || npc.HexY != npc.HomeHexY)) {
            if (!npc.IsNoMove) {
                AddWalkPlane(npc, 0, 0, 0, npc.HomeHexX, npc.HomeHexY, npc.HomeDir, false, 0);
            }
            else if (map.IsHexesMovable(npc.HomeHexX, npc.HomeHexY, npc.Multihex)) {
                npc.TransitToMap(map, npc.HomeHexX, npc.HomeHexY, npc.HomeDir);
                return 0;
            }
        }
        // Set home direction
        else if (!npc.IsNoHome && map.Id == npc.HomeMapId && npc.Dir != npc.HomeDir) {
            npc.SetDir(npc.HomeDir);
        }
        return 0;
    }
    else {
        // Process move
        if (plane.IsMove) {
            // Check run availability
            if (plane.Run) {
                if (npc.IsDamagedRightLeg || npc.IsDamagedLeftLeg || npc.IsOverweight) {
                    plane.Run = false;
                }
            }

            // Check ap availability
            int ap_move = (plane.Run ? Settings.RtApCostCritterRun : Settings.RtApCostCritterWalk);

            // TODO:tb
            /*
               if( map->IsTurnBasedOn )
                    ap_move += npc->GetMoveAp();
             */
            plane.IsMove = false;
            if (!CheckHasEnoughAP(npc, ap_move)) {
                uint wait = Settings.ApRegeneration / npc.ActionPoints * (ap_move - npc.CurrentAp) / AP_DIVIDER;
                // npc->SetWait( GameOpt.ApRegeneration / npc->GetActionPoints() * ( (int) ( need_ap ) - npc->GetRealAp() ) / AP_DIVIDER );
                return wait;
            }
            plane.IsMove = true;

            MovingState state = npc.GetMovingState();
            if (state != MovingState::InProgress && state != MovingState::Success) {
                ident gagId;
                npc.GetMovingState(gagId);
                npc.StopMoving();

                int reason = REASON_TRACE_FAIL;
                switch (state) {
                case MovingState::GagCritter:
                    reason = REASON_GAG_CRITTER;
                    break;
                case MovingState::GagItem:
                    reason = REASON_GAG_ITEM;
                    break;
                }

                if (Game.OnNpcPlaneEnd.Fire(npc, plane.PlaneId, reason, Game.GetCritter(gagId), Game.GetItem(gagId))) {
                    ErasePlane(npc, 0); // TODO: возможно, здесь нужночто-то другое, не удалять план
                }
                return 0;
            }
        }

        bool is_busy = (plane.IsMove || CritterState::IsBusy(npc)); // || CritterState::IsWait(npc);

        // Process planes
        switch (plane.Type) {
        /************************************************************************/
        /* ==================================================================== */
        /* ========================   Misc   ================================== */
        /* ==================================================================== */
        /************************************************************************/
        case AI_PLANE_MISC: {
            if (is_busy) {
                break;
            }

            uint wait = plane.Misc_WaitSecond;
            NpcPlaneMiscFunc func = plane.Misc_Script;

            if (wait > Game.GetFullSecond()) {
                return ((wait - Game.GetFullSecond()) * 1000 / Settings.TimeMultiplier);
            }
            else if (func !is null) {
                func(npc);
            }
            else {
                NextPlane(npc, REASON_SUCCESS);
            }
        } break;
        /************************************************************************/
        /* ==================================================================== */
        /* ========================   Attack   ================================ */
        /* ==================================================================== */
        /************************************************************************/
        case AI_PLANE_ATTACK: {
            // TODO: tb
            // if( map->Data.IsTurnBasedAvailable && !map->IsTurnBasedOn )
            //	map->BeginTurnBased( npc );

            /************************************************************************/
            /* Target is visible                                                    */
            /************************************************************************/
            Critter targ = Game.GetCritter(plane.Attack_TargId);

            if (valid(targ) && npc.IsSee(targ)) {
                /************************************************************************/
                /* Step 0: Check for success plane and continue target timeout          */
                /************************************************************************/

                if (plane.Attack_IsGag && (targ.HexX != plane.Attack_GagHexX || targ.HexY != plane.Attack_GagHexY)) {
                    NextPlane(npc, REASON_SUCCESS);
                    break;
                }

                bool attack_to_dead = (plane.Attack_MinHp <= Settings.DeadHitPoints);
                if (!plane.Attack_IsGag && (!attack_to_dead && targ.CurrentHp <= plane.Attack_MinHp) || (attack_to_dead && targ.IsDead())) {
                    NextPlane(npc, REASON_SUCCESS);
                    break;
                }

                if (plane.IsMove && plane.Attack_LastHexX == 0 && plane.Attack_LastHexY == 0) {
                    plane.IsMove = false;
                }

                plane.Attack_LastHexX = targ.HexX;
                plane.Attack_LastHexY = targ.HexY;

                if (is_busy) {
                    break;
                }

                // Is moving
                if (npc.GetMovingState() == MovingState::InProgress) {
                    return 1000;
                }
                /************************************************************************/
                /* Step 1: Choose weapon                                                */
                /************************************************************************/
                // Get battle weapon
                uint use;
                AbstractItem weap;
                any r0 = targ.Id;
                any r1 = 0;
                any r2 = 0;
                if (!Game.OnNpcPlaneRun.Fire(npc, plane.PlaneId, REASON_ATTACK_WEAPON, r0, r1, r2)) {
                    Game.Log("REASON_ATTACK_WEAPON fail. Skip attack.\n");
                    break;
                }
                if (plane.PlaneId != plane.GetCurPlane().PlaneId) { // TODO: проверить, что тут нет ошибки
                    break;                                          // Validate plane
                }

                if (ident(r0) != ZERO_IDENT) {
                    weap = npc.GetItem(ident(r0)); // TODO: проверить, что оружие найдено
                }
                else {
                    if (npc.IsNoUnarmed) {
                        NextPlane(npc, REASON_NO_UNARMED);
                        break;
                    }

                    ProtoItem unarmed = Game.GetProtoItem(hstring_fromHash(r2));
                    if (!valid(unarmed) || !unarmed.Weapon_IsUnarmed) {
                        unarmed = Game.GetProtoItem(hstring("default_weapon"));
                    }

                    weap = unarmed;
                }
                use = r1;

                if (!valid(weap) || weap.Type != ItemType::Weapon || weap.Weapon_ActiveUses <= use) {
                    Game.Log("REASON_ATTACK_WEAPON fail");
                    break;
                }

                AbstractItem mainItem = CritterItem::GetActive(npc);
                Item realMainItem = cast<Item>(mainItem);
                Item realWeapon = cast<Item>(weap);

                // Hide cur, show new
                if (realMainItem != null && realWeapon != null && realWeapon.Id != realMainItem.Id) {
                    CritterActions::MoveInvItem(npc, realMainItem.Id, CritterItemSlot::Inventory);
                    break; // TODO: проверить, не слишком ли долго будет думать нпц при замене оружия
                }

                if (realMainItem == null && realWeapon != null) {
                    CritterActions::MoveInvItem(npc, realWeapon.Id, CritterItemSlot::Main);
                    break;
                }

                if (realWeapon != null) {
                    Parameters::SetWeaponMode(realWeapon, _WeaponModeMake(use, 0));
                }
                else {
                    npc.HandsItemMode = _WeaponModeMake(use, 0);
                }

                // Load weapon
                if (realWeapon != null) {
                    if (!npc.IsUnlimitedAmmo && realWeapon.Weapon_MaxAmmoCount > 0 && realWeapon.AmmoCount == 0) {
                        Item ammo = Obsolete::FindAmmoForWeapon(npc, realWeapon);
                        if (ammo != null) {
                            if (realWeapon.AmmoPid == EMPTY_HSTRING) {
                                realWeapon.AmmoPid = realWeapon.Weapon_DefaultAmmoPid;
                            }
                            realWeapon.AmmoCount = realWeapon.Weapon_MaxAmmoCount;
                        }
                        else {
                            CritterActions::ReloadWeapon(npc, realWeapon.Id, ammo.Id);
                            break;
                        }
                    }
                    else if (npc.IsUnlimitedAmmo && realWeapon.Weapon_MaxAmmoCount > 0) {
                        if (realWeapon.AmmoPid == EMPTY_HSTRING) {
                            realWeapon.AmmoPid = realWeapon.Weapon_DefaultAmmoPid;
                        }
                        realWeapon.AmmoCount = realWeapon.Weapon_MaxAmmoCount;
                    }
                }

                /************************************************************************/
                /* Step 2: Move to target                                               */
                /************************************************************************/
                bool is_can_walk = !npc.IsNoMove;
                uint best_dist = 0, min_dist = 0, maxDist = 0;
                r0 = targ.Id;
                r1 = 0;
                r2 = 0;
                if (!Game.OnNpcPlaneRun.Fire(npc, plane.PlaneId, REASON_ATTACK_DISTANTION, r0, r1, r2)) {
                    Game.Log("REASON_ATTACK_DISTANTION fail. Skip attack.\n");
                    break;
                }
                if (plane.PlaneId != plane.GetCurPlane().PlaneId) {
                    break; // Validate plane
                }

                best_dist = r0;
                min_dist = r1;
                maxDist = r2;

                if (r2 <= 0) // Run away
                {
                    NextPlane(npc, REASON_RUN_AWAY);
                    break;
                }

                if (maxDist <= 0) {
                    uint look = npc.LookDistance;
                    maxDist = Parameters::GetItemAttackDistance(npc, weap, use);
                    if (maxDist > look) {
                        maxDist = look;
                    }
                }
                if (min_dist <= 0) {
                    min_dist = 1;
                }

                if (min_dist > maxDist) {
                    min_dist = maxDist;
                }
                best_dist = CLAMP(best_dist, min_dist, maxDist);
                uint actualDist = Game.GetDistance(npc.HexX, npc.HexY, targ.HexX, targ.HexY);

                if (actualDist > maxDist) {
                    if (!npc.IsNoMove) {
                        plane.IsMove = true;
                        npc.MoveToCritter(targ, best_dist, plane.Run && !npc.IsNoRun ? npc.WalkSpeed * 2 : npc.WalkSpeed);
                        break;
                    }
                    NextPlane(npc, REASON_CANT_WALK);
                    break;
                }

                // Find better position
                uint16 hx = npc.HexX;
                uint16 hy = npc.HexY;
                uint16 targetHx = targ.HexX;
                uint16 targetHy = targ.HexY;
                uint16 resHx = targetHx;
                uint16 resHy = targetHy;
                bool is_range = (maxDist > 2);
                if (is_range && !npc.IsNoMove) {
                    // Check target reachability
                    auto tracer = AttackCritterTracer(targ);
                    LineTracer::LineTracerHex(hx, hy, targetHx, targetHy, map, maxDist, tracer);
                    if (!tracer.Success) {
                        float angleDir = (Game.Random(0, 1) == 0 ? 1 : -1);
                        float baseAngle = LineTracer::GetDirectionF(targetHx, targetHy, hx, hy);
                        for (int i = 0; i < 17; i++) {
                            float angle = baseAngle * 20.0 * float(i / 2 + 1) * (i % 2 == 0 ? angleDir : -angleDir);
                            uint16 tx = hx;
                            uint16 ty = hy;
                            map.GetWallHexInPath(targetHx, targetHy, tx, ty, angle, best_dist);
                            uint dist = Game.GetDistance(targetHx, targetHy, tx, ty);
                            if (dist >= min_dist) {
                                LineTracer::LineTracerHex(tx, ty, targetHx, targetHy, map, maxDist, tracer);
                                if (tracer.Success) {
                                    plane.IsMove = true;
                                    npc.MoveToHex(tx, ty, 0, plane.Run && !npc.IsNoRun ? npc.WalkSpeed * 2 : npc.WalkSpeed);
                                    break;
                                }
                            }
                        }

                        // Better position not found
                        NextPlane(npc, REASON_POSITION_NOT_FOUND);
                        break;
                    }
                }
                // Find precision HtH attack
                else if (!is_range) {
                    if (Game.GetDistance(npc.HexX, npc.HexY, targ.HexX, targ.HexY) > maxDist) {
                        if (!is_can_walk) {
                            NextPlane(npc, REASON_CANT_WALK);
                        }
                        else if (maxDist > 1 && best_dist == 1) {
                            plane.IsMove = true;
                            npc.MoveToCritter(targ, best_dist, plane.Run && !npc.IsNoRun ? npc.WalkSpeed * 2 : npc.WalkSpeed);
                        }

                        break;
                    }
                }

                /************************************************************************/
                /* Step 3: Attack                                                       */
                /************************************************************************/

                r0 = targ.Id;
                r1 = 0;
                r2 = 0;
                if (!Game.OnNpcPlaneRun.Fire(npc, plane.PlaneId, REASON_ATTACK_USE_AIM, r0, r1, r2)) {
                    Game.Log("REASON_ATTACK_USE_AIM fail. Skip attack.\n");
                    break;
                }

                if (r2 > 0) {
                    return r2;
                }

                if (r0 != uint(use) && weap.Weapon_ActiveUses > uint(r0)) {
                    use = r0;
                }

                int aim = r1;
                if (npc.IsNoAim || !_WeaponAim(weap, use)) {
                    aim = 0;
                }
                if (realWeapon != null) {
                    Parameters::SetWeaponMode(realWeapon, _WeaponModeMake(use, aim));
                }
                else {
                    npc.HandsItemMode = _WeaponModeMake(use, 0);
                }
                CritterActions::Attack(npc, targ.Id, _WeaponModeMake(use, aim));
            }
            /************************************************************************/
            /* Target not visible, try find by last stored position                 */
            /************************************************************************/
            else {
                if (is_busy) {
                    break;
                }

                if ((plane.Attack_LastHexX == 0 && plane.Attack_LastHexY == 0) || npc.IsNoMove) {
                    // Critter targ_ = Game.GetCritter( plane.Attack_TargId );
                    NextPlane(npc, REASON_TARGET_DISAPPEARED);
                    break;
                }
                // AttackPlan Is moving last pos"
                if (npc.GetMovingState() == MovingState::InProgress) {
                    break;
                }

                AddWalkPlane(npc, 0, 0, 0, plane.Attack_LastHexX, plane.Attack_LastHexY, 1, plane.Run, npc.LookDistance / 2);

                plane.Attack_LastHexX = 0;
                plane.Attack_LastHexY = 0;
            }
        } break;
        /************************************************************************/
        /* ==================================================================== */
        /* ========================   Walk   ================================== */
        /* ==================================================================== */
        /************************************************************************/
        case AI_PLANE_WALK: {
            if (is_busy) {
                break;
            }

            if (Game.GetDistance(npc.HexX, npc.HexY, plane.Walk_HexX, plane.Walk_HexY) <= plane.Walk_Cut) {
                if (plane.Walk_Dir < 6) {
                    npc.SetDir(plane.Walk_Dir);
                }
                else if (plane.Walk_Cut > 0) {
                    npc.SetDir(Game.GetDirection(npc.HexX, npc.HexY, plane.Walk_HexX, plane.Walk_HexY));
                }

                NextPlane(npc, REASON_SUCCESS);
            }
            else {
                if (npc.IsNoMove) {
                    NextPlane(npc, REASON_CANT_WALK);
                }
                npc.MoveToHex(plane.Walk_HexX, plane.Walk_HexY, plane.Walk_Cut, plane.Run && !npc.IsNoRun ? npc.WalkSpeed * 2 : npc.WalkSpeed);
            }
        } break;
        /************************************************************************/
        /* ==================================================================== */
        /* ========================   Pick   ================================== */
        /* ==================================================================== */
        /************************************************************************/
        case AI_PLANE_PICK: {
            uint16 hx = plane.Pick_HexX;
            uint16 hy = plane.Pick_HexY;
            hstring pid = plane.Pick_Pid;
            ident use_item_id = plane.Pick_UseItemId;
            bool to_open = plane.Pick_ToOpen;
            bool is_run = plane.Pick_IsRun;

            Item item = map.GetItem(hx, hy, pid);
            if (!valid(item) || (item.Type == ItemType::Door && (to_open ? item.Opened : !item.Opened))) {
                NextPlane(npc, REASON_SUCCESS);
                break;
            }

            if (use_item_id != ZERO_IDENT && !valid(npc.GetItem(use_item_id))) {
                NextPlane(npc, REASON_USE_ITEM_NOT_FOUND);
                break;
            }

            if (is_busy) {
                break;
            }

            ProtoItem proto_item = Game.GetProtoItem(pid);
            if (!valid(proto_item)) {
                NextPlane(npc, REASON_SUCCESS);
                break;
            }

            if (Game.GetDistance(npc.HexX, npc.HexY, hx, hy) > 1 + npc.Multihex) {
                npc.MoveToHex(hx, hy, 1 + npc.Multihex, is_run && !npc.IsNoRun ? npc.WalkSpeed * 2 : npc.WalkSpeed);
            }
            else {
                npc.SetDir(Game.GetDirection(npc.HexX, npc.HexY, hx, hy));
                CritterActions::PickItem(npc, hx, hy, pid);
                NextPlane(npc, REASON_SUCCESS);
                break;
            }
        } break;
        /************************************************************************/
        /* ==================================================================== */
        /* ==================================================================== */
        /* ==================================================================== */
        /************************************************************************/
        default: {
            NextPlane(npc, REASON_SUCCESS);
        } break;
        }

        //	if(map->IsTurnBasedOn && map->IsCritterTurn(npc) && !is_busy && (npc->IsNoPlanes() || !npc->GetCurPlane()->IsMove) && !npc->IsBusy() &&
        //! npc->IsWait()) map->EndCritterTurn();
    }
    return 0;
}

NpcPlane CreatePlane()
{
    return NpcPlane(0, 0);
}

dict<ident, NpcPlane[]> AllNpcPlanes = {};
int LastPlaneId = 0;

class AttackCritterTracer : LineTracer::ITraceContext
{
    Critter Target;
    bool Success;

    AttackCritterTracer(Critter target)
    {
        Target = target;
    }

    void StartExec(Map map, uint16 hx, uint16 hy, uint16 tx, uint16 ty, uint maxDist) override
    {
        Success = false;
    }

    void FinishExec(Map map, uint resultDist) override
    {
        // Nothing
    }

    bool Exec(Map map, uint16 hx, uint16 hy) override
    {
        if (!map.IsHexShootable(hx, hy)) {
            return true;
        }

        Critter cr = map.GetCritter(hx, hy);
        if (cr != null && cr.Condition != CritterCondition::Dead) {
            Success = (cr.Id == Target.Id);
            return true;
        }

        return false;
    }
};

class NpcPlane
{
    int PlaneId;
    int Type;
    uint Priority;
    any Identifier;
    any IdentifierExt;
    bool Run;
    bool IsMove;
    uint Misc_WaitSecond;
    NpcPlaneMiscFunc Misc_Script;
    ident Attack_TargId;
    int Attack_MinHp;
    bool Attack_IsGag;
    uint16 Attack_GagHexX;
    uint16 Attack_GagHexY;
    uint16 Attack_LastHexX;
    uint16 Attack_LastHexY;
    uint16 Walk_HexX;
    uint16 Walk_HexY;
    uint8 Walk_Dir;
    uint Walk_Cut;
    uint16 Pick_HexX;
    uint16 Pick_HexY;
    hstring Pick_Pid;
    ident Pick_UseItemId;
    bool Pick_ToOpen;
    bool Pick_IsRun;
    // private
    NpcPlane ChildPlane;
    bool Assigned;
    int RefCounter;

    string ToString()
    {
        return "PlaneId = " + PlaneId + ";Type = " + Type + ";Priority = " + Priority + ";Identifier = " + Identifier + ";IdentifierExt = " + IdentifierExt +
               "; coords = " + Pick_HexX + ":" + Pick_HexY;
    }

    NpcPlane(uint type, uint priority)
    {
        Type = type;
        Priority = priority;
        RefCounter = 1;
        Identifier = 0;
        IdentifierExt = 0;
        ChildPlane = null;
        IsMove = false;
        Assigned = false;
        PlaneId = LastPlaneId + 1;
        LastPlaneId = PlaneId;
    }

    void AddRef()
    {
        RefCounter++;
    }

    void Misc_SetupScript(NpcPlaneMiscFunc func)
    {
        @Misc_Script = func;
    }

    NpcPlane GetCopy()
    {
        NpcPlane copy = NpcPlane(Type, Priority);
        NpcPlane result = copy;
        NpcPlane planeChild = ChildPlane;
        while (planeChild != null) {
            copy.ChildPlane = NpcPlane(planeChild.Type, planeChild.Priority);
            if (copy.ChildPlane == null) {
                return null;
            }
            copy.ChildPlane.Assigned = true;
            planeChild = planeChild.ChildPlane;
            copy = copy.ChildPlane;
        }
        return result;
    }

    NpcPlane SetChild(NpcPlane child_plane)
    {
        if (child_plane.Assigned) {
            child_plane = child_plane.GetCopy();
        }
        else {
            child_plane.AddRef();
        }

        ChildPlane = child_plane;
        return child_plane;
    }

    NpcPlane GetChild(uint index)
    {
        NpcPlane result = ChildPlane;
        for (uint i = 0; i < index && result != null; i++) {
            result = result.ChildPlane;
        }
        return result;
    }

    NpcPlane GetCurPlane()
    {
        return ChildPlane == null ? this : ChildPlane.GetCurPlane();
    }
};

NpcPlane GetCritterPlane(Critter cr, int planeId)
{
    if (valid(cr)) {
        NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
        if (planes != null && !planes.isEmpty()) {
            for (int i = 0, l = planes.length(); i < l; i++) {
                if (planes[i].PlaneId == planeId) {
                    return planes[i];
                }
            }
        }
    }
    return null;
}

// Remove one or more planes from critter pool. all - remove all of the planeType, planeType = -1 => remove any type.
uint ErasePlane(Critter cr, int planeType, bool all)
{
    int erased = 0;

    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes != null && !planes.isEmpty()) {
        for (int i = 0, l = planes.length(); i < l; i++) {
            NpcPlane plane = planes[i];
            if (plane != null) {
                if (plane.Type == planeType || planeType == -1) {
                    planes.remove(plane);
                    erased++;
                    if (!all) {
                        break;
                    }
                }
            }
            else {
                planes.remove(planes[i]);
                erased++;
            }
        }
    }
    AllNpcPlanes.set(cr.Id, planes);
    return erased;
}

bool ErasePlane(Critter cr, uint index)
{
    if (!valid(cr)) {
        ThrowException("Attempt to call method on destroyed object.");
    }
    if (!cr.IsControlledByPlayer) {
        ThrowException("Critter is not npc.");
    }

    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes != null && !planes.isEmpty()) {
        for (uint i = 0, l = planes.length(); i < l; i++) {
            if (index >= l) {
                ThrowException("Invalid index arg.");
            }
            if (i == index) {
                NpcPlane plane = planes[i];
                if (plane != null) {
                    planes.remove(plane);
                    AllNpcPlanes.set(cr.Id, planes);
                    return true;
                }
            }
        }
    }
    return false;
}

void DropPlanes(Critter cr)
{
    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes != null && !planes.isEmpty()) {
        planes.clear();
        AllNpcPlanes.set(cr.Id, null);
    }
}

bool IsNoPlanes(Critter cr)
{
    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes == null || planes.isEmpty()) {
        return true;
    }
    return false;
}

bool IsCurPlane(Critter cr, int planeType)
{
    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes != null && !planes.isEmpty()) {
        NpcPlane plane = planes[0].GetCurPlane();
        return planeType == plane.Type;
    }
    return false;
}

// Returns first plan for the critter. Deepest child plane returned first.
NpcPlane GetCurPlane(Critter cr)
{
    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes != null && !planes.isEmpty()) {
        NpcPlane plane = planes[0];
        if (plane != null) {
            return plane.GetCurPlane();
        }
    }
    return null;
}

NpcPlane[] GetPlanes(Critter cr)
{
    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes != null && !planes.isEmpty()) {
        return planes;
    }
    return null;
}

uint GetPlanes(Critter cr, NpcPlane[] planes)
{
    NpcPlane[] crPlanes = GetPlanes(cr);
    if (crPlanes == null) {
        return 0;
    }
    if (valid(planes)) {
        planes = crPlanes;
    }
    return crPlanes.length();
}

NpcPlane[] GetPlanes(Critter cr, any identifier)
{
    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes != null && !planes.isEmpty()) {
        NpcPlane[] result = {};
        for (int i = 0, l = planes.length(); i < l; i++) {
            NpcPlane plane = planes[i];
            if (plane != null) {
                if (plane.Identifier == identifier) {
                    result.insertLast(plane);
                }
            }
        }
        if (result.length() > 0) {
            return result;
        }
    }
    return null;
}

uint GetPlanes(Critter cr, any identifier, NpcPlane[] planes)
{
    NpcPlane[] crPlanes = GetPlanes(cr, identifier);
    if (crPlanes == null) {
        return 0;
    }
    if (valid(planes)) {
        planes = crPlanes;
    }
    return crPlanes.length();
}

NpcPlane[] GetPlanes(Critter cr, any identifier, any identifierExt)
{
    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes != null && !planes.isEmpty()) {
        NpcPlane[] result = {};
        for (int i = 0, l = planes.length(); i < l; i++) {
            NpcPlane plane = planes[i];
            if (plane != null) {
                if (plane.Identifier == identifier && plane.IdentifierExt == identifierExt) {
                    result.insertLast(plane);
                }
            }
        }
        if (result.length() > 0) {
            return result;
        }
    }
    return null;
}

uint GetPlanes(Critter cr, any identifier, any identifierExt, NpcPlane[] planes)
{
    NpcPlane[] crPlanes = GetPlanes(cr, identifier, identifierExt);
    if (crPlanes == null) {
        return 0;
    }
    if (valid(planes)) {
        planes = crPlanes;
    }
    return crPlanes.length();
}

bool AddPlane(Critter cr, NpcPlane plane)
{
    if (valid(cr) && !cr.IsControlledByPlayer) {
        NpcPlane[] planes = {};
        if (!valid(AllNpcPlanes)) {
            Game.Log("invalid AllNpcPlanes");
        }
        if (AllNpcPlanes.exists(cr.Id)) {
            planes = AllNpcPlanes.get(cr.Id, planes);
        }
        // AllNpcPlanes.setIfNotExist( cr.Id, array< NpcPlane >() );
        if (!valid(planes)) {
            planes = array<NpcPlane>();
        }
        if (planes.length() >= MAX_PLANES_PER_CRITTER) {
            return false;
        }

        for (int i = 0, l = planes.length(); i < l; i++) {
            NpcPlane existingPlane = planes[i];
            if (valid(existingPlane)) {
                if (existingPlane.Type == plane.Type) {
                    if (plane.Type == AI_PLANE_ATTACK && plane.Attack_TargId == existingPlane.Attack_TargId) {
                        planes.removeAt(i);
                        i--;
                        l--;
                    }
                }
            }
        }
        if (planes.length() == 0) {
            planes.insertFirst(plane);
        }
        else {
            uint i = 0;
            for (uint l = planes.length(); i < l; i++) {
                NpcPlane p = planes[i];
                if (valid(p) && p.Priority < plane.Priority) {
                    break;
                }
            }
            planes.insertAt(i, plane);
        }

        // void insertAt(uint, const array<T>&in)

        AllNpcPlanes.set(cr.Id, planes);
        return true;
    }
    return false;
}

void NextPlane(Critter cr, int reason)
{
    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes != null && !planes.isEmpty()) {
        // Remove first plane and notify about
        NpcPlane plane = planes[0];
        if (valid(plane)) {
            if (Game.OnNpcPlaneEnd.Fire(cr, plane.PlaneId, reason, null, null)) {
                planes.removeFirst();
                if (plane.GetCurPlane().PlaneId == plane.PlaneId) {
                    //Нет дочерних планов.
                    return;
                }
                NpcPlane cur = plane;
                NpcPlane child = plane.ChildPlane;
                while (child.ChildPlane != null) {
                    cur = child;
                    child = cur.ChildPlane;
                }
                cur.ChildPlane = null;
                planes.insertFirst(plane);
            }
            else {
                // поменять приоритет
                planes.removeFirst();
                uint position = 0;
                if (planes.length() > 0) {
                    for (uint l = planes.length(); position < l; position++) {
                        if (plane.Priority > planes[position].Priority) {
                            break;
                        }
                    }
                }
                planes.insertAt(position, plane);
            }
        }
    }
}

bool AddMiscPlane(Critter npc, uint priority, uint waitSecond, NpcPlaneMiscFunc func)
{
    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_MISC;
    plane.Priority = (priority == 0 ? AI_PLANE_MISC_PRIORITY : priority);
    plane.Misc_WaitSecond = waitSecond;
    if (func !is null) {
        plane.Misc_SetupScript(func);
    }
    return AddPlane(npc, plane);
}

bool AddWalkPlane(Critter npc, hstring entry, uint cut, bool run)
{
    uint16 hX = 0, hY = 0;
    Map map = npc.GetMap();
    if (map !is null && Entrance::MapGetEntryCoords(map, entry, 0, hX, hY)) {
        return AddWalkPlane(npc, 0, hX, hY, 6, run, cut);
    }
    return false;
}

bool AddWalkPlane(Critter npc, uint entry, uint cut, bool run)
{
    return AddWalkPlane(npc, hstring("" + entry), cut, run);
}

bool AddWalkPlane(Critter npc, uint priority, uint16 hexX, uint16 hexY, uint8 dir, bool run, uint cut)
{
    if (npc.IsNoMove) {
        return false;
    }

    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_WALK;
    plane.Priority = (priority == 0 ? AI_PLANE_WALK_PRIORITY : priority);
    plane.Walk_HexX = hexX;
    plane.Walk_HexY = hexY;
    plane.Walk_Dir = dir;
    plane.Run = run;
    plane.Walk_Cut = cut;
    return AddPlane(npc, plane);
}

bool AddWalkPlane(Critter npc, uint priority, any identifier, any identifierExt, uint16 hexX, uint16 hexY, uint8 dir, bool run, uint cut)
{
    if (npc.IsNoMove) {
        return false;
    }

    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_WALK;
    plane.Priority = (priority == 0 ? AI_PLANE_WALK_PRIORITY : priority);
    plane.Identifier = identifier;
    plane.IdentifierExt = identifierExt;
    plane.Walk_HexX = hexX;
    plane.Walk_HexY = hexY;
    plane.Walk_Dir = dir;
    plane.Run = run;
    plane.Walk_Cut = cut;
    return AddPlane(npc, plane);
}

bool AddAttackPlane(Critter npc, uint priority, Critter target)
{
    NL(npc, "AddAttackPlane");
    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_ATTACK;
    plane.Priority = (priority == 0 ? AI_PLANE_ATTACK_PRIORITY : priority);
    plane.Attack_TargId = target.Id;
    plane.Attack_MinHp = Settings.DeadHitPoints;
    plane.Attack_IsGag = false;
    plane.Attack_GagHexX = 0;
    plane.Attack_GagHexY = 0;
    plane.Attack_LastHexX = target.HexX;
    plane.Attack_LastHexY = target.HexY;
    plane.Run = false;
    return AddPlane(npc, plane);
}

bool AddAttackPlane(Critter npc, uint priority, ident critId)
{
    Critter target = Game.GetCritter(critId);
    if (target is null) {
        Game.Log("Target not found.");
        return false;
    }

    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_ATTACK;
    plane.Priority = (priority == 0 ? AI_PLANE_ATTACK_PRIORITY : priority);
    plane.Attack_TargId = target.Id;
    plane.Attack_MinHp = Settings.DeadHitPoints;
    plane.Attack_IsGag = false;
    plane.Attack_GagHexX = 0;
    plane.Attack_GagHexY = 0;
    plane.Attack_LastHexX = target.HexX;
    plane.Attack_LastHexY = target.HexY;
    plane.Run = false;
    return AddPlane(npc, plane);
}

bool AddAttackPlane(Critter npc, uint priority, Critter target, int minHp)
{
    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_ATTACK;
    plane.Priority = (priority == 0 ? AI_PLANE_ATTACK_PRIORITY : priority);
    plane.Attack_TargId = target.Id;
    plane.Attack_MinHp = minHp;
    plane.Attack_IsGag = false;
    plane.Attack_GagHexX = 0;
    plane.Attack_GagHexY = 0;
    plane.Attack_LastHexY = target.HexY;
    plane.Attack_LastHexX = target.HexX;
    plane.Run = false;
    return AddPlane(npc, plane);
}

bool AddAttackPlane(Critter npc, uint priority, ident critId, int minHp)
{
    Critter target = Game.GetCritter(critId);
    if (target is null) {
        Game.Log("Target not found.");
        return false;
    }

    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_ATTACK;
    plane.Priority = (priority == 0 ? AI_PLANE_ATTACK_PRIORITY : priority);
    plane.Attack_TargId = target.Id;
    plane.Attack_MinHp = minHp;
    plane.Attack_IsGag = false;
    plane.Attack_GagHexX = 0;
    plane.Attack_GagHexY = 0;
    plane.Attack_LastHexX = target.HexX;
    plane.Attack_LastHexY = target.HexY;
    plane.Run = false;
    return AddPlane(npc, plane);
}

bool AddAttackPlane(Critter npc, uint priority, Critter target, bool run)
{
    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_ATTACK;
    plane.Priority = (priority == 0 ? AI_PLANE_ATTACK_PRIORITY : priority);
    plane.Attack_TargId = target.Id;
    plane.Attack_MinHp = Settings.DeadHitPoints;
    plane.Attack_IsGag = false;
    plane.Attack_GagHexX = 0;
    plane.Attack_GagHexY = 0;
    plane.Attack_LastHexX = target.HexX;
    plane.Attack_LastHexY = target.HexY;
    plane.Run = run;
    return AddPlane(npc, plane);
}

bool AddAttackPlane(Critter npc, uint priority, ident critId, bool run)
{
    Critter target = Game.GetCritter(critId);
    if (target is null) {
        Game.Log("Target not found.");
        return false;
    }

    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_ATTACK;
    plane.Priority = (priority == 0 ? AI_PLANE_ATTACK_PRIORITY : priority);
    plane.Attack_TargId = target.Id;
    plane.Attack_MinHp = Settings.DeadHitPoints;
    plane.Attack_IsGag = false;
    plane.Attack_GagHexX = 0;
    plane.Attack_GagHexY = 0;
    plane.Attack_LastHexX = target.HexX;
    plane.Attack_LastHexY = target.HexY;
    plane.Run = run;
    return AddPlane(npc, plane);
}

bool AddAttackPlane(Critter npc, uint priority, Critter target, int minHp, bool run)
{
    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_ATTACK;
    plane.Priority = (priority == 0 ? AI_PLANE_ATTACK_PRIORITY : priority);
    plane.Attack_TargId = target.Id;
    plane.Attack_MinHp = minHp;
    plane.Attack_IsGag = false;
    plane.Attack_GagHexX = 0;
    plane.Attack_GagHexY = 0;
    plane.Attack_LastHexX = target.HexX;
    plane.Attack_LastHexY = target.HexY;
    plane.Run = run;
    return AddPlane(npc, plane);
}

bool AddAttackPlane(Critter npc, uint priority, ident critId, int minHp, bool run)
{
    Critter target = Game.GetCritter(critId);
    if (target is null) {
        Game.Log("Target not found.");
        return false;
    }

    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_ATTACK;
    plane.Priority = (priority == 0 ? AI_PLANE_ATTACK_PRIORITY : priority);
    plane.Attack_TargId = target.Id;
    plane.Attack_MinHp = minHp;
    plane.Attack_IsGag = false;
    plane.Attack_GagHexX = 0;
    plane.Attack_GagHexY = 0;
    plane.Attack_LastHexX = target.HexX;
    plane.Attack_LastHexY = target.HexY;
    plane.Run = run;
    return AddPlane(npc, plane);
}

bool AddPickPlane(Critter npc, uint priority, uint16 hexX, uint16 hexY, hstring protoId, ident useItemId, bool toOpen)
{
    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_PICK;
    plane.Priority = (priority == 0 ? AI_PLANE_PICK_PRIORITY : priority);
    plane.Pick_HexX = hexX;
    plane.Pick_HexY = hexY;
    plane.Pick_Pid = protoId;
    plane.Pick_UseItemId = useItemId;
    plane.Pick_ToOpen = toOpen;
    plane.Run = false;
    return AddPlane(npc, plane);
}

bool AddPickPlane(Critter npc, uint priority, Item item, ident useItemId, bool toOpen)
{
    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_PICK;
    plane.Priority = (priority == 0 ? AI_PLANE_PICK_PRIORITY : priority);
    plane.Pick_HexX = item.HexX;
    plane.Pick_HexY = item.HexY;
    plane.Pick_Pid = item.ProtoId;
    plane.Pick_UseItemId = useItemId;
    plane.Pick_ToOpen = toOpen;
    plane.Run = false;
    return AddPlane(npc, plane);
}

uint EraseAttackPlane(Critter npc, Critter target)
{
    return EraseAttackPlane(npc, target.Id);
}

uint EraseAttackPlane(Critter npc, ident critId)
{
    NpcPlane[] planes = GetPlanes(npc);

    uint erased = 0;
    for (uint i = 0; i < planes.length(); i++) {
        if (planes[i].Attack_TargId == critId && ErasePlane(npc, i - erased)) {
            erased++;
        }
    }

    return erased;
}
