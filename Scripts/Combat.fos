// FOS Server

// WeaponSubtype
#define WS_UNARMED   (1)
#define WS_MELEE     (2)
#define WS_THROWING  (3)
#define WS_GUN       (4)
#define PTR_NULL     (-1)

#define FlushResults #(tree)runTree(tree, 0)

class CombatRes
{
    any[] Res = {};
    Critter Crit;
    int Left;
    int Right;

    CombatRes()
    {
        Res.resize(1);
        Res[0] = 1; // This will hold length of the message for client (so it can verify the length)
        Left = PTR_NULL;
        Right = PTR_NULL;
    }
};

void AddEff(Critter crit, any[] eff, CombatRes[] combatResults)
{
    int ptr = 0;

    // find or create the node:
    if (combatResults.length() == 0) {
        combatResults.resize(1);
        combatResults[0] = CombatRes();
        combatResults[0].Crit = crit;
    }

    while (combatResults[ptr].Crit.Id != crit.Id) {
        if (crit.Id.value < combatResults[ptr].Crit.Id.value) {
            if (combatResults[ptr].Left != PTR_NULL) {
                ptr = combatResults[ptr].Left;
            }
            else {
                uint last = combatResults.length();
                combatResults.resize(last + 1);
                combatResults.last() = CombatRes();
                combatResults[ptr].Left = last;
                ptr = last;
                combatResults[last].Crit = crit;
            }
        }
        else {
            if (combatResults[ptr].Right != PTR_NULL) {
                ptr = combatResults[ptr].Right;
            }
            else {
                uint last = combatResults.length();
                combatResults.resize(last + 1);
                combatResults.last() = CombatRes();
                combatResults[ptr].Right = last;
                ptr = last;
                combatResults[last].Crit = crit;
            }
        }
    }

    // add the effect:
    uint len = eff.length();
    combatResults[ptr].Res.resize(int(combatResults[ptr].Res[0]) + len);
    for (uint i = 0; i < len; i++) {
        combatResults[ptr].Res[i + int(combatResults[ptr].Res[0])] = eff[i];
    }

    combatResults[ptr].Res[0] = int(combatResults[ptr].Res[0]) + len;
}

void runTree(CombatRes[] combatResults, int ptr)
{
    if (ptr == 0) {
        if (combatResults.length() == 0) {
            return;
        }
    }
    /*if (combatResults[ptr].Crit == null)
       {
       Game.Log("tree fail, ptr="+ptr+" in "+where);
       return false;
       }*/

    combatResults[ptr].Crit.PlayerClientCall.CombatResult(combatResults[ptr].Res);

    /*if (combatResults[ptr].Left  != PTR_NULL)
       if (!runTree(combatResults, combatResults[ptr].Left, where)) return false;
       if (combatResults[ptr].Right != PTR_NULL)
       if (!runTree(combatResults, combatResults[ptr].Right, where)) return false;*/
    if (combatResults[ptr].Left != PTR_NULL) {
        runTree(combatResults, combatResults[ptr].Left);
    }
    if (combatResults[ptr].Right != PTR_NULL) {
        runTree(combatResults, combatResults[ptr].Right);
    }
}

// Author: Atom, cvet
// 21-08-2010 05:09
// vanilla

class AttackStruct
{
    Critter Attacker;
    Item RealWeapon;
    uint16 Hx;
    uint16 Hy;
    uint8 Aim;
    bool IsBurst;
    bool BloodyMess;
    bool CombatMessage;
    bool scoreUnarmed;
    ItemPerks WeaponPerk;
    uint8 WeaponSubtype;
    int DmgMin;
    int DmgMax;
    DamageTypes DmgType;
    int BonusDmg;
    int DmgMul;
    int DRMod;
    int DMMod;
    int DDMod;
    ident TargetId;
    bool TargetHit;
    uint ForceFlags;
    bool ShowHitAnimForce;

    AttackStruct()
    {
        Attacker = null;
        RealWeapon = null;
        Hx = 0;
        Hy = 0;
        Aim = HitLocations::LocationUncalled;
        IsBurst = false;
        BloodyMess = false;
        CombatMessage = false;
        scoreUnarmed = false;
        WeaponPerk = ItemPerks::ItemPerkNone;
        WeaponSubtype = 0;
        DmgMin = 0;
        DmgMax = 0;
        DmgType = DamageTypes::None;
        BonusDmg = 0;
        DmgMul = 2;
        DRMod = 0;
        DMMod = 1;
        DDMod = 1;

        TargetId = ZERO_IDENT;
        TargetHit = false;
        ForceFlags = 0;
        ShowHitAnimForce = false;
    }
};

void CombatAttack(Critter cr, Critter target, AbstractItem weapon, uint8 weaponMode, ProtoItem ammo)
{
    if (!cr.IsAlive()) {
        return;
    }
    uint8 use = _WeaponModeUse(weaponMode);
    uint8 aim = _WeaponModeAim(weaponMode);
    Item realWeapon = _CritGetItemHand(cr);
    Map map = cr.GetMap();
    int wpnMaxDist = _WeaponMaxDist(weapon, use);
    CritterProperty skill = _WeaponSkill(weapon, use);
    if (skill == CritterProperty::SkillThrowing) {
        wpnMaxDist = MIN(wpnMaxDist, 3 * MIN(int(10), (cr.Strength + 2 * cr.PerkHeaveHo)));
    }
    int skillVal = cr.GetAsInt(skill);
    uint8 weaponSubtype = (skill == CritterProperty::SkillSmallGuns || skill == CritterProperty::SkillBigGuns || skill == CritterProperty::SkillEnergyWeapons) ?
                              WS_GUN :
                              ((skill == CritterProperty::SkillThrowing)     ? WS_THROWING :
                               (skill == CritterProperty::SkillMeleeWeapons) ? WS_MELEE :
                                                                               WS_UNARMED);
    bool isRanged = (weaponSubtype == WS_THROWING || weaponSubtype == WS_GUN);
    bool isUnarmed = weapon.Weapon_IsUnarmed;
    bool isHthAttack = (weaponSubtype == WS_MELEE || weaponSubtype == WS_UNARMED);
    uint16 ammoRound = _WeaponRound(weapon, use);
    bool wpnIsRemoved = _WeaponRemove(weapon, use);
    uint16 hx = cr.HexX;
    uint16 hy = cr.HexY;
    uint16 tx = target.HexX;
    uint16 ty = target.HexY;
    hstring weapPid = weapon.ProtoId;
    hstring ammoPid;
    if (valid(ammo)) {
        ammoPid = ammo.ProtoId;
    }
    bool isBurst = (ammoRound > 1); // will suffice for now
    if (isBurst) {
        aim = HitLocations::LocationUncalled;
    }
    DamageTypes dmgType = _WeaponDmgType(weapon, use);
    bool isGrenade =
        weaponSubtype == WS_THROWING && (dmgType == DamageTypes::Plasma || dmgType == DamageTypes::Emp || dmgType == DamageTypes::Explode); // like in fo2
    bool isFlamethrower =
        (weapPid == Content::Item::flamer) || (weapPid == Content::Item::improved_flamethrower) || (weapPid == Content::Item::fire_gecko_flame_weapon);
    bool isRocket = (ammoPid == Content::Item::explosive_rocket) || (ammoPid == Content::Item::rocket_ap) || (ammoPid == Content::Item::robo_rocket_ammo) ||
                    (ammoPid == Content::Item::emp_rocket);

    bool eyeDamage = cr.IsDamagedEye;
    ItemPerks weaponPerk = weapon.Weapon_Perk;
    bool crIsPlayer = cr.IsControlledByPlayer;
    bool isHit = false;
    bool isCritical = false;
    bool hitRandomly = false;
    uint critfailFlags = 0;
    Critter realTarget;
    bool isSneak = false;
    bool useNormal = false; // used to change target during RunFlyEffect
    bool useHex = false;    // used to change end hex of RunFlyEffect, i.e. for thrown weapons and rockets.
    Critter normalTarget;   // used as a target for weapon animations;

    CombatRes[] results = {};

    int acmod = 0; // used many times

    // always unsneak
    if (cr.InSneakMode) {
        cr.InSneakMode = false;
        isSneak = true;
    }

    target.InSneakMode = false;

    cr.SetDir(Game.GetDirection(hx, hy, tx, ty));

    // now we change aim:
    if (aim == HitLocations::LocationEyes && valid(cr) && (cr.Dir + 3) % 6 != target.Dir) {
        aim = HitLocations::LocationHead;
    }

    uint crTimeout = BATTLE_TIMEOUT(cr);
    if (cr.TimeoutBattle < crTimeout) {
        cr.TimeoutBattle = crTimeout;
    }
    uint targetTimeout = BATTLE_TIMEOUT(target);
    if (target.TimeoutBattle < targetTimeout) {
        target.TimeoutBattle = targetTimeout;
    }

    cr.TimeoutSneak = SNEAK_TIMEOUT(cr);
    target.TimeoutSneak = SNEAK_TIMEOUT(target);

    // leaderboard
    if (crIsPlayer) {
        if (weaponSubtype == WS_GUN) {
            Scores::AddScore(cr, EScores::Shooter, 1);
        }
        else if (skill == CritterProperty::SkillMeleeWeapons || skill == CritterProperty::SkillThrowing) {
            Scores::AddScore(cr, EScores::Melee, 1);
        }
        else if (skill == CritterProperty::SkillUnarmed) {
            Scores::AddScore(cr, EScores::Unarmed, 1);
        }
    }

    // Npc attack text
    if (!crIsPlayer) {
        AiSettings::AI_TrySayCombatText(cr, CombatText::Attack);
    }

    // Add event, always
    Game.OnCritterAttacked.Fire(target, cr);

    // essential start

    // baseToHit used for all targets, adjusted for distance and other target-dependent qualities every time it is necessary
    int baseToHit = skillVal;
    if (eyeDamage) {
        baseToHit -= 25;
    }
    if (cr.PerkVampireAccuracy != 0 && IS_NIGHT(GameTime::GetHour())) {
        baseToHit += 13; // Quest pe
    }
    if (!isUnarmed) {
        if (cr.IsTraitOneHander) {
            baseToHit += (weapon.Weapon_IsTwoHanded ? -40 : 20);
        }

        int handlingStrength = cr.Strength;
        int reqStrength = weapon.Weapon_MinStrength;
        if (cr.PerkWeaponHandling != 0) {
            handlingStrength += 3;
        }
        if (handlingStrength < reqStrength) {
            baseToHit -= (reqStrength - handlingStrength) * 20;
        }

        if (weaponPerk == ItemPerks::Accurate) {
            baseToHit += 20;
        }
    }

    // main attack structure
    AttackStruct attack = AttackStruct();
    attack.Attacker = cr;
    attack.RealWeapon = realWeapon;
    attack.Hx = hx;
    attack.Hy = hy;
    attack.Aim = aim;
    attack.IsBurst = isBurst;
    attack.BloodyMess = cr.IsTraitBloodyMess;
    attack.CombatMessage = true;
    attack.scoreUnarmed = (weaponSubtype == WS_UNARMED);
    attack.WeaponPerk = (isUnarmed && weapon.Weapon_UnarmedArmorPiercing) ? ItemPerks::Penetrate : weaponPerk;
    attack.WeaponSubtype = weaponSubtype;
    attack.DmgMin = _WeaponDmgMin(weapon, use);
    attack.DmgMax = _WeaponDmgMax(weapon, use);
    attack.DmgType = dmgType;
    attack.BonusDmg = 0;

    if (isHthAttack) {
        attack.DmgMax += cr.MeleeDamage;
    }
    if (weaponSubtype == WS_GUN) {
        attack.BonusDmg += cr.PerkBonusRangedDamage * 2;
    }
    attack.DmgMul = 2;
    // Ammo
    if (valid(ammo)) {
        attack.DRMod = ammo.Ammo_DrMod;
        attack.DMMod = ammo.Ammo_DmgMult;
        attack.DDMod = ammo.Ammo_DmgDiv;
        if (attack.DMMod == 0) {
            attack.DMMod = 1;
        }
        if (attack.DDMod == 0) {
            attack.DDMod = 1;
        }
    }

    // to check if the target was hit:
    attack.TargetId = target.Id;

    // here we're deciding the real toHit;
    int toHit = baseToHit;
    toHit -= isHthAttack ? (GetHitAim(aim) / 2) : GetHitAim(aim);

    // range considerations, we're storing everything for a later use
    int distmod1 = 2; // used for initial weapon bonus
    int distmod2 = 0; // minimal distance

    if (weaponPerk == ItemPerks::LongRange) {
        distmod1 = 4;
    }
    else if (weaponPerk == ItemPerks::ScopeRange) {
        distmod1 = 5;
        distmod2 = 8;
    }

    int perception = cr.Perception;
    int dist = Game.GetDistance(hx, hy, target.HexX, target.HexY);
    int acc = dist;
    int accloss = (crIsPlayer ? (perception - 2) * distmod1 : (perception * distmod1));
    int sharpshooter = 2 * cr.PerkSharpshooter;

    if (!isHthAttack) {
        if (dist < distmod2) {
            acc += distmod2;
        }
        else {
            acc -= accloss;
        }
        if (-2 * perception > acc) {
            acc = -2 * perception;
        }
        acc -= sharpshooter;
        if (acc > 0 && eyeDamage) {
            acc *= 3;
        }
        acc *= -4;
        toHit += acc;
        int blockers = Obsolete::GetCrittersInPath(map, hx, hy, tx, ty, 0.0f, dist, CritterFindType::Alive, null);
        if (!target.IsKnockout()) {
            blockers--;
        }
        toHit -= 10 * blockers;
    }
    acmod = target.ArmorClass;
    if (valid(ammo)) {
        acmod += ammo.Ammo_AcMod;
    }
    if (acmod > 0) {
        toHit -= acmod;
    }
    if (target.IsKnockout()) {
        toHit += 40;
    }
    if (target.Multihex > 0) {
        toHit += 15;
    }

    toHit = CLAMP(toHit, 5, 95);
    // smoke penalty
    if (!isHthAttack) {
        toHit -= SmokeGrenade::GetSmokePenalty(map, cr, target);
    }
    // main roll
    int margin = toHit - Game.Random(1, 100);

    if (margin < 0) // if missed
    {
        // not setting isHit, we try a critical failure
        if (!cr.IsInvulnerable) {
            isCritical = ((-margin) / 10 >= Game.Random(1, 100));

            // basic jinxed behaviour (upgrade if anyone is jinxed and coinflip is passed)
            if (!isCritical) {
                isCritical = (Game.Random(0, 1) == 0 && (cr.IsTraitJinxed || cr.IsTraitJinxedII || target.IsTraitJinxed || target.IsTraitJinxedII));
            }
            if (isCritical) {
                int roll = Game.Random(1, 100) - 5 * (cr.Luck - 5);
                if (roll <= 20) {
                    roll = 0;
                }
                else if (roll <= 50) {
                    roll = 1;
                }
                else if (roll <= 75) {
                    roll = 2;
                }
                else if (roll <= 95) {
                    roll = 3;
                }
                else {
                    roll = 4;
                }

                critfailFlags = CriticalFailureTable[5 * weapon.Weapon_CriticalFailture + roll];
                if (critfailFlags == 0) {
                    isCritical = false;
                }
                hitRandomly = FLAG(critfailFlags, MF_HIT_RANDOMLY);
            }
        }
    }
    else // if hit
    {
        isHit = true;
        if (isHthAttack && cr.PerkSlayer != 0) {
            isCritical = true;
        }
        else {
            isCritical = (Game.Random(1, 100) <= cr.CriticalChance + margin / 10 + GetHitAim(aim));
        }

        if (!isCritical && weaponSubtype == WS_GUN && cr.PerkSniper != 0) {
            isCritical = (Game.Random(1, 10) <= cr.Luck);
        }
        if (!isCritical && isUnarmed) {
            isCritical = Game.Random(1, 100) <= weapon.Weapon_UnarmedCriticalBonus;
        }
    }

    if (hitRandomly) {
        Critter randomTarget = ChooseRandomTarget(map, cr, target, wpnMaxDist);
        if (randomTarget != null) {
            realTarget = randomTarget;
            tx = realTarget.HexX;
            ty = realTarget.HexY;
            attack.Aim = HitLocations::LocationUncalled;
            realTarget.InSneakMode = false; // done here to allow combat notifications later
            NotifyOops(cr, target, realTarget, results);
        }
    }
    else {
        realTarget = target;
    }

    // initial animations
    cr.Action(CritterAction::UseWeapon, (((!isHit && isCritical && !hitRandomly) ? 1 : 0) << 8) | (aim << 4) | use, realWeapon);

    // animations are now played, and we're updating the hit randomly status now
    bool changedTarget = (hitRandomly && (realTarget != null));

    // commencing critical failures
    if (!isHit && isCritical && (!hitRandomly || realTarget == null)) {
        CriticalFailure(cr, weapon, use, ammo, critfailFlags, results);
        return;
    }

    // commencing attack, various instances
    bool criticalHit = isHit && isCritical;

    if (isHthAttack) // UNARMED AND MELEE ATTACK
    {
        if (isHit) {
            int crDir = cr.Dir;
            int tDir = realTarget.Dir;
            if (isSneak && cr.PerkSilentDeath != 0 && (crDir == tDir || ((crDir + 1) % 6) == tDir || ((crDir + 5) % 6) == tDir)) {
                attack.DmgMul *= 2;
            }
            ApplyDamage(attack, realTarget, 1, criticalHit, true, results);
        }
        else {
            if (changedTarget) {
                ApplyDamage(attack, realTarget, 1, false, false, results);
            }
            else {
                NotifyMiss(cr, results);
            }
        }
    }
    else if ((weaponSubtype == WS_GUN) && !isBurst && !isRocket && !isFlamethrower) // single shot, normal
    {
        if (isHit || changedTarget) {
            ApplyDamage(attack, realTarget, 1, criticalHit, !changedTarget, results);
        }
        else // standard miss here
        {
            Critter[] critsLine = {};
            attack.Aim = HitLocations::LocationUncalled;
            Obsolete::GetCrittersInPath(map, hx, hy, tx, ty, 0.0f, wpnMaxDist, CritterFindType::Alive, critsLine);
            int bl = 0;
            bool anyHit = false;
            for (int i = 0, j = critsLine.length(); (i < j) && !anyHit; i++) {
                if (critsLine[i].Id == realTarget.Id) {
                    bl++;
                    continue;
                } // skip the primary target

                // adjust tohit
                dist = Game.GetDistance(hx, hy, critsLine[i].HexX, critsLine[i].HexY);
                acc = dist;
                toHit = baseToHit;
                if (dist < distmod2) {
                    acc += distmod2;
                }
                else {
                    acc -= accloss;
                }
                if (-2 * perception > acc) {
                    acc = -2 * perception;
                }
                acc -= sharpshooter;
                if (acc > 0 && eyeDamage) {
                    acc *= 3;
                }
                acc *= -4;
                toHit += acc;
                acmod = critsLine[i].ArmorClass;
                if (valid(ammo)) {
                    acmod += ammo.Ammo_AcMod;
                }
                if (acmod > 0) {
                    toHit -= acmod;
                }
                toHit -= 10 * bl;
                if (critsLine[i].IsKnockout()) {
                    toHit += 40;
                }
                else {
                    bl++;
                }
                if (critsLine[i].Multihex > 0) {
                    toHit += 15;
                }
                toHit = CLAMP(toHit, 5, 95);
                toHit /= 3; // after clamp
                if (Game.Random(1, 100) <= toHit) {
                    NotifyOops(cr, target, critsLine[i], results);
                    normalTarget = critsLine[i];
                    useNormal = true;
                    ApplyDamage(attack, normalTarget, 1, false, false, results);
                    anyHit = true;
                }
            }
            if (!anyHit) {
                NotifyMiss(cr, results);
            }
        }
    }
    else if (isFlamethrower) // FLAME ATTACK
    {
        // adjust toHit if random hit
        if (changedTarget) {
            dist = Game.GetDistance(hx, hy, tx, ty);
            acc = dist;
            toHit = baseToHit;
            if (dist < distmod2) {
                acc += distmod2;
            }
            else {
                acc -= accloss;
            }
            if (-2 * perception > acc) {
                acc = -2 * perception;
            }
            acc -= sharpshooter;
            if (acc > 0 && eyeDamage) {
                acc *= 3;
            }
            acc *= -4;
            toHit += acc;
            acmod = realTarget.ArmorClass;
            if (valid(ammo)) {
                acmod += ammo.Ammo_AcMod;
            }
            if (acmod > 0) {
                toHit -= acmod;
            }
            if (realTarget.IsKnockout()) {
                toHit += 40;
            }
            if (realTarget.Multihex > 0) {
                toHit += 15;
            }
            int blockers = Obsolete::GetCrittersInPath(map, hx, hy, tx, ty, 0.0f, dist, CritterFindType::Alive, null);
            if (!realTarget.IsKnockout()) {
                blockers--;
            }
            toHit -= 10 * blockers;
            toHit = CLAMP(toHit, 5, 95);
        }

        // critical hit bonus, toHit can be increased over 100
        if (criticalHit) {
            toHit += 20;
        }

        // proceed with the flame attack
        Critter[] critsHit = {};
        uint[] critsHitBullets = {};
        int len_ = 0;

        if (Game.Random(1, 100) <= toHit) {
            critsHit.resize(1);
            critsHit[0] = realTarget;
            critsHitBullets.resize(1);
            critsHitBullets[0] += 1;
            len_++;
        }

        Critter[] lineCentral = {};
        Obsolete::GetCrittersInPath(map, hx, hy, tx, ty, 0.0f, wpnMaxDist, CritterFindType::Alive, lineCentral);
        int bl;

        bool threeLines = (Game.GetDistance(hx, hy, lineCentral[0].HexX, lineCentral[0].HexY) > 1); // target not adjacent and weapon not shotgun
        // already shot: MAX(rounds/6,1);

        for (int lineCount = 0, lineMax = (threeLines ? 1 : 3); lineCount < lineMax; lineCount++) {
            // lineCentral
            bl = 0; // zero blockers
            for (int i = 0, j = lineCentral.length(); i < j; i++) {
                // adjust tohit
                toHit = baseToHit - 10 * bl;
                dist = Game.GetDistance(hx, hy, lineCentral[i].HexX, lineCentral[i].HexY);
                acc = dist;
                if (dist < distmod2) {
                    acc += distmod2;
                }
                else {
                    acc -= accloss;
                }
                if (-2 * perception > acc) {
                    acc = -2 * perception;
                }
                acc -= sharpshooter;
                if (acc > 0 && eyeDamage) {
                    acc *= 3;
                }
                acc *= -4;
                toHit += acc;
                acmod = lineCentral[i].ArmorClass;
                if (valid(ammo)) {
                    acmod += ammo.Ammo_AcMod;
                }
                if (acmod > 0) {
                    toHit -= acmod;
                }
                if (lineCentral[i].IsKnockout()) {
                    toHit += 40;
                }
                else {
                    bl++;
                }
                if (lineCentral[i].Multihex > 0) {
                    toHit += 15;
                }
                toHit = CLAMP(toHit, 5, 95);
                if (Game.Random(1, 100) <= toHit) {
                    int crIndex = FindCritterInArray(critsHit, lineCentral[i]);
                    if (crIndex == -1) {
                        critsHit.resize(len_ + 1);
                        critsHit[len_] = lineCentral[i];
                        critsHitBullets.resize(len_ + 1);
                        crIndex = len_;
                        len_++;
                    }
                    critsHitBullets[crIndex] += 1;
                }
            }
            // lineCentral end
        }

        if (threeLines) {
            // rounds for the left stack
            // real left

            uint8 leftDir = Game.GetDirection(hx, hy, tx, ty, 89.0f);
            uint16 sx = hx;
            uint16 sy = hy;
            uint16 ex = tx;
            uint16 ey = ty;

            map.MoveHexByDir(sx, sy, leftDir, 1);
            map.MoveHexByDir(ex, ey, leftDir, 1);

            Critter[] lineLeft = {};
            Obsolete::GetCrittersInPath(map, sx, sy, ex, ey, 0.0f, wpnMaxDist - 1, CritterFindType::Alive, lineLeft);
            int leftStart = 0;
            int leftLen = lineLeft.length();
            while ((leftStart < leftLen) && (Game.GetDistance(hx, hy, lineLeft[leftStart].HexX, lineLeft[leftStart].HexY)) < 3) {
                leftStart++;
            }

            for (int i = leftStart, j = leftLen; i < j; i++) {
                // adjust tohit
                dist = Game.GetDistance(hx, hy, lineLeft[i].HexX, lineLeft[i].HexY);
                bl = Obsolete::GetCrittersInPath(map, hx, hy, lineLeft[i].HexX, lineLeft[i].HexY, 0.0f, dist, CritterFindType::Alive, null) - 1;
                toHit = baseToHit - 10 * bl;
                acc = dist;
                if (dist < distmod2) {
                    acc += distmod2;
                }
                else {
                    acc -= accloss;
                }
                if (-2 * perception > acc) {
                    acc = -2 * perception;
                }
                acc -= sharpshooter;
                if (acc > 0 && eyeDamage) {
                    acc *= 3;
                }
                acc *= -4;
                toHit += acc;
                acmod = lineLeft[i].ArmorClass;
                if (valid(ammo)) {
                    acmod += ammo.Ammo_AcMod;
                }
                if (acmod > 0) {
                    toHit -= acmod;
                }
                if (lineLeft[i].IsKnockout()) {
                    toHit += 40;
                }
                if (lineLeft[i].Multihex > 0) {
                    toHit += 15;
                }
                toHit = CLAMP(toHit, 5, 95);
                if (Game.Random(1, 100) <= toHit) {
                    int crIndex = FindCritterInArray(critsHit, lineLeft[i]);
                    if (crIndex == -1) {
                        critsHit.resize(len_ + 1);
                        critsHit[len_] = lineLeft[i];
                        critsHitBullets.resize(len_ + 1);
                        crIndex = len_;
                        len_++;
                    }
                    critsHitBullets[crIndex] += 1;
                }
            } // left line

            uint8 rightDir = Game.GetDirection(hx, hy, tx, ty, -89.0f);
            sx = hx;
            sy = hy;
            ex = tx;
            ey = ty;

            map.MoveHexByDir(sx, sy, rightDir, 1);
            map.MoveHexByDir(ex, ey, rightDir, 1);

            Critter[] lineRight = {};
            Obsolete::GetCrittersInPath(map, sx, sy, ex, ey, 0.0f, wpnMaxDist - 1, CritterFindType::Alive, lineRight);
            int rightStart = 0;
            int rightLen = lineRight.length();
            while ((rightStart < rightLen) && (Game.GetDistance(hx, hy, lineRight[rightStart].HexX, lineRight[rightStart].HexY)) < 3) {
                rightStart++;
            }
            for (int i = rightStart, j = rightLen; i < j; i++) {
                // adjust tohit
                dist = Game.GetDistance(hx, hy, lineRight[i].HexX, lineRight[i].HexY);
                bl = Obsolete::GetCrittersInPath(map, hx, hy, lineRight[i].HexX, lineRight[i].HexY, 0.0f, dist, CritterFindType::Alive, null) - 1;
                toHit = baseToHit - 10 * bl;
                acc = dist;
                if (dist < distmod2) {
                    acc += distmod2;
                }
                else {
                    acc -= accloss;
                }
                if (-2 * perception > acc) {
                    acc = -2 * perception;
                }
                acc -= sharpshooter;
                if (acc > 0 && eyeDamage) {
                    acc *= 3;
                }
                acc *= -4;
                toHit += acc;
                acmod = lineRight[i].ArmorClass;
                if (valid(ammo)) {
                    acmod += ammo.Ammo_AcMod;
                }
                if (acmod > 0) {
                    toHit -= acmod;
                }
                if (lineRight[i].IsKnockout()) {
                    toHit += 40;
                }
                if (lineRight[i].Multihex > 0) {
                    toHit += 15;
                }
                toHit = CLAMP(toHit, 5, 95);
                if (Game.Random(1, 100) <= toHit) {
                    int crIndex = FindCritterInArray(critsHit, lineRight[i]);
                    if (crIndex == -1) {
                        critsHit.resize(len_ + 1);
                        critsHit[len_] = lineRight[i];
                        critsHitBullets.resize(len_ + 1);
                        crIndex = len_;
                        len_++;
                    }
                    critsHitBullets[crIndex] += 1;
                }
            } // right line
        }

        for (int i = 0, j = len_; i < j; i++) {
            ApplyDamage(attack,
                        critsHit[i],
                        1,
                        (realTarget.Id == critsHit[i].Id) && criticalHit,
                        (cr.IsControlledByPlayer && !changedTarget) || (!cr.IsControlledByPlayer && critsHit[i].Id == target.Id),
                        results);
        }

        if (!changedTarget && !attack.TargetHit) {
            NotifyMiss(cr, results);
        }
    }
    else if ((weaponSubtype == WS_GUN) && isBurst) // BURST FIRE
    {
        // adjust toHit if random hit
        if (changedTarget) {
            dist = Game.GetDistance(hx, hy, tx, ty);
            acc = dist;
            toHit = baseToHit;
            if (dist < distmod2) {
                acc += distmod2;
            }
            else {
                acc -= accloss;
            }
            if (-2 * perception > acc) {
                acc = -2 * perception;
            }
            acc -= sharpshooter;
            if (acc > 0 && eyeDamage) {
                acc *= 3;
            }
            acc *= -4;
            toHit += acc;
            acmod = realTarget.ArmorClass;
            if (valid(ammo)) {
                acmod += ammo.Ammo_AcMod;
            }
            if (acmod > 0) {
                toHit -= acmod;
            }
            if (realTarget.IsKnockout()) {
                toHit += 40;
            }
            if (realTarget.Multihex > 0) {
                toHit += 15;
            }
            int blockers = Obsolete::GetCrittersInPath(map, hx, hy, tx, ty, 0.0f, dist, CritterFindType::Alive, null);
            if (!realTarget.IsKnockout()) {
                blockers--;
            }
            toHit -= 10 * blockers;
            toHit = CLAMP(toHit, 5, 95);
        }

        // critical hit bonus, toHit can be increased over 100
        if (criticalHit) {
            toHit += 20;
        }

        // proceed with the burst attack
        int rounds = ammoRound;
        if (valid(realWeapon) && int(realWeapon.AmmoCount) < rounds) {
            rounds = realWeapon.AmmoCount;
        }
        Critter[] critsHit = {};
        uint[] critsHitBullets = {};

        int len_ = 0;
        int volleyRounds = MAX((rounds / 6), 1);

        int curRounds = 0;
        for (int i = 0; i < volleyRounds; i++) {
            if (Game.Random(1, 100) <= toHit) {
                curRounds++;
            }
        }
        if (curRounds != 0) {
            critsHit.resize(1);
            critsHitBullets.resize(1);
            critsHit[0] = realTarget;
            critsHitBullets[0] = curRounds;
            len_++;
        }
        volleyRounds -= curRounds;

        Critter[] lineCentral = {};
        Obsolete::GetCrittersInPath(map, hx, hy, tx, ty, 0.0f, wpnMaxDist, CritterFindType::Alive, lineCentral);

        int bl = 0;
        curRounds = 0;
        for (int i = 0, j = lineCentral.length(); (i < j) && (volleyRounds > 0); i++) {
            if (lineCentral[i].Id == realTarget.Id) {
                bl++;
                continue;
            } // skip the primary target, but add blocker
            // adjust tohit
            toHit = baseToHit - 10 * bl;
            dist = Game.GetDistance(hx, hy, lineCentral[i].HexX, lineCentral[i].HexY);
            acc = dist;
            if (dist < distmod2) {
                acc += distmod2;
            }
            else {
                acc -= accloss;
            }
            if (-2 * perception > acc) {
                acc = -2 * perception;
            }
            acc -= sharpshooter;
            if (acc > 0 && eyeDamage) {
                acc *= 3;
            }
            acc *= -4;
            toHit += acc;
            acmod = lineCentral[i].ArmorClass;
            if (valid(ammo)) {
                acmod += ammo.Ammo_AcMod;
            }
            if (acmod > 0) {
                toHit -= acmod;
            }
            toHit = CLAMP(toHit, 5, 95);
            if (lineCentral[i].IsKnockout()) {
                toHit += 40;
            }
            else {
                bl++;
            }
            if (lineCentral[i].Multihex > 0) {
                toHit += 15;
            }
            for (curRounds = 0; curRounds < volleyRounds;) {
                if (Game.Random(1, 100) <= toHit) {
                    curRounds++;
                }
                else {
                    break;
                }
            }
            volleyRounds -= curRounds;
            if (curRounds > 0) {
                int crIndex = FindCritterInArray(critsHit, lineCentral[i]);
                if (crIndex == -1) {
                    critsHit.resize(len_ + 1);
                    critsHit[len_] = lineCentral[i];
                    critsHitBullets.resize(len_ + 1);
                    critsHitBullets[len_] = 0;
                    crIndex = len_;
                    len_++;
                }
                critsHitBullets[crIndex] += curRounds;
            }
        }

        // now we're shooting the rest of the bullets (=rounds-MAX(1,rounds/6))
        bool threeLines =
            (Game.GetDistance(hx, hy, lineCentral[0].HexX, lineCentral[0].HexY) > 1) && (ammoRound > 3); // target not adjacent and weapon not shotgun

        // already shot: MAX(rounds/6,1);

        for (int lineCount = 0, lineMax = (threeLines ? 1 : 3); lineCount < lineMax; lineCount++) {
            // rounds for central stack

            if (lineCount == 0) {
                volleyRounds = rounds - (((rounds + 1) / 3) + (rounds / 3)); // second central, always
                volleyRounds -= MAX(rounds / 6, 1);
            }
            else {
                if (lineCount == 1) {
                    volleyRounds = (rounds + 1) / 3; // left line
                }
                else {
                    volleyRounds = rounds / 3; // right line
                }
            }

            if (volleyRounds == 0) {
                continue; // end this
            }

            // lineCentral
            bl = 0; // zero blockers
            for (int i = 0, j = lineCentral.length(); (i < j) && (volleyRounds > 0); i++) {
                // adjust tohit
                toHit = baseToHit - 10 * bl;
                dist = Game.GetDistance(hx, hy, lineCentral[i].HexX, lineCentral[i].HexY);
                acc = dist;
                if (dist < distmod2) {
                    acc += distmod2;
                }
                else {
                    acc -= accloss;
                }
                if (-2 * perception > acc) {
                    acc = -2 * perception;
                }
                acc -= sharpshooter;
                if (acc > 0 && eyeDamage) {
                    acc *= 3;
                }
                acc *= -4;
                toHit += acc;
                acmod = lineCentral[i].ArmorClass;
                if (valid(ammo)) {
                    acmod += ammo.Ammo_AcMod;
                }
                if (acmod > 0) {
                    toHit -= acmod;
                }
                if (lineCentral[i].IsKnockout()) {
                    toHit += 40;
                }
                if (lineCentral[i].Multihex > 0) {
                    toHit += 15;
                }
                toHit = CLAMP(toHit, 5, 95);
                bl++;
                for (curRounds = 0; curRounds < volleyRounds;) {
                    if (Game.Random(1, 100) <= toHit) {
                        curRounds++;
                    }
                    else {
                        break;
                    }
                }
                volleyRounds -= curRounds;
                if (curRounds > 0) {
                    int crIndex = FindCritterInArray(critsHit, lineCentral[i]);
                    if (crIndex == -1) {
                        critsHit.resize(len_ + 1);
                        critsHit[len_] = lineCentral[i];
                        critsHitBullets.resize(len_ + 1);
                        critsHitBullets[len_] = 0;
                        crIndex = len_;
                        len_++;
                    }
                    critsHitBullets[crIndex] += curRounds;
                }
            }
            // lineCentral end
        }

        if (threeLines) {
            // rounds for the left stack
            volleyRounds = (rounds + 1) / 3;

            if (volleyRounds > 0) // real left
            {
                uint8 leftDir = Game.GetDirection(hx, hy, tx, ty, 89.0f);
                uint16 sx = hx;
                uint16 sy = hy;
                uint16 ex = tx;
                uint16 ey = ty;

                map.MoveHexByDir(sx, sy, leftDir, 1);
                map.MoveHexByDir(ex, ey, leftDir, 1);

                Critter[] lineLeft = {};
                Obsolete::GetCrittersInPath(map, sx, sy, ex, ey, 0.0f, wpnMaxDist - 1, CritterFindType::Alive, lineLeft);
                int leftStart = 0;
                int leftLen = lineLeft.length();
                while ((leftStart < leftLen) && (Game.GetDistance(hx, hy, lineLeft[leftStart].HexX, lineLeft[leftStart].HexY)) < 3) {
                    leftStart++;
                }

                for (int i = leftStart, j = leftLen; (i < j) && (volleyRounds > 0); i++) {
                    // adjust tohit
                    dist = Game.GetDistance(hx, hy, lineLeft[i].HexX, lineLeft[i].HexY);
                    bl = Obsolete::GetCrittersInPath(map, hx, hy, lineLeft[i].HexX, lineLeft[i].HexY, 0.0f, dist, CritterFindType::Alive, null) - 1;
                    toHit = baseToHit - 10 * bl;
                    acc = dist;
                    if (dist < distmod2) {
                        acc += distmod2;
                    }
                    else {
                        acc -= accloss;
                    }
                    if (-2 * perception > acc) {
                        acc = -2 * perception;
                    }
                    acc -= sharpshooter;
                    if (acc > 0 && eyeDamage) {
                        acc *= 3;
                    }
                    acc *= -4;
                    toHit += acc;
                    acmod = lineLeft[i].ArmorClass;
                    if (valid(ammo)) {
                        acmod += ammo.Ammo_AcMod;
                    }
                    if (acmod > 0) {
                        toHit -= acmod;
                    }
                    if (lineLeft[i].IsKnockout()) {
                        toHit += 40;
                    }
                    if (lineLeft[i].Multihex > 0) {
                        toHit += 15;
                    }
                    toHit = CLAMP(toHit, 5, 95);
                    for (curRounds = 0; curRounds < volleyRounds;) {
                        if (Game.Random(1, 100) <= toHit) {
                            curRounds++;
                        }
                        else {
                            break;
                        }
                    }
                    volleyRounds -= curRounds;
                    if (curRounds > 0) {
                        int crIndex = FindCritterInArray(critsHit, lineLeft[i]);
                        if (crIndex == -1) {
                            critsHit.resize(len_ + 1);
                            critsHit[len_] = lineLeft[i];
                            critsHitBullets.resize(len_ + 1);
                            critsHitBullets[len_] = 0;
                            crIndex = len_;
                            len_++;
                        }
                        critsHitBullets[crIndex] += curRounds;
                    }
                }
            } // left line

            // rounds for the right stack
            volleyRounds = (rounds) / 3;

            if (volleyRounds > 0) {
                uint8 rightDir = Game.GetDirection(hx, hy, tx, ty, -89.0f);

                uint16 sx = hx;
                uint16 sy = hy;
                uint16 ex = tx;
                uint16 ey = ty;

                map.MoveHexByDir(sx, sy, rightDir, 1);
                map.MoveHexByDir(ex, ey, rightDir, 1);

                Critter[] lineRight = {};
                Obsolete::GetCrittersInPath(map, sx, sy, ex, ey, 0.0f, wpnMaxDist - 1, CritterFindType::Alive, lineRight);
                int rightStart = 0;
                int rightLen = lineRight.length();
                while ((rightStart < rightLen) && (Game.GetDistance(hx, hy, lineRight[rightStart].HexX, lineRight[rightStart].HexY)) < 3) {
                    rightStart++;
                }
                for (int i = rightStart, j = rightLen; (i < j) && (volleyRounds > 0); i++) {
                    // adjust tohit
                    dist = Game.GetDistance(hx, hy, lineRight[i].HexX, lineRight[i].HexY);
                    bl = Obsolete::GetCrittersInPath(map, hx, hy, lineRight[i].HexX, lineRight[i].HexY, 0.0f, dist, CritterFindType::Alive, null) - 1;
                    toHit = baseToHit - 10 * bl;
                    acc = dist;
                    if (dist < distmod2) {
                        acc += distmod2;
                    }
                    else {
                        acc -= accloss;
                    }
                    if (-2 * perception > acc) {
                        acc = -2 * perception;
                    }
                    acc -= sharpshooter;
                    if (acc > 0 && eyeDamage) {
                        acc *= 3;
                    }
                    acc *= -4;
                    toHit += acc;
                    acmod = lineRight[i].ArmorClass;
                    if (valid(ammo)) {
                        acmod += ammo.Ammo_AcMod;
                    }
                    if (acmod > 0) {
                        toHit -= acmod;
                    }
                    if (lineRight[i].IsKnockout()) {
                        toHit += 40;
                    }
                    if (lineRight[i].Multihex > 0) {
                        toHit += 15;
                    }
                    toHit = CLAMP(toHit, 5, 95);
                    for (curRounds = 0; curRounds < volleyRounds;) {
                        if (Game.Random(1, 100) <= toHit) {
                            curRounds++;
                        }
                        else {
                            break;
                        }
                    }
                    volleyRounds -= curRounds;
                    if (curRounds > 0) {
                        int crIndex = FindCritterInArray(critsHit, lineRight[i]);
                        if (crIndex == -1) {
                            critsHit.resize(len_ + 1);
                            critsHit[len_] = lineRight[i];
                            critsHitBullets.resize(len_ + 1);
                            critsHitBullets[len_] = 0;
                            crIndex = len_;
                            len_++;
                        }
                        critsHitBullets[crIndex] += curRounds;
                    }
                }
            } // right line
        }

        for (int i = 0, j = len_; i < j; i++) {
            ApplyDamage(attack,
                        critsHit[i],
                        critsHitBullets[i],
                        (realTarget.Id == critsHit[i].Id) && criticalHit,
                        (cr.IsControlledByPlayer && !changedTarget) || (!cr.IsControlledByPlayer && critsHit[i].Id == target.Id),
                        results);
        }

        if (!changedTarget && !attack.TargetHit) {
            NotifyMiss(cr, results);
        }
    } // burst attack
    else if (isRocket || (weaponSubtype == WS_THROWING)) // ROCKETS, THROWING
    {
        bool exploding = isRocket || isGrenade;

        if (isHit || changedTarget) {
            if (exploding) {
                CommenceExplosion(attack, map, tx, ty, realTarget, weapPid, ammoPid, criticalHit, realTarget.Id, isRocket, results);
            }
            else {
                ApplyDamage(attack, realTarget, 1, criticalHit, !changedTarget, results);
            }
        }
        else {
            // miss with missiles
            attack.Aim = HitLocations::LocationUncalled;

            if (weaponSubtype == WS_THROWING) {
                sharpshooter = 0;
            }
            uint16 bx = 0;
            uint16 by = 0;
            uint16 pbx = 0;
            uint16 pby = 0;

            Critter[] critsLine = {};
            Obsolete::GetCrittersInPath(map, hx, hy, tx, ty, 0.0f, wpnMaxDist, CritterFindType::Alive, critsLine, pbx, pby, bx, by);

            int bl = 0;
            bool anyHit = false;
            for (int i = 0, j = critsLine.length(); (i < j) && !anyHit; i++) {
                if (critsLine[i].Id == realTarget.Id) {
                    bl++;
                    continue;
                } // skip the primary target

                // adjust tohit
                dist = Game.GetDistance(hx, hy, critsLine[i].HexX, critsLine[i].HexY);
                acc = dist;
                toHit = baseToHit;
                if (dist < distmod2) {
                    acc += distmod2;
                }
                else {
                    acc -= accloss;
                }
                if (-2 * perception > acc) {
                    acc = -2 * perception;
                }
                acc -= sharpshooter;
                if (acc > 0 && eyeDamage) {
                    acc *= 3;
                }
                acc *= -4;
                toHit += acc;
                acmod = critsLine[i].ArmorClass;
                if (valid(ammo)) {
                    acmod += ammo.Ammo_AcMod;
                }
                if (acmod > 0) {
                    toHit -= acmod;
                }
                toHit -= 10 * bl;
                if (critsLine[i].IsKnockout()) {
                    toHit += 40;
                }
                else {
                    bl++;
                }
                if (critsLine[i].Multihex > 0) {
                    toHit += 15;
                }
                toHit = CLAMP(toHit, 5, 95);
                toHit /= 3; // after clamp
                if (Game.Random(1, 100) <= toHit) {
                    tx = critsLine[i].HexX;
                    ty = critsLine[i].HexY;
                    normalTarget = critsLine[i];
                    anyHit = true;
                }
            }

            if (anyHit) {
                NotifyOops(cr, target, normalTarget, results);
                useNormal = true;

                if (exploding) {
                    CommenceExplosion(attack, map, tx, ty, normalTarget, weapPid, ammoPid, false, realTarget.Id, isRocket, results);
                }
                else {
                    ApplyDamage(attack, normalTarget, 1, false, false, results);
                }
            }
            else {
                useHex = true;
                NotifyMiss(cr, results);
                if (isGrenade) {
                    tx = realTarget.HexX;
                    ty = realTarget.HexY;
                    int newdist = Game.GetDistance(hx, hy, tx, ty) + 1;
                    map.MoveHexByDir(tx, ty, Game.Random(0, 5), Game.Random(1, newdist / 2));
                    newdist = Game.GetDistance(hx, hy, tx, ty);
                    // Чтение координат взрыва
                    map.GetCrittersInPath(hx, hy, tx, ty, 0.0f, newdist, CritterFindType::Alive, tx, ty, bx, by);
                }
                else {
                    if (isRocket) {
                        tx = bx;
                        ty = by;
                    }
                    else {
                        tx = pbx;
                        ty = pby;
                    }
                }

                if (exploding) {
                    CommenceExplosion(attack, map, tx, ty, null, weapPid, ammoPid, false, realTarget.Id, isRocket, results);
                }
            }
        } // miss
    }
    else {
        cr.Say(SAY_NETMSG, "Combat error: weapon PID=" + weapPid + " not handled, please send bug report.");
    }

    // combat messages

    FlushResults(results);

    // stuff like animations, effects

    // Shoot
    if (_WeaponEffect(weapon, use) != EMPTY_HSTRING) {
        if (useHex) {
            map.RunFlyEffect(_WeaponEffect(weapon, use), cr, null, hx, hy, tx, ty); // yeah, the target can be null (see: grenades, rocket launcher)
        }
        else {
            map.RunFlyEffect(_WeaponEffect(weapon, use), cr, useNormal ? normalTarget : realTarget, hx, hy, tx, ty);
        }
    }

    if (ammoRound > 0 && valid(realWeapon) && !cr.IsUnlimitedAmmo) {
        if (realWeapon.AmmoCount <= ammoRound) {
            realWeapon.AmmoCount = 0;
        }
        else {
            realWeapon.AmmoCount -= ammoRound;
        }
    }

    if (valid(realWeapon)) {
        if (realWeapon.Deteriorable) {
            Repair::DeteriorateItem(cr, realWeapon, (MAX_SKILL_VAL - skillVal) / 3);
        }

        // One time weapon, erase current and push next (if exist)
        if (wpnIsRemoved && !cr.IsUnlimitedAmmo) {
            bool placeOnHex = (skill == CritterProperty::SkillThrowing && !isGrenade);
            if (realWeapon.Stackable) {
                // Place on hex
                if (placeOnHex) {
                    map.AddItem(tx, ty, weapPid, 1);
                }

                // Sub 1 item
                if (realWeapon.Count > 1) {
                    realWeapon.Count = realWeapon.Count - 1;
                }
                else {
                    Game.DestroyItem(realWeapon);
                }
            }
            else {
                ItemMovement::MoveItem(realWeapon, 0, map, tx, ty);
            }
        }
    }

    // Npc miss text
    if (!attack.TargetHit) {
        if (!target.IsControlledByPlayer) {
            AiSettings::AI_TrySayCombatText(target, CombatText::Miss);
        }
        target.Action(CritterAction::Dodge, 0, null); // Todo: type front/back
    }

    return;
}

void ApplyDamage(AttackStruct attack, Critter target, uint rounds, bool isCritical, bool intentionally, CombatRes[] results)
{
    int dmgMul = attack.DmgMul;
    uint bt = target.BodyType;
    uint eff = 0;
    uint msgEff = 0;
    ItemPerks weaponPerk = attack.WeaponPerk;
    Critter attacker = attack.Attacker;
    bool validAttacker = valid(attacker);
    Map map = target.GetMap();
    bool isBloodyMess = attack.BloodyMess;
    bool isCombatText = attack.CombatMessage;
    Item realWeapon = attack.RealWeapon;
    uint aim = attack.Aim;
    uint extraMessage = 0;
    uint extraMessageSelf = 0;

    bool targetIsPlayer = target.IsControlledByPlayer;
    bool attackerIsPlayer = (valid(attacker) ? attacker.IsControlledByPlayer : false);

    if (target.IsDead() || not valid(map)) {
        return;
    }

    if (validAttacker && intentionally && target.Id != attack.TargetId) {
        Game.OnCritterAttacked.Fire(target, attacker);
    }

    // check if hit
    if (target.Id == attack.TargetId) {
        attack.TargetHit = true;
    }

    // Check no PvP
    if (targetIsPlayer && attackerIsPlayer && validAttacker && (attacker.IsNoPvp || target.IsNoPvp)) {
        if (validAttacker) {
            attacker.Say(SAY_NETMSG, "No PvP.");
        }
        target.Say(SAY_NETMSG, "No PvP.");
        return;
    }
    // Мины от игроков, ушедших на глобал
    if (targetIsPlayer && !validAttacker && target.IsNoPvp) {
        target.Say(SAY_NETMSG, "No PvP.");
        return;
    }

    if (target.InSneakMode) {
        target.InSneakMode = false;
    }

    uint targetTimeout = BATTLE_TIMEOUT(target);
    if (target.TimeoutBattle < targetTimeout) {
        target.TimeoutBattle = targetTimeout;
    }
    target.TimeoutSneak = SNEAK_TIMEOUT(target);

    if (target.IsInvulnerable) {
        isCritical = false;
    }

    if (isCritical && (attack.WeaponSubtype == WS_GUN || attack.WeaponSubtype == WS_THROWING) && target.PerkTerminator != 0 &&
        (target.StrengthBase + target.EnduranceBase) * 5 >= Game.Random(1, 100)) {
        isCritical = false;
    }
    else if (isCritical || attack.ForceFlags != 0) {
        if (isCritical) {
            int aim_ = aim;
            if (aim_ == HitLocations::LocationNone) {
                aim_ = HitLocations::LocationUncalled;
            }
            aim_--;
            int roll = Game.Random(0, 100) + (validAttacker ? ((attacker.PerkBetterCriticals != 0 ? 20 : 0) + (attacker.IsTraitHeavyHanded ? -30 : 0)) : 0);
            if (roll <= 20) {
                roll = 0;
            }
            else if (roll <= 45) {
                roll = 1;
            }
            else if (roll <= 70) {
                roll = 2;
            }
            else if (roll <= 90) {
                roll = 3;
            }
            else if (roll <= 100) {
                roll = 4;
            }
            else {
                roll = 5;
            }

            // 0x00000001 - knockout
            // 0x00000002 - knockdown
            // 0x00000004 - crippled left leg
            // 0x00000008 - crippled right leg
            // 0x00000010 - crippled left arm
            // 0x00000020 - crippled right arm
            // 0x00000040 - blinded
            // 0x00000080 - death
            // 0x00000400 !- on fire - triggers the 'flamedance' animation, but not if the hit is fatal (probably a bug) // not used now
            // 0x00000800 - bypass armor
            // 0x00004000 - dropped weapon (doesn't work) // haha, really?
            // 0x00008000 - lose next turn
            // 0x00200000 - random

            uint offset = bt * 9 * 6 * 7 + aim_ * 6 * 7 + roll * 7;
            dmgMul *= CriticalTable[offset];
            dmgMul >>= 1;
            eff = CriticalTable[offset + 1];
            int stat = CriticalTable[offset + 2];
            int statMod = CriticalTable[offset + 3];

            uint cMessage = CriticalTable[offset + 5];
            uint cFailureMessage = CriticalTable[offset + 6];

            extraMessage = cMessage;

            if (stat != -1) {
                if (Game.Random(1, 10) > target.GetAsInt(CritterProperty(stat)) + statMod) {
                    eff |= CriticalTable[offset + 4];
                    extraMessage = cFailureMessage;
                }
            }

            if (weaponPerk == ItemPerks::EnhancedKnockout) {
                SETFLAG(eff, HF_KNOCKOUT);
            }

            if (target.IsNoKnock) {
                UNSETFLAG(eff, HF_KNOCKDOWN);
            }
            else if (FLAG(eff, HF_KNOCKDOWN) && target.PerkStonewall != 0 && (Game.Random(0, 100) < 50)) {
                UNSETFLAG(eff, HF_KNOCKDOWN);
            }
        }

        if (attack.ForceFlags != 0) {
            eff |= attack.ForceFlags;
            isCritical = true;
        }

        // in the following: in no lose limbs, then clear the effects and set msgEff
        // otherwise set msgEff first, then check for HF_RANDOM
        if (target.IsNoLooseLimbs) {
            UNSETFLAG(eff, (HF_CRIPPLED_LEFT_LEG | HF_CRIPPLED_RIGHT_LEG | HF_CRIPPLED_LEFT_ARM | HF_CRIPPLED_RIGHT_ARM | HF_RANDOM));
            msgEff = eff;
        }
        else {
            msgEff = eff;

            if (FLAG(eff, HF_RANDOM)) {
                UNSETFLAG(eff, HF_RANDOM);
                switch (Game.Random(1, 4)) {
                case 1:
                    SETFLAG(eff, HF_CRIPPLED_LEFT_LEG);
                    break;
                case 2:
                    SETFLAG(eff, HF_CRIPPLED_RIGHT_LEG);
                    break;
                case 3:
                    SETFLAG(eff, HF_CRIPPLED_LEFT_ARM);
                    break;
                case 4:
                    SETFLAG(eff, HF_CRIPPLED_RIGHT_ARM);
                    break;
                default:
                    break;
                }
            }
        }
        if (target.IsNoDrop) {
            UNSETFLAG(eff, HF_DROPPED_WEAPON);
            UNSETFLAG(msgEff, HF_DROPPED_WEAPON);
        }

        if (validAttacker && attackerIsPlayer) {
            Scores::AddScore(attacker, EScores::Sniper, 1);
        }
    } // end isCritical

    if (weaponPerk == ItemPerks::EnhancedKnockout) {
        if (validAttacker) {
            if (Game.Random(1, 100) <= (attacker.Strength) - 8) {
                SETFLAG(eff, HF_KNOCKOUT);
            }
        }
    } // not messaged

    DamageTypes dmgType = attack.DmgType;
    int targetDR = target.DamageResistance[dmgType];
    int targetDT = target.DamageThreshold[dmgType];

    if (FLAG(eff, HF_BYPASS_ARMOR) && dmgType != DamageTypes::Emp) {
        targetDT /= 5;
        targetDR /= 5;
        targetDR -= (valid(attacker) ? (attacker.IsTraitFinesse ? 30 : 0) : 0);
    }
    else if (weaponPerk == ItemPerks::Penetrate) {
        targetDT /= 5;
    }

    targetDR += (validAttacker ? (attacker.IsTraitFinesse ? 30 : 0) : 0);
    targetDR += attack.DRMod; // always
    targetDR = CLAMP(targetDR, 0, 100);
    int dmgMin = attack.DmgMin + attack.BonusDmg;
    int dmgMax = attack.DmgMax + attack.BonusDmg;
    int rawDmg;
    int totalDmg = 0;
    dmgMul *= attack.DMMod;
    int dmgDiv = 2 * attack.DDMod;
    for (uint i = 0; i < rounds; i++) {
        rawDmg = Game.Random(dmgMin, dmgMax);
        rawDmg *= dmgMul;
        rawDmg /= dmgDiv;
        rawDmg -= targetDT;
        rawDmg -= (rawDmg * targetDR) / 100;
        if (rawDmg > 0) {
            totalDmg += rawDmg;
        }
    }
    if (validAttacker) {
        if (attack.Attacker.PerkLivingAnatomy != 0 && !(bt == BodyTypes::Alien || bt == BodyTypes::Robot)) {
            totalDmg += 5; // yes, pulse grenade works
        }
        if (attack.Attacker.PerkPyromaniac != 0 && dmgType == DamageTypes::Fire) {
            totalDmg += 5;
        }
    }

    // 0x00000001 - knockout
    // 0x00000002 - knockdown
    // 0x00000004 - crippled left leg
    // 0x00000008 - crippled right leg
    // 0x00000010 - crippled left arm
    // 0x00000020 - crippled right arm
    // 0x00000040 - blinded
    // 0x00000080 - death
    // 0x00000400 !- on fire - triggers the 'flamedance' animation, but not if the hit is fatal (probably a bug)
    // 0x00000800 - bypass armor
    // 0x00004000 !- dropped weapon (doesn't work)
    // 0x00008000 - lose next turn

    // code for dropping weapon, adapted from critical failures

    if (FLAG(eff, HF_DROPPED_WEAPON)) {
        Item realWeaponTarget = _CritGetItemHand(target);
        if (valid(realWeaponTarget)) {
            if (realWeaponTarget.Stackable) {
                Item dropped = map.AddItem(target.HexX, target.HexY, realWeaponTarget.ProtoId, 1);
                if (realWeaponTarget.Count > 1) {
                    realWeaponTarget.Count = realWeaponTarget.Count - 1;
                }
                else {
                    Game.DestroyItem(realWeaponTarget);
                }

                if (!target.IsControlledByPlayer) {
                    NpcPlanes::NpcPlane plane = NpcPlanes::CreatePlane();
                    NpcPlanes::NpcPlane[] crPlanes = {}; // array<NpcPlanes::NpcPlane>( 0 );

                    if (NpcPlanes::GetPlanes(target, crPlanes) > 0) {
                        plane.Priority = crPlanes[0].Priority + 1;
                    }
                    else {
                        plane.Priority = 70;
                    }

                    plane.Type = AI_PLANE_PICK;
                    plane.Pick_HexX = dropped.HexX;
                    plane.Pick_HexY = dropped.HexY;
                    plane.Pick_Pid = dropped.ProtoId;
                    plane.Pick_UseItemId = ZERO_IDENT;
                    plane.Pick_ToOpen = false;
                    plane.Run = true;
                    NpcPlanes::AddPlane(target, plane);
                }
            }
            else {
                ItemMovement::MoveItem(realWeaponTarget, 0, map, target.HexX, target.HexY);
                if (!target.IsControlledByPlayer) {
                    NpcPlanes::NpcPlane plane = NpcPlanes::CreatePlane();

                    NpcPlanes::NpcPlane[] crPlanes = {};

                    if (NpcPlanes::GetPlanes(target, crPlanes) > 0) {
                        plane.Priority = crPlanes[0].Priority + 1;
                    }
                    else {
                        plane.Priority = 70;
                    }

                    plane.Type = AI_PLANE_PICK;
                    plane.Pick_HexX = realWeaponTarget.HexX;
                    plane.Pick_HexY = realWeaponTarget.HexY;
                    plane.Pick_Pid = realWeaponTarget.ProtoId;
                    plane.Pick_UseItemId = ZERO_IDENT;
                    plane.Pick_ToOpen = false;
                    plane.Run = true;
                    NpcPlanes::AddPlane(target, plane);
                }
            }
        }
    }

    bool isKo = false;
    bool knockDown = false;
    bool knockOut = false;
    bool isDead = false;
    bool loseTurn = false;
    bool isBelow = false;
    int knockDmg = totalDmg;

    if (target.IsInvulnerable) {
        eff = 0;
    }

    // Knock down
    if (FLAG(eff, HF_KNOCKDOWN)) {
        isKo = true;
        knockDown = true;
    }
    else if (dmgType == DamageTypes::Explode && totalDmg > 9) {
        isKo = true;
    }

    // Clipped LLeg
    if (FLAG(eff, HF_CRIPPLED_LEFT_LEG)) {
        target.IsDamagedLeftLeg = true;
    }
    // Clipped RLeg
    if (FLAG(eff, HF_CRIPPLED_RIGHT_LEG)) {
        target.IsDamagedRightLeg = true;
    }
    // Clipped LArm
    if (FLAG(eff, HF_CRIPPLED_LEFT_ARM)) {
        target.IsDamagedLeftArm = true;
    }
    // Clipped RArm
    if (FLAG(eff, HF_CRIPPLED_RIGHT_ARM)) {
        target.IsDamagedRightArm = true;
    }
    // Blinded
    if (FLAG(eff, HF_BLINDED)) {
        target.IsDamagedEye = true;
    }

    // Lose turn
    if (FLAG(eff, HF_LOST_NEXT_TURN)) {
        isKo = true;
        loseTurn = true;
    }
    // Knock out
    if (FLAG(eff, HF_KNOCKOUT)) {
        isKo = true;
        knockOut = true;
        loseTurn = false; // overridden
    }

    // Instant death
    if (FLAG(eff, HF_DEATH)) {
        if (target.CurrentHp > totalDmg) {
            totalDmg = target.CurrentHp;
        }
    }

    if (totalDmg > 0) {
        if (!target.IsInvulnerable) {
            target.CurrentHp -= totalDmg;
            if (target.CurrentHp < 1) {
                if (target.CurrentHp > Settings.DeadHitPoints && !target.IsNoKnock) {
                    isKo = true;
                    isBelow = true;
                }
                else {
                    isDead = true;
                }
            }
        }
        // Score
        if (attack.scoreUnarmed && validAttacker && attackerIsPlayer) {
            Scores::AddScore(attacker, EScores::UnarmedDamage, totalDmg);
        }
    }

    bool attackFront = true;
    uint dir = Game.GetDirection(attack.Hx, attack.Hy, target.HexX, target.HexY);
    if ((dir == target.Dir || ((dir + 1) % 6) == target.Dir || ((dir + 5) % 6) == target.Dir)) {
        attackFront = false;
    }

    int armorDr = target.DamageResistance[dmgType];
    Item armor = _CritGetItemArmor(target);
    if (valid(armor) && targetIsPlayer) {
        Repair::DeteriorateItem(target, armor, ((100 - armorDr) * rounds + totalDmg) / 3);
    }

    // Dead
    if (isDead) {
        bool burst = attack.IsBurst;
        CritterActionAnim actionAnimDead = CritterActionAnim::None;

        if (target.IsKnockout()) {
            if (target.KnockoutActionAnim == CritterActionAnim::IdleProneFront) {
                actionAnimDead = CritterActionAnim::DeadProneFront;
            }
            else {
                actionAnimDead = CritterActionAnim::DeadProneBack;
            }
        }
        else {
            if (attackFront) {
                actionAnimDead = CritterActionAnim::DeadFront;
            }
            else {
                actionAnimDead = CritterActionAnim::DeadBack;
            }

            switch (dmgType) {
            case DamageTypes::Normal:
                if (burst) {
                    if (isCritical || isBloodyMess) {
                        actionAnimDead = CritterActionAnim::DeadBloodyBurst;
                    }
                    else {
                        actionAnimDead = CritterActionAnim::DeadBurst;
                    }
                }
                else {
                    if (isCritical || isBloodyMess) {
                        actionAnimDead = CritterActionAnim::DeadBloodySingle;
                    }
                }
                break;
            case DamageTypes::Laser:
                actionAnimDead = CritterActionAnim::DeadLaser;
                break;
            case DamageTypes::Fire:
                if (Game.Random(0, 1) == 0) {
                    actionAnimDead = CritterActionAnim::DeadBurn;
                }
                else {
                    actionAnimDead = CritterActionAnim::DeadBurnRun;
                }
                break;
            case DamageTypes::Plasma:
                actionAnimDead = CritterActionAnim::DeadFused;
                break;
            case DamageTypes::Electricity:
                if (Game.Random(0, 1) == 0) {
                    actionAnimDead = CritterActionAnim::DeadPulse;
                }
                else {
                    actionAnimDead = CritterActionAnim::DeadPulseDust;
                }
                break;
            case DamageTypes::Explode:
                actionAnimDead = CritterActionAnim::DeadExplode;
                break;
            default:
                break;
            }
        }

        if (targetIsPlayer) {
            Scores::AddScore(target, EScores::Zomby, 1);
        }

        if (validAttacker && attackerIsPlayer) {
            Scores::AddScore(attacker, EScores::Killer, 1);
            if (targetIsPlayer) {
                Scores::AddScore(attacker, EScores::Maniac, 1);
            }
            else if (target.Id == attack.TargetId) {
                EnemyStack::AddEnemyToStack(target, attacker.Id);
            }
        }

        if (validAttacker && !attackerIsPlayer) {
            EnemyStack::EraseEnemyFromStack(attacker, target.Id);
        }

        if (valid(attacker)) {
            attacker.Experience += target.KillExperience;
            if (bt < attacker.Kills.length()) {
                uint[] kills = attacker.Kills.clone();
                kills[bt] += 1;
                attacker.Kills = kills;
            }
        }

        CritterState::ToDead(target, actionAnimDead, attacker);
    }
    else if (isKo) {
        int maxAp = target.ActionPoints;
        int currentAp = target.CurrentAp / AP_DIVIDER;
        int targetAp = currentAp;
        if (loseTurn) {
            targetAp = -maxAp;
        }
        if (knockOut) {
            targetAp = -Game.Random(maxAp, 3 * maxAp);
        }
        if (knockDown && !target.IsKnockout()) {
            targetAp -= (target.PerkQuickRecovery != 0 ? 1 : 3);
        }
        if ((isBelow || knockOut || knockDown || dmgType == DamageTypes::Explode) && !target.IsKnockout() && !target.IsNoKnock) {
            int knockDist = knockDmg;
            if ((dmgType == DamageTypes::Explode || attack.WeaponSubtype == WS_MELEE) && !target.IsNoMove) {
                if (weaponPerk == ItemPerks::Knockback) {
                    knockDist /= 5;
                }
                else {
                    knockDist /= 10;
                }
                if (target.PerkStonewall != 0) {
                    knockDist /= 2;
                }
                knockDist--;
                if (knockDist > 10) {
                    knockDist = 10;
                }
                uint16 knockHx = attack.Hx;
                uint16 knockHy = attack.Hy;
                if (knockDist > 0) {
                    map.GetWallHexInPath(target.HexX, target.HexY, knockHx, knockHy, 180.0f, knockDist);
                    CritterState::ToKnockout(target, KNOCKOUT_ACTION_ANIM_DEFAULT(attackFront), 0, knockHx, knockHy);
                }
                else {
                    CritterState::ToKnockout(target, KNOCKOUT_ACTION_ANIM_DEFAULT(attackFront), 0, target.HexX, target.HexY);
                }
            }
            else {
                CritterState::ToKnockout(target, KNOCKOUT_ACTION_ANIM_DEFAULT(attackFront), 0, target.HexX, target.HexY);
            }
        }
        if (targetAp < currentAp / AP_DIVIDER) {
            target.CurrentAp = targetAp * AP_DIVIDER;
        }
    }

    // Damage
    else if (not target.IsKnockout()) {
        // Animate hit
        if (attack.ShowHitAnimForce) {
            target.Action(CritterAction::DamageForce, attackFront ? 0 : 1, null);
        }
        else {
            target.Action(CritterAction::Damage, attackFront ? 0 : 1, null);
        }

        // Npc hit message
        if (isCombatText && !targetIsPlayer) {
            switch (aim) {
            case HitLocations::LocationNone:
            case HitLocations::LocationUncalled:
            case HitLocations::LocationTorso:
                AiSettings::AI_TrySayCombatText(target, CombatText::HitTorso);
                break;
            case HitLocations::LocationEyes:
                AiSettings::AI_TrySayCombatText(target, CombatText::HitEyes);
                break;
            case HitLocations::LocationHead:
                AiSettings::AI_TrySayCombatText(target, CombatText::HitHead);
                break;
            case HitLocations::LocationLeftArm:
                AiSettings::AI_TrySayCombatText(target, CombatText::HitLeftArm);
                break;
            case HitLocations::LocationRightArm:
                AiSettings::AI_TrySayCombatText(target, CombatText::HitRightArm);
                break;
            case HitLocations::LocationGroin:
                AiSettings::AI_TrySayCombatText(target, CombatText::HitGroin);
                break;
            case HitLocations::LocationRightLeg:
                AiSettings::AI_TrySayCombatText(target, CombatText::HitRightLeg);
                break;
            case HitLocations::LocationLeftLeg:
                AiSettings::AI_TrySayCombatText(target, CombatText::HitLeftLeg);
                break;
            default:
                break;
            }
        }
    }

    bool isAimed = (aim != HitLocations::LocationNone) && (aim != HitLocations::LocationTorso) && (aim != HitLocations::LocationUncalled);

    uint mainMsg = MessageSpecifications::Hit;
    uint length = 3;

    if (isCritical) {
        mainMsg += 2;
        length += 2;
    }
    if (isDead) {
        mainMsg += 4;
        if (isCritical) {
            length -= 1;
        }
    }
    if (isAimed) {
        mainMsg += 1;
        length += 1;
    }

    any[] sendEff = array<any>(length);
    sendEff[0] = mainMsg;
    sendEff[1] = target.Id;
    uint now = 2;

    if (isAimed) {
        sendEff[2] = aim;
        now++;
    }

    sendEff[now] = totalDmg;
    now++;

    if (isCritical) {
        if (!isDead) {
            sendEff[now] = msgEff;
            now++;
        }

        sendEff[now] = extraMessage;
    }

    Critter[] source = {target};
    Critter[] crits = {};

    if (target.GetMap() != null) {
        crits = target.GetMap().GetCrittersSeeing(source, true, CritterFindType::Players);

        for (int i = 0, j = crits.length(); i < j; i++) {
            if (crits[i].Id != target.Id) {
                AddEff(crits[i], sendEff, results);
            }
        }
    }
    if (isCritical) {
        sendEff[now] = extraMessage + 1500; // men_player - men_npc
    }

    AddEff(target, sendEff, results);

    // poisoning and irradiating:
    if (validAttacker) {
        int poison = attacker.Toxic;
        int radiation = attacker.Radioactive;
        if (poison != 0 || radiation != 0) {
            if (Game.Random(2, 11) > target.Luck) {
                if (poison > 0) {
                    Poison::AffectPoison(target, Game.Random(poison / 3, poison));
                }
                if (radiation > 0) {
                    Radiation::AffectRadiation(target, Game.Random(radiation / 3, radiation));
                }
            }
        }
        else {
            uint attackerBt = attacker.BodyType;
            if (attackerBt == BodyTypes::Radscorpion || attackerBt == BodyTypes::Floater || attackerBt == BodyTypes::GiantWasp ||
                attackerBt == BodyTypes::Alien || attackerBt == BodyTypes::Centaur) {
                if (Game.Random(2, 11) > target.Luck) {
                    if (attackerBt == BodyTypes::Radscorpion) {
                        Poison::AffectPoison(target, Game.Random(3, 15));
                    }
                    else if (attackerBt == BodyTypes::Floater) {
                        Poison::AffectPoison(target, Game.Random(10, 40));
                    }
                    else if (attackerBt == BodyTypes::GiantWasp) {
                        Poison::AffectPoison(target, Game.Random(10, 40));
                    }
                    else if (attackerBt == BodyTypes::Alien) {
                        Radiation::AffectRadiation(target, Game.Random(10, 40));
                    }
                    else if (attackerBt == BodyTypes::Centaur) {
                        Poison::AffectPoison(target, Game.Random(10, 20));
                        Radiation::AffectRadiation(target, Game.Random(10, 20));
                    }
                }
            }
        }
    }
}

void CommenceExplosion(AttackStruct attack, Map map, uint16 tx, uint16 ty, Critter target, hstring weapPid, hstring ammoPid, bool isCritical,
                       ident intentionallyId, bool isRocket, CombatRes[] results)
{
    if (ammoPid == Content::Item::emp_rocket) {
        weapPid = ammoPid;
        attack.DmgType = DamageTypes::Emp;
        attack.DmgMin += 30; // Увеличение дамага, чтобы приблизить значения к ЕМП гранате
        attack.DmgMax += 40;
    }
    CommenceExplosion(attack, map, tx, ty, target, weapPid, isCritical, intentionallyId, isRocket, results);
}

void CommenceExplosion(AttackStruct attack, Map map, uint16 tx, uint16 ty, Critter target, hstring weapPid, bool isCritical, ident intentionallyId,
                       bool isRocket, CombatRes[] results)
{
    uint radius = isRocket ? 3 : 2;
    if (weapPid == Content::Item::molotov_cocktail) {
        map.RunEffect(Content::Item::explode_fire_big, tx, ty, 2);
    }
    else if (weapPid == Content::Item::frag_grenade || weapPid == Content::Item::holy_hand_grenade) {
        map.RunEffect(Content::Item::explode_fire_small, tx, ty, 2);
    }
    else if (weapPid == Content::Item::pulse_grenade) {
        map.RunEffect(Content::Item::explode_emp, tx, ty, 2);
    }
    else if (weapPid == Content::Item::plasma_grenade) {
        map.RunEffect(Content::Item::explode_plasma, tx, ty, 2);
    }
    else if (weapPid == Content::Item::smoke_grenade) {
        SmokeGrenade::SmokeBlast(map, tx, ty, Content::Item::smoke, (valid(attack.Attacker) ? attack.Attacker.Id : ZERO_IDENT));
    }
    else if (weapPid == Content::Item::mustard_gas_grenade) {
        SmokeGrenade::SmokeBlast(map, tx, ty, Content::Item::mustard_gas, (valid(attack.Attacker) ? attack.Attacker.Id : ZERO_IDENT));
    }
    else if (weapPid == Content::Item::emp_rocket) {
        map.RunEffect(Content::Item::explode_emp, tx, ty, 1);
    }
    else if (isRocket) {
        map.RunEffect(Content::Item::explode_rocket, tx, ty, 1);
    }
    else {
        map.RunEffect(Content::Item::explode_fire_big, tx, ty, 2); // default case
    }

    if (weapPid == Content::Item::mustard_gas_grenade || weapPid == Content::Item::smoke_grenade) {
        return;
    }

    Effects::QuakeScreen(map);
    Critter[] critsHit = map.GetCritters(tx, ty, radius, CritterFindType::Alive);
    bool validTarget = valid(target);
    ident targetId = validTarget ? target.Id : ZERO_IDENT;
    bool intentionally = (valid(attack.Attacker) && attack.Attacker.IsControlledByPlayer || targetId == intentionallyId);

    if (validTarget) {
        ApplyDamage(attack, target, 1, isCritical, intentionally, results);
    }

    attack.Hx = tx;
    attack.Hy = ty;

    for (uint i = 0; i < critsHit.length(); i++) {
        if (!validTarget || targetId != critsHit[i].Id) {
            ApplyDamage(attack, critsHit[i], 1, false, intentionally, results);
        }
    }
}

void CriticalFailure(Critter cr, AbstractItem weap, uint8 weaponUse, ProtoItem ammo, uint eff, CombatRes[] results)
{
    // 0x00000100 hit self OK
    // 0x00100000 weapon exploded OK

    // 0x00000200 lost rest of ammo OK
    // 0x00000400 fired dud shot OK?
    // 0x00000800 hurt self OK
    // 0x00001000 hit randomly ~OK, TODO
    // 0x00002000 crippled random limb OK
    // 0x00040000 on fire NOT USED NOW, TODO?

    // 0x00200000 weapon destroyed OK
    // 0x00400000 weapon dropped OK
    // 0x00800000 lost next turn OK
    // 0x02000000 knocked down OK

    Item weapon = cast<Item>(weap);
    int totalDmg = 0;
    bool tookDamage = false;
    Item realWeapon = _CritGetItemHand(cr);
    bool wpnIsRemoved = _WeaponRemove(weapon, weaponUse);
    Map map = cr.GetMap();

    if (cr.IsNoDrop) {
        UNSETFLAG(eff, MF_WEAPON_DROPPED);
    }

    if (FLAG(eff, MF_HIT_SELF) || FLAG(eff, MF_WEAPON_EXPLODED)) // only one bullet because burst weapons do not have the ability
    {
        bool validAmmo = valid(ammo);
        DamageTypes dmgType = _WeaponDmgType(weapon, weaponUse);
        int targetDR = cr.DamageResistance[dmgType];
        int targetDT = cr.DamageThreshold[dmgType];

        if (weapon.Weapon_Perk == ItemPerks::Penetrate) {
            targetDT /= 5;
        }

        targetDR += (cr.IsTraitFinesse ? 30 : 0);
        targetDR += validAmmo ? ammo.Ammo_DrMod : 0;
        targetDR = CLAMP(targetDR, 0, 100);
        int dmgMin = _WeaponDmgMin(weapon, weaponUse);
        int dmgMax = _WeaponDmgMax(weapon, weaponUse);
        int dmgMul = validAmmo ? ammo.Ammo_DmgMult : 1; // technically, should be *2
        int dmgDiv = validAmmo ? ammo.Ammo_DmgDiv : 1;  // technically, should be *2
        totalDmg = Game.Random(dmgMin, dmgMax) + 2 * cr.PerkBonusRangedDamage;
        totalDmg *= dmgMul;
        totalDmg /= dmgDiv;
        totalDmg -= targetDT;
        totalDmg -= (totalDmg * targetDR) / 100;
        if (totalDmg < 0) {
            totalDmg = 0;
        }
        uint bt = cr.BodyType;
        if (cr.PerkLivingAnatomy != 0 && !(bt == BodyTypes::Alien || bt == BodyTypes::Robot)) {
            totalDmg += 5;
        }
        if (cr.PerkPyromaniac != 0 && dmgType == DamageTypes::Fire) {
            totalDmg += 5;
        }
        tookDamage = true;
    }

    uint16 ammoRound = _WeaponRound(weapon, weaponUse);
    if (ammoRound > 0 && valid(realWeapon) && !cr.IsUnlimitedAmmo) {
        if (realWeapon.AmmoCount <= ammoRound || FLAG(eff, MF_LOST_REST_OF_AMMO)) {
            realWeapon.AmmoCount = 0;
        }
        else {
            realWeapon.AmmoCount -= ammoRound;
        }
    }

    if (cr.IsNoDrop) {
        UNSETFLAG(eff, MF_WEAPON_DROPPED);
    }

    if (FLAG(eff, MF_WEAPON_DROPPED) && valid(realWeapon)) {
        if (realWeapon.Stackable) {
            Item dropped = map.AddItem(cr.HexX, cr.HexY, weapon.ProtoId, 1);
            if (realWeapon.Count > 1) {
                realWeapon.Count = realWeapon.Count - 1;
            }
            else {
                Game.DestroyItem(realWeapon);
            }

            if (!cr.IsControlledByPlayer) {
                NpcPlanes::NpcPlane plane = NpcPlanes::CreatePlane();
                NpcPlanes::NpcPlane[] crPlanes = {};

                if (NpcPlanes::GetPlanes(cr, crPlanes) > 0) {
                    plane.Priority = crPlanes[0].Priority + 1;
                }
                else {
                    plane.Priority = 70;
                }

                plane.Type = AI_PLANE_PICK;
                plane.Pick_HexX = dropped.HexX;
                plane.Pick_HexY = dropped.HexY;
                plane.Pick_Pid = dropped.ProtoId;
                plane.Pick_UseItemId = ZERO_IDENT;
                plane.Pick_ToOpen = false;
                plane.Run = true;
                NpcPlanes::AddPlane(cr, plane);
            }
        }
        else {
            ItemMovement::MoveItem(realWeapon, 0, map, cr.HexX, cr.HexY);
            if (!cr.IsControlledByPlayer) {
                NpcPlanes::NpcPlane plane = NpcPlanes::CreatePlane();

                NpcPlanes::NpcPlane[] crPlanes = {};

                if (NpcPlanes::GetPlanes(cr, crPlanes) > 0) {
                    plane.Priority = crPlanes[0].Priority + 1;
                }
                else {
                    plane.Priority = 70;
                }

                plane.Type = AI_PLANE_PICK;
                plane.Pick_HexX = realWeapon.HexX;
                plane.Pick_HexY = realWeapon.HexY;
                plane.Pick_Pid = realWeapon.ProtoId;
                plane.Pick_UseItemId = ZERO_IDENT;
                plane.Pick_ToOpen = false;
                plane.Run = true;
                NpcPlanes::AddPlane(cr, plane);
            }
        }
    }

    if ((FLAG(eff, MF_WEAPON_DESTROYED) || FLAG(eff, MF_WEAPON_EXPLODED)) && valid(realWeapon)) {
        if (realWeapon.Stackable) {
            if (realWeapon.Count > 1) {
                realWeapon.Count = realWeapon.Count - 1;
            }
            else {
                Game.DestroyItem(realWeapon);
            }
        }
        else {
            Game.DestroyItem(realWeapon);
        }
    }

    if (FLAG(eff, MF_HURT_SELF)) {
        totalDmg += Game.Random(1, 5);
        tookDamage = true;
    }

    if (FLAG(eff, MF_LOST_NEXT_TURN)) {
        cr.CurrentAp = cr.ActionPoints * -AP_DIVIDER;
    }

    if (FLAG(eff, MF_KNOCKED_DOWN) && !cr.IsKnockout()) {
        CritterState::ToKnockout(cr, KNOCKOUT_ACTION_ANIM_DEFAULT(true), cr.PerkQuickRecovery != 0 ? 1 : 3, cr.HexX, cr.HexY);
    }

    if (FLAG(eff, MF_CRIPPLED_RANDOM_LIMB) && !cr.IsNoLooseLimbs) {
        switch (Game.Random(1, 4)) {
        case 1:
            cr.IsDamagedLeftLeg = true;
            break;
        case 2:
            cr.IsDamagedRightLeg = true;
            break;
        case 3:
            cr.IsDamagedLeftArm = true;
            break;
        case 4:
            cr.IsDamagedRightArm = true;
            break;
        default:
            break;
        }
    }

    if (FLAG(eff, MF_WEAPON_EXPLODED)) {
        map.RunEffect(Content::Item::explode_fire_small, cr.HexX, cr.HexY, 2);
    }

    if (totalDmg > 0) {
        cr.CurrentHp -= totalDmg;
    }

    any[] allEff = {MessageSpecifications::CritMiss, cr.Id, eff};

    if (tookDamage) {
        allEff.resize(4);
        allEff[3] = totalDmg;
        allEff[0] = MessageSpecifications::CritMissDamage;
    }

    if (cr.CurrentHp < 1) {
        if (cr.CurrentHp > Settings.DeadHitPoints && !cr.IsNoKnock) {
            if (!cr.IsKnockout()) {
                CritterState::ToKnockout(cr, KNOCKOUT_ACTION_ANIM_DEFAULT(true), 0, cr.HexX, cr.HexY);
            }
        }
        else {
            CritterActionAnim actionAnimDead = CritterActionAnim::DeadFront;

            if (cr.IsKnockout()) {
                if (cr.KnockoutActionAnim == CritterActionAnim::IdleProneFront) {
                    actionAnimDead = CritterActionAnim::DeadProneFront;
                }
                else {
                    actionAnimDead = CritterActionAnim::DeadProneBack;
                }
            }

            CritterState::ToDead(cr, actionAnimDead, null);
            allEff[2] = int(allEff[2]) | MF_WAS_KILLED;
        }
    }

    Critter[] him = {cr};
    Critter[] crits = {};
    crits = cr.GetMap().GetCrittersSeeing(him, true, CritterFindType::Players);
    for (int i = 0, j = crits.length(); i < j; i++) {
        AddEff(crits[i], allEff, results);
    }

    FlushResults(results);

    return;
}

void InjureCritter(Critter cr, uint dmg, DamageTypes dmgType, uint8 dir, ident attackerId)
{
    Critter attacker = null;
    if (attackerId != ZERO_IDENT && cr.Id != attackerId) {
        attacker = Game.GetCritter(attackerId);
    }

    AttackStruct attack;
    attack.Attacker = attacker;

    uint16 hx = cr.HexX;
    uint16 hy = cr.HexY;
    Map map = cr.GetMap();
    if (valid(map)) {
        map.MoveHexByDir(hx, hy, (dir + 3) % 6, 1);
    }

    attack.Hx = hx;
    attack.Hy = hy;
    attack.Aim = HitLocations::LocationUncalled;
    attack.IsBurst = false;
    attack.BloodyMess = false;
    attack.CombatMessage = false;
    attack.WeaponPerk = ItemPerks::ItemPerkNone;
    attack.WeaponSubtype = 0;
    attack.DmgMin = dmg;
    attack.DmgMax = dmg;
    attack.DmgType = dmgType;
    attack.BonusDmg = 0;
    attack.DmgMul = 2;
    attack.DRMod = 0;
    attack.DMMod = 1;
    attack.DDMod = 1;
    attack.TargetId = cr.Id;
    attack.ShowHitAnimForce = true;

    CombatRes[] results = {};
    ApplyDamage(attack, cr, 1, false, true, results);

    FlushResults(results);
}

void InjureCritter(Critter cr, uint dmg, DamageTypes dmgType, uint8 dir, ident attackerId, uint forceFlags)
{
    if (dmgType > DamageTypes::Explode) {
        Game.Log("Invalid damage type.");
        return;
    }

    Critter attacker = null;
    if (attackerId != ZERO_IDENT && cr.Id != attackerId) {
        attacker = Game.GetCritter(attackerId);
    }

    AttackStruct attack;
    attack.Attacker = attacker;

    uint16 hx = cr.HexX;
    uint16 hy = cr.HexY;
    Map map = cr.GetMap();
    if (valid(map)) {
        map.MoveHexByDir(hx, hy, (dir + 3) % 6, 1);
    }

    attack.Hx = hx;
    attack.Hy = hy;
    attack.Aim = HitLocations::LocationUncalled;
    attack.IsBurst = false;
    attack.BloodyMess = false;
    attack.CombatMessage = false;
    attack.WeaponPerk = ItemPerks::ItemPerkNone;
    attack.WeaponSubtype = 0;
    attack.DmgMin = dmg;
    attack.DmgMax = dmg;
    attack.DmgType = dmgType;
    attack.BonusDmg = 0;
    attack.DmgMul = 2;
    attack.DRMod = 0;
    attack.DMMod = 1;
    attack.DDMod = 1;
    attack.TargetId = cr.Id;
    attack.ForceFlags = forceFlags;
    attack.ShowHitAnimForce = true;

    CombatRes[] results = {};
    ApplyDamage(attack, cr, 1, false, true, results);

    FlushResults(results);
}

int FindCritterInArray(Critter[] crits, Critter cr)
{
    for (uint i = 0, j = crits.length(); i < j; i++) {
        if (crits[i].Id == cr.Id) {
            return i;
        }
    }
    return -1;
}

uint GetAimApCost(int hitLocation)
{
    switch (hitLocation) {
    case HitLocations::LocationNone:
        break;
    case HitLocations::LocationUncalled:
        break;
    case HitLocations::LocationTorso:
        return Settings.ApCostAimTorso;
    case HitLocations::LocationEyes:
        return Settings.ApCostAimEyes;
    case HitLocations::LocationHead:
        return Settings.ApCostAimHead;
    case HitLocations::LocationLeftArm:
    case HitLocations::LocationRightArm:
        return Settings.ApCostAimArms;
    case HitLocations::LocationGroin:
        return Settings.ApCostAimGroin;
    case HitLocations::LocationRightLeg:
    case HitLocations::LocationLeftLeg:
        return Settings.ApCostAimLegs;
    default:
        break;
    }
    return 0;
}

uint GetHitAim(int hitLocation)
{
    switch (hitLocation) {
    case HitLocations::LocationNone:
        break;
    case HitLocations::LocationUncalled:
        break;
    case HitLocations::LocationTorso:
        return Settings.HitAimTorso;
    case HitLocations::LocationEyes:
        return Settings.HitAimEyes;
    case HitLocations::LocationHead:
        return Settings.HitAimHead;
    case HitLocations::LocationLeftArm:
    case HitLocations::LocationRightArm:
        return Settings.HitAimArms;
    case HitLocations::LocationGroin:
        return Settings.HitAimGroin;
    case HitLocations::LocationRightLeg:
    case HitLocations::LocationLeftLeg:
        return Settings.HitAimLegs;
    default:
        break;
    }
    return 0;
}

// client only, possible use by AI
int RawToHit(Critter cr, Critter target, Item weapon, uint8 weaponUse, ProtoItem ammo)
{
    CritterProperty skill = valid(weapon) ? _WeaponSkill(weapon, weaponUse) : CritterProperty::SkillUnarmed;
    int toHit = cr.GetAsInt(skill);
    ItemPerks weaponPerk = valid(weapon) ? weapon.Weapon_Perk : ItemPerks::ItemPerkNone;
    uint blockers = 0;
    int dist = Game.GetDistance(cr.HexX, cr.HexY, target.HexX, target.HexY);
    if (skill != CritterProperty::SkillUnarmed && skill != CritterProperty::SkillMeleeWeapons) {
        // ranged attack modifiers
        int distmod1 = 2; // used for initial weapon bonus
        int distmod2 = 0; // minimal distance
        if (weaponPerk == ItemPerks::LongRange) {
            distmod1 = 4;
        }
        else if (weaponPerk == ItemPerks::ScopeRange) {
            distmod1 = 5;
            distmod2 = 8;
        }

        int perception = cr.Perception;
        int acc = dist;

        if (dist < distmod2) {
            acc += distmod2;
        }
        else {
            if (cr.IsControlledByPlayer) {
                acc -= (perception - 2) * distmod1;
            }
            else {
                acc -= perception * distmod1;
            }
        }

        if (-2 * perception > acc) {
            acc = -2 * perception;
        }

        acc -= 2 * cr.PerkSharpshooter;

        if (acc >= 0) {
            if (cr.IsDamagedEye) {
                acc *= -12;
            }
            else {
                acc *= -4;
            }
        }
        else {
            acc *= -4;
        }

        toHit += acc;

        Map map = cr.GetMap();
        // TODO: const question
        blockers = Obsolete::GetCrittersInPath(Game.GetMap(map.Id), cr.HexX, cr.HexY, target.HexX, target.HexY, 0.0f, dist, CritterFindType::Alive, null);
        if (!target.IsKnockout()) {
            blockers--;
        }
        toHit -= 10 * blockers;
    } // end range modifiers

    if (valid(weapon)) {
        if (!weapon.Weapon_IsUnarmed && cr.IsTraitOneHander) {
            toHit += (weapon.Weapon_IsTwoHanded ? -40 : 20);
        }

        int handlingStrength = cr.Strength;
        int reqStrength = weapon.Weapon_MinStrength;
        if (cr.PerkWeaponHandling != 0) {
            handlingStrength += 3;
        }
        if (handlingStrength < reqStrength) {
            toHit -= (reqStrength - handlingStrength) * 20;
        }

        if (weaponPerk == ItemPerks::Accurate) {
            toHit += 20;
        }
    }

    int acmod = target.ArmorClass;
    if (valid(ammo)) {
        acmod += ammo.Ammo_AcMod;
    }
    if (acmod > 0) {
        toHit -= acmod;
    }

    if (cr.IsDamagedEye) {
        toHit -= 25;
    }

    if (target.IsKnockout()) {
        toHit += 40;
    }
    if (target.Multihex > 0) {
        toHit += 15;
    }
    if (skill != CritterProperty::SkillUnarmed && skill != CritterProperty::SkillMeleeWeapons) {
        toHit -= SmokeGrenade::GetSmokePenalty(cr.GetMap(), cr, target);
    }

    return toHit;
}

void NotifyOops(Critter cr, Critter t1, Critter t2, CombatRes[] results)
{
    // if (t2==null) pass "cr critically missed and hit randomly."
    // otherwise pass "oops! t2 was hit instead of t1!"
    if (t2 == null) {
        any[] allEff = {MessageSpecifications::HitRandomly, cr.Id};
        Critter[] him = {cr};
        Critter[] crits = {};
        crits = cr.GetMap().GetCrittersSeeing(him, true, CritterFindType::Players);
        for (int i = 0, j = crits.length(); i < j; i++) {
            AddEff(crits[i], allEff, results);
        }
    }
    else {
        any[] allEff = {MessageSpecifications::Oops, t1.Id, t2.Id};
        Critter[] them = {t1, t2};
        Critter[] crits = {};
        crits = t1.GetMap().GetCrittersSeeing(them, true, CritterFindType::Players);
        for (int i = 0, j = crits.length(); i < j; i++) {
            AddEff(crits[i], allEff, results);
        }
    }

    return;
}

void NotifyMiss(Critter cr, CombatRes[] results)
{
    any[] allEff = {MessageSpecifications::Miss, cr.Id};
    Critter[] him = {cr};
    Critter[] crits = {};
    crits = cr.GetMap().GetCrittersSeeing(him, true, CritterFindType::Players);
    for (int i = 0, j = crits.length(); i < j; i++) {
        AddEff(crits[i], allEff, results);
    }

    return;
}

Critter ChooseRandomTarget(Map map, Critter cr, Critter target, uint wpnMaxDist)
{
    uint16 hx = cr.HexX;
    uint16 hy = cr.HexY;
    Critter[] crits = map.GetCritters(hx, hy, wpnMaxDist, CritterFindType::Alive);
    if (crits.isEmpty()) {
        return null; // should never happen
    }

    uint start = Game.Random(0, crits.length() - 1);
    uint16 bx = 0;
    uint16 by = 0;
    uint16 pbx = 0;
    uint16 pby = 0;
    for (uint i = start; i < crits.length(); i++) {
        if (crits[i].Id == cr.Id || crits[i].Id == target.Id) {
            continue;
        }
        // wallcheck:
        Obsolete::GetCrittersInPath(map, hx, hy, crits[i].HexX, crits[i].HexY, 0.0f, 0, CritterFindType::Alive, null, pbx, pby, bx, by);
        if (bx == crits[i].HexX && by == crits[i].HexY) {
            return crits[i];
        }
    }

    for (uint i = 0; i < start; i++) {
        if (!valid(crits[i])) {
            continue;
        }
        if (crits[i].Id == cr.Id || crits[i].Id == target.Id) {
            continue;
        }
        // wallcheck:
        Obsolete::GetCrittersInPath(map, hx, hy, crits[i].HexX, crits[i].HexY, 0.0f, 0, CritterFindType::Alive, null, pbx, pby, bx, by);
        if (bx == crits[i].HexX && by == crits[i].HexY) {
            return crits[i];
        }
    }

    return null;
}

// Fallout2.exe FEF78 - 106597

const int ST = CritterProperty::Strength;
const int EN = CritterProperty::Endurance;
const int AG = CritterProperty::Agility;
const int LK = CritterProperty::Luck;

// clang-format off

const int[] CriticalTable =
{
    // 30240
    // Roll 0 - 20                                                21 - 45                                                       46 - 70                                                       71 - 90                                                       91 - 100                                                      100+
    // DamageMultiplier Effects StatCheck CheckModifier FailureEffect Message FailureMessage
    // DM  Effects     Stat  Check FailEffects Mess  FailMess
// Men
/* Head */ 4, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000800,   EN,    0, 0x00000001, 5002, 5003,            5, 0x00000800,   EN,   -3, 0x00000001, 5002, 5003,            5, 0x00000802,   EN,   -3, 0x00000001, 5004, 5003,            6, 0x00000801,   LK,    0, 0x00000040, 5005, 5006,            6, 0x00000080,   -1,    0, 0x00000000, 5007, 5000,
    /* LArm */ 3, 0x00000000,   -1,    0, 0x00000000, 5008, 5000,            3, 0x00008000,   -1,    0, 0x00000000, 5009, 5000,            4, 0x00000000,   EN,   -3, 0x00000010, 5010, 5011,            4, 0x00000810,   -1,    0, 0x00000000, 5012, 5000,            4, 0x00000810,   -1,    0, 0x00000000, 5012, 5000,            4, 0x00000810,   -1,    0, 0x00000000, 5013, 5000,
    /* RArm */ 3, 0x00000000,   -1,    0, 0x00000000, 5008, 5000,            3, 0x00008000,   -1,    0, 0x00000000, 5009, 5000,            4, 0x00000000,   EN,   -3, 0x00000020, 5014, 5000,            4, 0x00000820,   -1,    0, 0x00000000, 5015, 5000,            4, 0x00000820,   -1,    0, 0x00000000, 5015, 5000,            4, 0x00000820,   -1,    0, 0x00000000, 5013, 5000,
    /* Torso */ 3, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 5017, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 5019, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 5019, 5000,            6, 0x00000801,   -1,    0, 0x00000000, 5020, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5021, 5000,
    /* RLeg */ 3, 0x00000002,   -1,    0, 0x00000000, 5023, 5000,            3, 0x00000002,   EN,    0, 0x00000008, 5023, 5024,            4, 0x00000002,   EN,   -3, 0x00000008, 5023, 5024,            4, 0x0000080A,   -1,    0, 0x00000000, 5025, 5000,            4, 0x0000080A,   EN,    0, 0x00000001, 5025, 5026,            4, 0x00000809,   -1,    0, 0x00000000, 5026, 5000,
    /* LLeg */ 3, 0x00000002,   -1,    0, 0x00000000, 5023, 5000,            3, 0x00000002,   EN,    0, 0x00000004, 5023, 5024,            4, 0x00000002,   EN,   -3, 0x00000004, 5023, 5024,            4, 0x00000806,   -1,    0, 0x00000000, 5025, 5000,            4, 0x00000806,   EN,    0, 0x00000001, 5025, 5026,            4, 0x00000805,   -1,    0, 0x00000000, 5026, 5000,
    /* Eyes */ 4, 0x00000000,   LK,    4, 0x00000040, 5027, 5028,            4, 0x00000800,   LK,    3, 0x00000040, 5029, 5028,            6, 0x00000800,   LK,    2, 0x00000040, 5029, 5028,            6, 0x00008840,   -1,    0, 0x00000000, 5030, 5000,            8, 0x00000841,   -1,    0, 0x00000000, 5031, 5000,            8, 0x00000080,   -1,    0, 0x00000000, 5032, 5000,
    /* Groin */ 3, 0x00000000,   -1,    0, 0x00000000, 5033, 5000,            3, 0x00000800,   EN,   -3, 0x00000002, 5034, 5035,            3, 0x00000002,   EN,   -3, 0x00000001, 5035, 5036,            3, 0x00000001,   -1,    0, 0x00000000, 5036, 5000,            4, 0x00000802,   EN,    0, 0x00000001, 5035, 5036,            4, 0x00000801,   -1,    0, 0x00000000, 5037, 5000,
    /* Uncalled */ 3, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 5017, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 5018, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 5019, 5000,            6, 0x00000801,   -1,    0, 0x00000000, 5020, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5021, 5000,
// Women
    4, 0x00000000,   -1,    0, 0x00000000, 5101, 5100,            4, 0x00000800,   EN,    0, 0x00000001, 5102, 5103,            6, 0x00000800,   EN,   -3, 0x00000001, 5102, 5103,            6, 0x00000802,   EN,   -3, 0x00000001, 5104, 5103,            6, 0x00000801,   LK,    0, 0x00000040, 5105, 5106,            6, 0x00000080,   -1,    0, 0x00000000, 5107, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5108, 5100,            3, 0x00008000,   -1,    0, 0x00000000, 5109, 5100,            4, 0x00000000,   EN,   -2, 0x00000010, 5110, 5111,            4, 0x00000000,   EN,   -4, 0x00000010, 5110, 5111,            4, 0x00000810,   -1,    0, 0x00000000, 5112, 5100,            4, 0x00000810,   -1,    0, 0x00000000, 5113, 5100,
    3, 0x00000000,   -1,    0, 0x00000000, 5108, 5100,            3, 0x00008000,   -1,    0, 0x00000000, 5109, 5100,            4, 0x00000000,   EN,   -2, 0x00000020, 5114, 5100,            4, 0x00000000,   EN,   -4, 0x00000020, 5114, 5100,            4, 0x00000820,   -1,    0, 0x00000000, 5115, 5100,            4, 0x00000820,   -1,    0, 0x00000000, 5113, 5100,
    3, 0x00000000,   -1,    0, 0x00000000, 5116, 5100,            3, 0x00000800,   -1,    0, 0x00000000, 5117, 5100,            4, 0x00000802,   -1,    0, 0x00000000, 5119, 5100,            4, 0x00000802,   -1,    0, 0x00000000, 5119, 5100,            6, 0x00000801,   -1,    0, 0x00000000, 5120, 5100,            6, 0x00000080,   -1,    0, 0x00000000, 5121, 5100,
    3, 0x00000002,   -1,    0, 0x00000000, 5123, 5100,            4, 0x00000002,   EN,    0, 0x00000008, 5123, 5124,            4, 0x00000002,   EN,   -3, 0x00000008, 5123, 5124,            4, 0x0000080A,   -1,    0, 0x00000000, 5125, 5100,            4, 0x0000080A,   EN,    0, 0x00000001, 5125, 5126,            4, 0x00000809,   -1,    0, 0x00000000, 5126, 5100,
    3, 0x00000002,   -1,    0, 0x00000000, 5123, 5100,            4, 0x00000002,   EN,    0, 0x00000004, 5123, 5124,            4, 0x00000002,   EN,   -3, 0x00000004, 5123, 5124,            4, 0x00000806,   -1,    0, 0x00000000, 5125, 5100,            4, 0x00000806,   EN,    0, 0x00000001, 5125, 5126,            4, 0x00000805,   -1,    0, 0x00000000, 5126, 5100,
    4, 0x00000000,   LK,    4, 0x00000040, 5127, 5128,            4, 0x00000800,   LK,    3, 0x00000040, 5129, 5128,            6, 0x00000800,   LK,    2, 0x00000040, 5129, 5128,            6, 0x00008840,   -1,    0, 0x00000000, 5130, 5100,            8, 0x00000841,   -1,    0, 0x00000000, 5131, 5100,            8, 0x00000080,   -1,    0, 0x00000000, 5132, 5100,
    3, 0x00000000,   -1,    0, 0x00000000, 5133, 5100,            3, 0x00000000,   EN,    0, 0x00000002, 5133, 5134,            3, 0x00000002,   EN,    0, 0x00000001, 5134, 5135,            3, 0x00000001,   -1,    0, 0x00000000, 5135, 5100,            4, 0x00000802,   EN,    0, 0x00000001, 5134, 5135,            4, 0x00000801,   -1,    0, 0x00000000, 5135, 5100,
    3, 0x00000000,   -1,    0, 0x00000000, 5116, 5100,            3, 0x00000800,   -1,    0, 0x00000000, 5117, 5100,            4, 0x00000802,   -1,    0, 0x00000000, 5119, 5100,            4, 0x00000802,   -1,    0, 0x00000000, 5119, 5100,            6, 0x00000801,   -1,    0, 0x00000000, 5120, 5100,            6, 0x00000080,   -1,    0, 0x00000000, 5121, 5100,
// Children
    4, 0x00000000,   EN,    0, 0x00000001, 5200, 5201,            4, 0x00000800,   EN,   -2, 0x00000001, 5202, 5203,            4, 0x00000800,   EN,   -2, 0x00000001, 5202, 5203,            6, 0x00000801,   -1,    0, 0x00000000, 5203, 5000,            6, 0x00000801,   -1,    0, 0x00000000, 5203, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5204, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5205, 5000,            4, 0x00008000,   EN,    0, 0x00000010, 5206, 5207,            4, 0x00008000,   EN,   -2, 0x00000010, 5206, 5207,            4, 0x00000810,   -1,    0, 0x00000000, 5208, 5000,            4, 0x00000810,   -1,    0, 0x00000000, 5208, 5000,            4, 0x00000810,   -1,    0, 0x00000000, 5208, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5209, 5000,            4, 0x00008000,   EN,    0, 0x00000020, 5206, 5207,            4, 0x00008000,   EN,   -2, 0x00000020, 5206, 5207,            4, 0x00000820,   -1,    0, 0x00000000, 5208, 5000,            4, 0x00000820,   -1,    0, 0x00000000, 5208, 5000,            4, 0x00000820,   -1,    0, 0x00000000, 5208, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5210, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 5211, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 5212, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 5212, 5000,            4, 0x00000801,   -1,    0, 0x00000000, 5213, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5214, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5215, 5000,            3, 0x0000000A,   -1,    0, 0x00000000, 5216, 5000,            3, 0x0000000A,   -1,    0, 0x00000000, 5216, 5000,            4, 0x0000080A,   -1,    0, 0x00000000, 5217, 5000,            4, 0x0000080A,   -1,    0, 0x00000000, 5217, 5000,            4, 0x0000080A,   -1,    0, 0x00000000, 5217, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5215, 5000,            3, 0x00000006,   -1,    0, 0x00000000, 5216, 5000,            3, 0x00000006,   -1,    0, 0x00000000, 5216, 5000,            4, 0x00000806,   -1,    0, 0x00000000, 5217, 5000,            4, 0x00000806,   -1,    0, 0x00000000, 5217, 5000,            4, 0x00000806,   -1,    0, 0x00000000, 5217, 5000,
    4, 0x00000000,   LK,    5, 0x00000040, 5218, 5219,            4, 0x00000800,   LK,    2, 0x00000040, 5220, 5221,            6, 0x00000800,   LK,   -1, 0x00000040, 5220, 5221,            6, 0x00008840,   -1,    0, 0x00000000, 5222, 5000,            8, 0x00000841,   -1,    0, 0x00000000, 5223, 5000,            8, 0x00000080,   -1,    0, 0x00000000, 5224, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5225, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5225, 5000,            3, 0x00000002,   -1,    0, 0x00000000, 5226, 5000,            3, 0x00000002,   -1,    0, 0x00000000, 5226, 5000,            3, 0x00000002,   -1,    0, 0x00000000, 5226, 5000,            4, 0x00000002,   -1,    0, 0x00000000, 5226, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5210, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 5211, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 5211, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 5212, 5000,            4, 0x00000801,   -1,    0, 0x00000000, 5213, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5214, 5000,
// Super mutant
    4, 0x00000000,   -1,    0, 0x00000000, 5300, 5000,            4, 0x00000800,   EN,   -1, 0x00000002, 5301, 5302,            5, 0x00000800,   EN,   -4, 0x00000002, 5301, 5302,            5, 0x00000802,   EN,   -3, 0x00000001, 5302, 5303,            6, 0x00000802,   EN,    0, 0x00000001, 5302, 5303,            6, 0x00000080,   -1,    0, 0x00000000, 5304, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5300, 5000,            3, 0x00000000,   AG,    0, 0x00008000, 5300, 5306,            4, 0x00008800,   EN,   -1, 0x00000010, 5307, 5308,            4, 0x00008800,   EN,   -3, 0x00000010, 5307, 5308,            4, 0x00000810,   -1,    0, 0x00000000, 5308, 5000,            4, 0x00000810,   -1,    0, 0x00000000, 5308, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5300, 5000,            3, 0x00000000,   AG,    0, 0x00008000, 5300, 5306,            4, 0x00008800,   EN,   -1, 0x00000020, 5307, 5309,            4, 0x00008800,   EN,   -3, 0x00000020, 5307, 5309,            4, 0x00000820,   -1,    0, 0x00000000, 5309, 5000,            4, 0x00000820,   -1,    0, 0x00000000, 5309, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5300, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 5301, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 5302, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 5302, 5000,            4, 0x00000801,   -1,    0, 0x00000000, 5310, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5311, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5300, 5000,            3, 0x00000000,   AG,    0, 0x00000002, 5300, 5312,            4, 0x00000002,   EN,   -3, 0x00000008, 5312, 5313,            4, 0x0000000A,   -1,    0, 0x00000000, 5313, 5000,            4, 0x0000080A,   -1,    0, 0x00000000, 5314, 5000,            4, 0x00000809,   -1,    0, 0x00000000, 5315, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5300, 5000,            3, 0x00000000,   AG,    0, 0x00000002, 5300, 5312,            4, 0x00000002,   EN,   -3, 0x00000004, 5312, 5313,            4, 0x00000006,   -1,    0, 0x00000000, 5313, 5000,            4, 0x00000806,   -1,    0, 0x00000000, 5314, 5000,            4, 0x00000805,   -1,    0, 0x00000000, 5315, 5000,
    4, 0x00000000,   -1,    0, 0x00000000, 5300, 5000,            4, 0x00000800,   LK,    5, 0x00000040, 5316, 5317,            6, 0x00000800,   LK,    3, 0x00000040, 5316, 5317,            6, 0x00008800,   LK,    0, 0x00000040, 5318, 5319,            8, 0x00000841,   -1,    0, 0x00000000, 5320, 5000,            8, 0x00000080,   -1,    0, 0x00000000, 5321, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5300, 5000,            3, 0x00000000,   LK,    0, 0x00000800, 5300, 5017,            3, 0x00000800,   EN,   -2, 0x00000002, 5301, 5302,            3, 0x00000002,   -1,    0, 0x00000000, 5312, 5000,            4, 0x00000802,   EN,    0, 0x00000001, 5302, 5303,            4, 0x00000801,   -1,    0, 0x00000000, 5303, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5300, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 5301, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 5302, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 5302, 5000,            4, 0x00000801,   -1,    0, 0x00000000, 5310, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5311, 5000,
// Ghoul
    4, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000800,   EN,    0, 0x00000001, 5400, 5003,            5, 0x00000800,   EN,   -1, 0x00000001, 5400, 5003,            5, 0x00000802,   EN,   -2, 0x00000001, 5004, 5005,            6, 0x00000801,   ST,    0, 0x00000000, 5005, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5401, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            3, 0x00000000,   AG,    0, 0x0000C000, 5001, 5402,            4, 0x0000C000,   EN,    0, 0x00000010, 5402, 5012,            4, 0x0000C800,   EN,    0, 0x00000010, 5403, 5404,            4, 0x00004810,   -1,    0, 0x00000000, 5404, 5000,            4, 0x00004810,   -1,    0, 0x00000000, 5404, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            3, 0x00000000,   AG,    0, 0x0000C000, 5001, 5402,            4, 0x0000C000,   EN,    0, 0x00000020, 5402, 5015,            4, 0x0000C800,   EN,    0, 0x00000020, 5403, 5404,            4, 0x00004820,   -1,    0, 0x00000000, 5404, 5000,            4, 0x00004820,   -1,    0, 0x00000000, 5404, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 5017, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5018, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 5004, 5000,            4, 0x00000801,   -1,    0, 0x00000000, 5003, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5007, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   AG,    0, 0x00000002, 5001, 5023,            4, 0x00000002,   EN,    0, 0x00000008, 5023, 5024,            4, 0x0000000A,   -1,    0, 0x00000000, 5024, 5000,            4, 0x0000080A,   EN,    0, 0x00000001, 5024, 5026,            4, 0x00000809,   -1,    0, 0x00000000, 5026, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   AG,    0, 0x00000002, 5001, 5023,            4, 0x00000002,   EN,    0, 0x00000004, 5023, 5024,            4, 0x00000006,   -1,    0, 0x00000000, 5024, 5000,            4, 0x00000806,   EN,    0, 0x00000001, 5024, 5026,            4, 0x00000805,   -1,    0, 0x00000000, 5026, 5000,
    4, 0x00000000,   LK,    3, 0x00000040, 5001, 5405,            4, 0x00000800,   LK,    0, 0x00000040, 5406, 5407,            6, 0x00000800,   LK,   -3, 0x00000040, 5406, 5407,            6, 0x00008840,   -1,    0, 0x00000000, 5030, 5000,            8, 0x00000841,   -1,    0, 0x00000000, 5031, 5000,            8, 0x00000080,   -1,    0, 0x00000000, 5408, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   LK,    0, 0x00000800, 5001, 5033,            3, 0x00000800,   EN,    0, 0x00000002, 5033, 5035,            3, 0x00000002,   -1,    0, 0x00000000, 5004, 5000,            4, 0x00000802,   EN,    0, 0x00000001, 5035, 5036,            4, 0x00000801,   -1,    0, 0x00000000, 5036, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 5017, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5018, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 5004, 5000,            4, 0x00000801,   -1,    0, 0x00000000, 5003, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5007, 5000,
// Brahmin
    4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            5, 0x00000000,   EN,    2, 0x00000002, 5016, 5500,            5, 0x00000000,   EN,   -1, 0x00000002, 5016, 5500,            6, 0x00000001,   ST,    0, 0x00000000, 5501, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5502, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   EN,    0, 0x00000004, 5016, 5503,            4, 0x00000000,   EN,    0, 0x00000004, 5016, 5503,            4, 0x00000004,   -1,    0, 0x00000000, 5503, 5000,            4, 0x00000004,   -1,    0, 0x00000000, 5503, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   EN,    0, 0x00000008, 5016, 5503,            4, 0x00000000,   EN,    0, 0x00000008, 5016, 5503,            4, 0x00000008,   -1,    0, 0x00000000, 5503, 5000,            4, 0x00000008,   -1,    0, 0x00000000, 5503, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5504, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5504, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 5504, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 5505, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 5505, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5506, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   EN,    0, 0x00000008, 5016, 5503,            4, 0x00000000,   EN,    0, 0x00000008, 5016, 5503,            4, 0x00000008,   -1,    0, 0x00000000, 5503, 5000,            4, 0x00000008,   -1,    0, 0x00000000, 5503, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   EN,    0, 0x00000004, 5016, 5503,            4, 0x00000000,   EN,    0, 0x00000004, 5016, 5503,            4, 0x00000004,   -1,    0, 0x00000000, 5503, 5000,            4, 0x00000004,   -1,    0, 0x00000000, 5503, 5000,
    4, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000800,   LK,    0, 0x00000040, 5029, 5507,            6, 0x00000800,   LK,   -3, 0x00000040, 5029, 5507,            6, 0x00008840,   -1,    0, 0x00000000, 5508, 5000,            8, 0x00000841,   -1,    0, 0x00000000, 5509, 5000,            8, 0x00000080,   -1,    0, 0x00000000, 5510, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 5511, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 5511, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 5512, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 5512, 5000,            6, 0x00000800,   -1,    0, 0x00000000, 5513, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5504, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5504, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 5504, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 5505, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 5505, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5506, 5000,
// Radscorpion
    4, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   EN,    3, 0x00000002, 5001, 5600,            5, 0x00000000,   EN,    0, 0x00000002, 5001, 5600,            5, 0x00000000,   EN,   -3, 0x00000002, 5001, 5600,            6, 0x00000002,   -1,    0, 0x00000000, 5600, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5601, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            4, 0x00000000,   EN,    0, 0x00000010, 5016, 5602,            4, 0x00000010,   -1,    0, 0x00000000, 5602, 5000,            4, 0x00000010,   -1,    0, 0x00000000, 5602, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            4, 0x00000000,   EN,    2, 0x00000020, 5016, 5603,            4, 0x00000000,   EN,    0, 0x00000020, 5016, 5603,            4, 0x00000020,   -1,    0, 0x00000000, 5603, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 5604, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 5605, 5000,            4, 0x00000800,   AG,    0, 0x00000002, 5605, 5606,            4, 0x00000080,   -1,    0, 0x00000000, 5607, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   AG,    2, 0x00000000, 5001, 5600,            4, 0x00000002,   EN,    0, 0x00000008, 5600, 5608,            4, 0x00000808,   -1,    0, 0x00000000, 5609, 5000,            4, 0x0000080A,   -1,    0, 0x00000000, 5608, 5000,            4, 0x0000080A,   -1,    0, 0x00000000, 5608, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   AG,    2, 0x00000000, 5001, 5600,            4, 0x00000002,   EN,    0, 0x00000004, 5600, 5008,            4, 0x00000804,   -1,    0, 0x00000000, 5609, 5000,            4, 0x00000806,   -1,    0, 0x00000000, 5608, 5000,            4, 0x00000806,   -1,    0, 0x00000000, 5608, 5000,
    4, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   AG,    3, 0x00000040, 5001, 5610,            6, 0x00000000,   AG,    0, 0x00000040, 5016, 5610,            6, 0x00000000,   AG,   -3, 0x00000040, 5016, 5610,            8, 0x00000000,   AG,   -3, 0x00000040, 5611, 5612,            8, 0x00000080,   -1,    0, 0x00000000, 5613, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5614, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5614, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 5614, 5000,            4, 0x00000001,   -1,    0, 0x00000000, 5615, 5000,            4, 0x00000001,   -1,    0, 0x00000000, 5615, 5000,            4, 0x00000080,   -1,    0, 0x00000000, 5616, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 5604, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 5605, 5000,            4, 0x00000800,   AG,    0, 0x00000002, 5605, 5606,            4, 0x00000080,   -1,    0, 0x00000000, 5607, 5000,
// Rat
    4, 0x00000800,   -1,    0, 0x00000000, 5700, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 5700, 5000,            4, 0x00000080,   -1,    0, 0x00000000, 5701, 5000,            4, 0x00000080,   -1,    0, 0x00000000, 5701, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5701, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5701, 5000,
    3, 0x00000010,   -1,    0, 0x00000000, 5703, 5000,            3, 0x00000010,   -1,    0, 0x00000000, 5703, 5000,            3, 0x00000010,   -1,    0, 0x00000000, 5703, 5000,            4, 0x00000010,   -1,    0, 0x00000000, 5703, 5000,            4, 0x00000010,   -1,    0, 0x00000000, 5703, 5000,            4, 0x00000010,   -1,    0, 0x00000000, 5703, 5000,
    3, 0x00000020,   -1,    0, 0x00000000, 5705, 5000,            3, 0x00000020,   -1,    0, 0x00000000, 5705, 5000,            3, 0x00000020,   -1,    0, 0x00000000, 5705, 5000,            4, 0x00000020,   -1,    0, 0x00000000, 5705, 5000,            4, 0x00000020,   -1,    0, 0x00000000, 5705, 5000,            4, 0x00000020,   -1,    0, 0x00000000, 5705, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5706, 5000,            3, 0x00000002,   -1,    0, 0x00000000, 5707, 5000,            3, 0x00000002,   -1,    0, 0x00000000, 5707, 5000,            4, 0x00000002,   -1,    0, 0x00000000, 5707, 5000,            4, 0x00000002,   -1,    0, 0x00000000, 5707, 5000,            4, 0x00000080,   -1,    0, 0x00000000, 5708, 5000,
    3, 0x00000008,   -1,    0, 0x00000000, 5709, 5000,            3, 0x00000008,   -1,    0, 0x00000000, 5709, 5000,            3, 0x00000008,   -1,    0, 0x00000000, 5709, 5000,            4, 0x00000008,   -1,    0, 0x00000000, 5709, 5000,            4, 0x00000008,   -1,    0, 0x00000000, 5709, 5000,            4, 0x00000008,   -1,    0, 0x00000000, 5709, 5000,
    3, 0x00000004,   -1,    0, 0x00000000, 5710, 5000,            3, 0x00000004,   -1,    0, 0x00000000, 5710, 5000,            3, 0x00000004,   -1,    0, 0x00000000, 5710, 5000,            4, 0x00000004,   -1,    0, 0x00000000, 5710, 5000,            4, 0x00000004,   -1,    0, 0x00000000, 5710, 5000,            4, 0x00000004,   -1,    0, 0x00000000, 5710, 5000,
    4, 0x00000800,   -1,    0, 0x00000000, 5711, 5000,            4, 0x00000080,   -1,    0, 0x00000000, 5712, 5000,            4, 0x00000080,   -1,    0, 0x00000000, 5712, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5712, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5712, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5712, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 5711, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 5711, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5712, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 5712, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5706, 5000,            3, 0x00000002,   -1,    0, 0x00000000, 5707, 5000,            3, 0x00000002,   -1,    0, 0x00000000, 5707, 5000,            4, 0x00000002,   -1,    0, 0x00000000, 5707, 5000,            4, 0x00000002,   -1,    0, 0x00000000, 5707, 5000,            4, 0x00000080,   -1,    0, 0x00000000, 5708, 5000,
// Floater
    4, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   AG,    0, 0x00000002, 5001, 5800,            5, 0x00000000,   AG,   -3, 0x00000002, 5016, 5800,            5, 0x00000002,   EN,    0, 0x00000001, 5800, 5801,            6, 0x00000002,   EN,   -3, 0x00000001, 5800, 5801,            6, 0x00000080,   -1,    0, 0x00000000, 5802, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   EN,    0, 0x00008000, 5001, 5803,            4, 0x00000000,   EN,   -2, 0x00008000, 5001, 5803,            3, 0x00008800,   -1,    0, 0x00000000, 5804, 5000,            4, 0x00008800,   -1,    0, 0x00000000, 5804, 5000,            4, 0x00000080,   -1,    0, 0x00000000, 5805, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   EN,    0, 0x00008000, 5001, 5803,            4, 0x00000000,   EN,   -2, 0x00008000, 5001, 5803,            3, 0x00008800,   -1,    0, 0x00000000, 5804, 5000,            4, 0x00008800,   -1,    0, 0x00000000, 5804, 5000,            4, 0x00000080,   -1,    0, 0x00000000, 5805, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   AG,    0, 0x00000002, 5001, 5800,            3, 0x00000000,   AG,   -2, 0x00000002, 5001, 5800,            4, 0x00000002,   -1,    0, 0x00000000, 5800, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 5804, 5000,            4, 0x00000080,   -1,    0, 0x00000000, 5805, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   AG,    1, 0x00000002, 5001, 5800,            4, 0x00000000,   AG,   -1, 0x00000002, 5001, 5800,            4, 0x00000002,   EN,   -1, 0x0000000C, 5800, 5806,            4, 0x00000802,   EN,   -3, 0x0000000C, 5804, 5806,            6, 0x00000480,   -1,    0, 0x00000000, 5807, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00008000,   -1,    0, 0x00000000, 5803, 5000,            4, 0x00008000,   -1,    0, 0x00000000, 5803, 5000,            4, 0x00008030,   -1,    0, 0x00000000, 5808, 5000,            4, 0x00008030,   -1,    0, 0x00000000, 5808, 5000,
    4, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 5809, 5000,            5, 0x00000000,   EN,    0, 0x00000040, 5016, 5810,            5, 0x00000800,   EN,   -3, 0x00000040, 5809, 5810,            6, 0x00000840,   -1,    0, 0x00000000, 5810, 5000,            6, 0x00000842,   -1,    0, 0x00000000, 5801, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   EN,    0, 0x00000002, 5001, 5800,            3, 0x00000000,   EN,   -3, 0x00000002, 5001, 5800,            3, 0x00000802,   -1,    0, 0x00000000, 5800, 5000,            3, 0x00000802,   -1,    0, 0x00000000, 5800, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   AG,    0, 0x00000002, 5001, 5800,            3, 0x00000000,   AG,   -2, 0x00000002, 5001, 5800,            4, 0x00000002,   -1,    0, 0x00000000, 5800, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 5804, 5000,            4, 0x00000080,   -1,    0, 0x00000000, 5805, 5000,
// Centaur
    4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            4, 0x00000000,   EN,    0, 0x00008002, 5016, 5900,            5, 0x00000000,   EN,   -3, 0x00008002, 5016, 5900,            5, 0x00000800,   EN,   -3, 0x00008002, 5901, 5900,            6, 0x00000800,   EN,   -3, 0x00008002, 5901, 5900,            6, 0x00000080,   -1,    0, 0x00000000, 5902, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   EN,    0, 0x00008000, 5016, 5903,            4, 0x00000000,   EN,    0, 0x00000010, 5016, 5904,            4, 0x00000010,   -1,    0, 0x00000000, 5904, 5000,            4, 0x00000810,   -1,    0, 0x00000000, 5905, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   EN,    0, 0x00008000, 5016, 5903,            4, 0x00000000,   EN,    0, 0x00000020, 5016, 5904,            4, 0x00000020,   -1,    0, 0x00000000, 5904, 5000,            4, 0x00000820,   -1,    0, 0x00000000, 5905, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 5901, 5000,            4, 0x00000800,   EN,    2, 0x00000000, 5901, 5900,            5, 0x00000802,   -1,    0, 0x00000000, 5900, 5000,            5, 0x00000080,   -1,    0, 0x00000000, 5902, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000002,   -1,    0, 0x00000000, 5900, 5000,            4, 0x00000002,   EN,    0, 0x00000008, 5900, 5906,            4, 0x0000000A,   -1,    0, 0x00000000, 5906, 5000,            4, 0x0000000A,   -1,    0, 0x00000000, 5906, 5000,            4, 0x0000800A,   -1,    0, 0x00000000, 5907, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000002,   -1,    0, 0x00000000, 5900, 5000,            4, 0x00000002,   EN,    0, 0x00000004, 5900, 5906,            4, 0x00000006,   -1,    0, 0x00000000, 5906, 5000,            4, 0x00000006,   -1,    0, 0x00000000, 5906, 5000,            4, 0x00008006,   -1,    0, 0x00000000, 5907, 5000,
    4, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   EN,    1, 0x00000040, 5001, 5908,            6, 0x00000800,   EN,   -1, 0x00000040, 5901, 5908,            6, 0x00008840,   -1,    0, 0x00000000, 5909, 5000,            8, 0x00000841,   -1,    0, 0x00000000, 5910, 5000,            8, 0x00000080,   -1,    0, 0x00000000, 5911, 5000,
    2, 0x00000000,   -1,    0, 0x00000000, 5912, 5000,            2, 0x00000000,   -1,    0, 0x00000000, 5912, 5000,            2, 0x00000000,   -1,    0, 0x00000000, 5912, 5000,            2, 0x00000000,   -1,    0, 0x00000000, 5912, 5000,            2, 0x00000000,   -1,    0, 0x00000000, 5912, 5000,            2, 0x00000000,   -1,    0, 0x00000000, 5912, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 5901, 5000,            4, 0x00000800,   EN,    2, 0x00000000, 5901, 5900,            5, 0x00000802,   -1,    0, 0x00000000, 5900, 5000,            5, 0x00000080,   -1,    0, 0x00000000, 5902, 5000,
// Robot
    4, 0x00000000,   -1,    0, 0x00000000, 6000, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 6000, 5000,            5, 0x00000000,   -1,    0, 0x00000000, 6000, 5000,            5, 0x00000002,   -1,    0, 0x00000000, 6001, 5000,            6, 0x00000802,   -1,    0, 0x00000000, 6002, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 6003, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6000, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6000, 5000,            3, 0x00000000,   EN,    0, 0x00000010, 6000, 6004,            3, 0x00000000,   EN,   -3, 0x00000010, 6000, 6004,            4, 0x00000010,   -1,    0, 0x00000000, 6004, 5000,            4, 0x00000010,   EN,    0, 0x00000020, 6004, 6005,
    3, 0x00000000,   -1,    0, 0x00000000, 6000, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6000, 5000,            3, 0x00000000,   EN,    0, 0x00000020, 6000, 6004,            3, 0x00000000,   EN,   -3, 0x00000020, 6000, 6004,            4, 0x00000020,   -1,    0, 0x00000000, 6004, 5000,            4, 0x00000020,   EN,    0, 0x00000010, 6004, 6005,
    3, 0x00000000,   -1,    0, 0x00000000, 6000, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 6006, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 6007, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 6008, 5000,            6, 0x00000800,   -1,    0, 0x00000000, 6009, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 6010, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6000, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 6007, 5000,            3, 0x00000000,   EN,    0, 0x00000008, 6000, 6004,            4, 0x00000000,   EN,   -4, 0x00000008, 6007, 6004,            4, 0x00000008,   EN,    0, 0x00000002, 6004, 6011,            4, 0x00000008,   EN,   -3, 0x00000006, 6004, 6012,
    3, 0x00000000,   -1,    0, 0x00000000, 6000, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 6007, 5000,            3, 0x00000000,   EN,    0, 0x00000004, 6000, 6004,            4, 0x00000000,   EN,   -4, 0x00000004, 6007, 6004,            4, 0x00000004,   EN,    0, 0x00000002, 6004, 6011,            4, 0x00000004,   EN,   -3, 0x0000000A, 6004, 6012,
    3, 0x00000000,   -1,    0, 0x00000000, 6000, 5000,            3, 0x00000000,   EN,    0, 0x00000040, 6000, 6013,            3, 0x00000000,   EN,   -2, 0x00000040, 6000, 6013,            3, 0x00000000,   EN,   -4, 0x00000040, 6000, 6013,            3, 0x00000000,   EN,   -6, 0x00000040, 6000, 6013,            3, 0x00000040,   -1,    0, 0x00000000, 6013, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6000, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6000, 5000,            3, 0x00000000,   EN,   -1, 0x00008002, 6000, 6002,            3, 0x00000000,   EN,   -4, 0x00008002, 6000, 6002,            3, 0x00008002,   EN,    0, 0x00200000, 6002, 6003,            3, 0x00008002,   EN,   -4, 0x00200000, 6002, 6003,
    3, 0x00000000,   -1,    0, 0x00000000, 6000, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 6006, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 6007, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 6008, 5000,            6, 0x00000800,   -1,    0, 0x00000000, 6009, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 6010, 5000,
// Dog
    4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            4, 0x00000000,   EN,    0, 0x00000002, 5016, 6100,            4, 0x00000000,   EN,   -3, 0x00000002, 5016, 6100,            4, 0x00000000,   EN,   -6, 0x00000030, 5016, 6101,            4, 0x00000002,   EN,   -3, 0x00000001, 6100, 6102,            4, 0x00000080,   -1,    0, 0x00000000, 6103, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   EN,   -1, 0x00000004, 5001, 6104,            3, 0x00000000,   EN,   -3, 0x00000004, 5001, 6104,            3, 0x00000000,   EN,   -5, 0x00000006, 5001, 6105,            3, 0x00000004,   AG,   -1, 0x00000002, 6104, 6105,            3, 0x00000006,   -1,    0, 0x00000000, 6105, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   EN,   -1, 0x00000008, 5001, 6104,            3, 0x00000000,   EN,   -3, 0x00000008, 5001, 6104,            3, 0x00000000,   EN,   -5, 0x0000000A, 5001, 6105,            3, 0x00000008,   AG,   -1, 0x00000002, 6104, 6105,            3, 0x0000000A,   -1,    0, 0x00000000, 6105, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   AG,   -1, 0x00000002, 5001, 6100,            4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            4, 0x00000000,   AG,   -3, 0x00000002, 5016, 6100,            4, 0x00000002,   -1,    0, 0x00000000, 6100, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 6103, 5000,
    3, 0x00000000,   EN,    1, 0x00000008, 5001, 6104,            3, 0x00000000,   EN,    0, 0x00000008, 5001, 6104,            3, 0x00000000,   EN,   -2, 0x00000008, 5001, 6104,            3, 0x00000000,   EN,   -4, 0x0000000A, 5001, 6105,            3, 0x00000008,   AG,   -1, 0x00000002, 6104, 6105,            3, 0x0000000A,   -1,    0, 0x00000000, 6105, 5000,
    3, 0x00000000,   EN,    1, 0x00000004, 5001, 6104,            3, 0x00000000,   EN,    0, 0x00000004, 5001, 6104,            3, 0x00000000,   EN,   -2, 0x00000004, 5001, 6104,            3, 0x00000000,   EN,   -4, 0x00000006, 5001, 6105,            3, 0x00000004,   AG,   -1, 0x00000002, 6104, 6105,            3, 0x00000006,   -1,    0, 0x00000000, 6105, 5000,
    4, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 5018, 5000,            6, 0x00000800,   -1,    0, 0x00000000, 5018, 5000,            6, 0x00000800,   EN,    3, 0x00000040, 5018, 6106,            8, 0x00000800,   EN,    0, 0x00000040, 5018, 6106,            8, 0x00000080,   -1,    0, 0x00000000, 6107, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   AG,   -2, 0x00000002, 5001, 6100,            4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            4, 0x00000000,   AG,   -5, 0x00000002, 5016, 6100,            4, 0x00000002,   -1,    0, 0x00000000, 6100, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 6103, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   AG,   -1, 0x00000002, 5001, 6100,            4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            4, 0x00000000,   AG,   -3, 0x00000002, 5016, 6100,            4, 0x00000002,   -1,    0, 0x00000000, 6100, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 6103, 5000,
// Mantis
    4, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   EN,    0, 0x00000002, 5001, 6200,            5, 0x00000000,   EN,   -3, 0x00000002, 5016, 6200,            5, 0x00000002,   EN,   -1, 0x00000001, 6200, 6201,            6, 0x00000002,   EN,   -3, 0x00000001, 6200, 6201,            6, 0x00000080,   -1,    0, 0x00000000, 6202, 5000,
    3, 0x00000000,   EN,    0, 0x00000010, 5001, 6203,            3, 0x00000000,   EN,    0, 0x00000010, 5001, 6203,            3, 0x00000000,   EN,   -2, 0x00000010, 5001, 6203,            4, 0x00000000,   EN,   -4, 0x00000010, 5016, 6203,            4, 0x00000000,   EN,   -4, 0x00000010, 5016, 6203,            4, 0x00008010,   -1,    0, 0x00000000, 6204, 5000,
    3, 0x00000000,   EN,    0, 0x00000020, 5001, 6203,            3, 0x00000000,   EN,    0, 0x00000020, 5001, 6203,            3, 0x00000000,   EN,   -2, 0x00000020, 5001, 6203,            4, 0x00000000,   EN,   -4, 0x00000020, 5016, 6203,            4, 0x00000000,   EN,   -4, 0x00000020, 5016, 6203,            4, 0x00008020,   -1,    0, 0x00000000, 6204, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 1000, 5000,            3, 0x00000000,   EN,    0, 0x00000800, 5001, 6205,            3, 0x00000000,   EN,   -2, 0x00000800, 5001, 6205,            4, 0x00000000,   EN,   -2, 0x00000800, 5016, 6205,            4, 0x00000000,   EN,   -4, 0x00000800, 5016, 6205,            6, 0x00000080,   -1,    0, 0x00000000, 6206, 5000,
    3, 0x00000000,   AG,    0, 0x00000002, 5001, 6201,            3, 0x00000000,   AG,   -2, 0x00000002, 5001, 6201,            4, 0x00000000,   AG,   -4, 0x00000002, 5001, 6201,            3, 0x00000002,   EN,    0, 0x00000008, 6201, 6203,            4, 0x00000002,   EN,   -3, 0x00000008, 6201, 6203,            4, 0x0000000A,   -1,    0, 0x00000000, 6207, 5000,
    3, 0x00000000,   AG,    0, 0x00000002, 5001, 6201,            3, 0x00000000,   AG,   -3, 0x00000002, 5001, 6201,            3, 0x00000002,   EN,   -2, 0x00000004, 6201, 6208,            3, 0x00000002,   EN,   -2, 0x00000004, 6201, 6208,            3, 0x00000002,   EN,   -5, 0x00000004, 6201, 6208,            3, 0x00000006,   -1,    0, 0x00000000, 6208, 5000,
    4, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000800,   EN,    0, 0x00008000, 6205, 6209,            6, 0x00000800,   EN,   -3, 0x00008000, 6205, 6209,            6, 0x00008800,   EN,   -3, 0x00000040, 6209, 6210,            8, 0x00008802,   EN,   -3, 0x00000040, 6209, 6210,            8, 0x00000080,   -1,    0, 0x00000000, 6202, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 6205, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 6209, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 1000, 5000,            3, 0x00000000,   EN,    0, 0x00000800, 5001, 6205,            3, 0x00000000,   EN,   -2, 0x00000800, 5001, 6205,            4, 0x00000000,   EN,   -2, 0x00000800, 5016, 6205,            4, 0x00000000,   EN,   -4, 0x00000800, 5016, 6205,            6, 0x00000080,   -1,    0, 0x00000000, 6206, 5000,
// Deathclaw
    4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            4, 0x00000000,   EN,    0, 0x00000002, 5016, 5023,            5, 0x00000000,   EN,   -3, 0x00000002, 5016, 5023,            5, 0x00000000,   EN,   -5, 0x00000002, 5016, 5023,            6, 0x00000000,   EN,   -4, 0x00008002, 5016, 5004,            6, 0x00000000,   EN,   -5, 0x00008002, 5016, 5004,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   EN,    0, 0x00000010, 5001, 5011,            3, 0x00000000,   EN,   -2, 0x00000010, 5001, 5011,            3, 0x00000000,   EN,   -4, 0x00000010, 5001, 5011,            3, 0x00000000,   EN,   -6, 0x00000010, 5001, 5011,            3, 0x00000000,   EN,   -8, 0x00000010, 5001, 5011,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   EN,    0, 0x00000020, 5001, 5014,            3, 0x00000000,   EN,   -2, 0x00000020, 5001, 5014,            3, 0x00000000,   EN,   -4, 0x00000020, 5001, 5014,            3, 0x00000000,   EN,   -6, 0x00000020, 5001, 5014,            3, 0x00000000,   EN,   -8, 0x00000020, 5001, 5014,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   EN,   -1, 0x00000800, 5001, 6300,            4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            4, 0x00000000,   EN,   -1, 0x00000800, 5016, 6300,            5, 0x00000802,   -1,    0, 0x00000000, 5004, 5000,            5, 0x00008802,   -1,    0, 0x00000000, 5005, 5000,
    3, 0x00000000,   AG,    0, 0x00000002, 5001, 5004,            3, 0x00000000,   EN,    0, 0x00000008, 5001, 5004,            3, 0x00000002,   EN,   -2, 0x00000008, 5001, 5004,            4, 0x00000002,   EN,   -4, 0x00000008, 5016, 5022,            4, 0x00000002,   EN,   -5, 0x00000008, 5023, 5024,            4, 0x00000002,   EN,   -6, 0x00000008, 5023, 5024,
    3, 0x00000000,   AG,    0, 0x00000002, 5001, 5004,            3, 0x00000000,   EN,    0, 0x00000008, 5001, 5004,            3, 0x00000002,   EN,   -2, 0x00000008, 5001, 5004,            4, 0x00000002,   EN,   -4, 0x00000008, 5016, 5022,            4, 0x00000002,   EN,   -5, 0x00000008, 5023, 5024,            4, 0x00000002,   EN,   -6, 0x00000008, 5023, 5024,
    4, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   EN,   -3, 0x00008000, 5001, 6301,            6, 0x00000800,   EN,   -6, 0x00008000, 6300, 6301,            6, 0x00000800,   EN,   -2, 0x00000040, 6301, 6302,            8, 0x00000840,   -1,    0, 0x00000000, 6302, 5000,            8, 0x00000840,   -1,    0, 0x00000000, 6302, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            5, 0x00000000,   AG,    0, 0x00000002, 5016, 5004,            5, 0x00000000,   AG,   -3, 0x00000002, 5016, 5004,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   EN,   -1, 0x00000800, 5001, 6300,            4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            4, 0x00000000,   EN,   -1, 0x00000800, 5016, 6300,            5, 0x00000802,   -1,    0, 0x00000000, 5004, 5000,            5, 0x00008802,   -1,    0, 0x00000000, 5005, 5000,
// Spore plant
    4, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 6400, 5000,            5, 0x00000000,   -1,    0, 0x00000000, 6401, 5000,            5, 0x00000800,   -1,    0, 0x00000000, 6402, 5000,            6, 0x00000800,   EN,   -3, 0x00008000, 6402, 6403,            6, 0x00000800,   EN,   -6, 0x00008000, 6402, 6403,
    3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 6400, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 6401, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 6401, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 6402, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,
    4, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 6400, 5000,            5, 0x00000000,   -1,    0, 0x00000000, 6401, 5000,            5, 0x00000800,   -1,    0, 0x00000000, 6402, 5000,            6, 0x00000800,   EN,   -4, 0x00000040, 6402, 6406,            6, 0x00000840,   -1,    0, 0x00000000, 6406, 6404,
    3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 6402, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 6402, 5000,            5, 0x00000800,   EN,   -3, 0x00008000, 6402, 6403,            5, 0x00000800,   EN,   -6, 0x00008000, 6402, 6403,
    3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6405, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 6400, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 6401, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 6401, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 6402, 5000,
// Gecko
    4, 0x00000000,   -1,    0, 0x00000000, 6701, 5000,            4, 0x00000800,   EN,    0, 0x00000001, 6700, 5003,            5, 0x00000800,   EN,   -3, 0x00000001, 6700, 5003,            5, 0x00000802,   EN,   -3, 0x00000001, 6700, 5003,            6, 0x00000801,   LK,    0, 0x00000040, 6700, 5006,            6, 0x00000080,   -1,    0, 0x00000000, 6700, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6702, 5000,            3, 0x00008000,   -1,    0, 0x00000000, 6702, 5000,            4, 0x00000000,   EN,   -3, 0x00000010, 6702, 5011,            4, 0x00000810,   -1,    0, 0x00000000, 6702, 5000,            4, 0x00000810,   -1,    0, 0x00000000, 6702, 5000,            4, 0x00000810,   -1,    0, 0x00000000, 6702, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6702, 5000,            3, 0x00008000,   -1,    0, 0x00000000, 6702, 5000,            4, 0x00000000,   EN,   -3, 0x00000020, 6702, 5000,            4, 0x00000820,   -1,    0, 0x00000000, 6702, 5000,            4, 0x00000820,   -1,    0, 0x00000000, 6702, 5000,            4, 0x00000820,   -1,    0, 0x00000000, 6702, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6701, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 6701, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 6704, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 6704, 5000,            6, 0x00000801,   -1,    0, 0x00000000, 6704, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 6704, 5000,
    3, 0x00000002,   -1,    0, 0x00000000, 6705, 5000,            3, 0x00000002,   EN,    0, 0x00000008, 6705, 5024,            4, 0x00000002,   EN,   -3, 0x00000008, 6705, 5024,            4, 0x0000080A,   -1,    0, 0x00000000, 6705, 5000,            4, 0x0000080A,   EN,    0, 0x00000001, 6705, 5026,            4, 0x00000809,   -1,    0, 0x00000000, 6705, 5000,
    3, 0x00000002,   -1,    0, 0x00000000, 6705, 5000,            3, 0x00000002,   EN,    0, 0x00000004, 6705, 5024,            4, 0x00000002,   EN,   -3, 0x00000004, 6705, 5024,            4, 0x00000806,   -1,    0, 0x00000000, 6705, 5000,            4, 0x00000806,   EN,    0, 0x00000001, 6705, 5026,            4, 0x00000805,   -1,    0, 0x00000000, 6705, 5000,
    4, 0x00000000,   LK,    4, 0x00000040, 6700, 5028,            4, 0x00000800,   LK,    3, 0x00000040, 6700, 5028,            6, 0x00000800,   LK,    2, 0x00000040, 6700, 5028,            6, 0x00008840,   -1,    0, 0x00000000, 6700, 5000,            8, 0x00000841,   -1,    0, 0x00000000, 6700, 5000,            8, 0x00000080,   -1,    0, 0x00000000, 6700, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6703, 5000,            3, 0x00000800,   EN,   -3, 0x00000002, 6703, 5035,            3, 0x00000002,   EN,   -3, 0x00000001, 6703, 5036,            3, 0x00000001,   -1,    0, 0x00000000, 6703, 5000,            4, 0x00000802,   EN,    0, 0x00000001, 6703, 5036,            4, 0x00000801,   -1,    0, 0x00000000, 6703, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6700, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 6700, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 6700, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 6700, 5000,            6, 0x00000801,   -1,    0, 0x00000000, 6700, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 6700, 5000,
// Alien
    4, 0x00000000,   -1,    0, 0x00000000, 6801, 5000,            4, 0x00000800,   EN,    0, 0x00000001, 6800, 5003,            5, 0x00000800,   EN,   -3, 0x00000001, 6800, 5003,            5, 0x00000802,   EN,   -3, 0x00000001, 6803, 5003,            6, 0x00000801,   LK,    0, 0x00000040, 6804, 5006,            6, 0x00000080,   -1,    0, 0x00000000, 6804, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6806, 5000,            3, 0x00008000,   -1,    0, 0x00000000, 6806, 5000,            4, 0x00000000,   EN,   -3, 0x00000010, 6806, 5011,            4, 0x00000810,   -1,    0, 0x00000000, 6806, 5000,            4, 0x00000810,   -1,    0, 0x00000000, 6806, 5000,            4, 0x00000810,   -1,    0, 0x00000000, 6806, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6806, 5000,            3, 0x00008000,   -1,    0, 0x00000000, 6806, 5000,            4, 0x00000000,   EN,   -3, 0x00000020, 6806, 5000,            4, 0x00000820,   -1,    0, 0x00000000, 6806, 5000,            4, 0x00000820,   -1,    0, 0x00000000, 6806, 5000,            4, 0x00000820,   -1,    0, 0x00000000, 6806, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6800, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 6800, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 6800, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 6800, 5000,            6, 0x00000801,   -1,    0, 0x00000000, 6800, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 6800, 5000,
    3, 0x00000002,   -1,    0, 0x00000000, 6805, 5000,            3, 0x00000002,   EN,    0, 0x00000008, 6805, 5024,            4, 0x00000002,   EN,   -3, 0x00000008, 6805, 5024,            4, 0x0000080A,   -1,    0, 0x00000000, 6805, 5000,            4, 0x0000080A,   EN,    0, 0x00000001, 6805, 5026,            4, 0x00000809,   -1,    0, 0x00000000, 6805, 5000,
    3, 0x00000002,   -1,    0, 0x00000000, 6805, 5000,            3, 0x00000002,   EN,    0, 0x00000004, 6805, 5024,            4, 0x00000002,   EN,   -3, 0x00000004, 6805, 5024,            4, 0x00000806,   -1,    0, 0x00000000, 6805, 5000,            4, 0x00000806,   EN,    0, 0x00000001, 6805, 5026,            4, 0x00000805,   -1,    0, 0x00000000, 6805, 5000,
    4, 0x00000000,   LK,    4, 0x00000040, 6803, 5028,            4, 0x00000800,   LK,    3, 0x00000040, 6803, 5028,            6, 0x00000800,   LK,    2, 0x00000040, 6803, 5028,            6, 0x00008840,   -1,    0, 0x00000000, 6803, 5000,            8, 0x00000841,   -1,    0, 0x00000000, 6803, 5000,            8, 0x00000080,   -1,    0, 0x00000000, 6804, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6801, 5000,            3, 0x00000800,   EN,   -3, 0x00000002, 6801, 5035,            3, 0x00000002,   EN,   -3, 0x00000001, 6801, 5036,            3, 0x00000001,   -1,    0, 0x00000000, 6801, 5000,            4, 0x00000802,   EN,    0, 0x00000001, 6804, 5036,            4, 0x00000801,   -1,    0, 0x00000000, 6804, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6800, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 6800, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 6800, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 6800, 5000,            6, 0x00000801,   -1,    0, 0x00000000, 6800, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 6800, 5000,
// Giant ant
    4, 0x00000000,   -1,    0, 0x00000000, 6901, 5000,            4, 0x00000800,   EN,    0, 0x00000001, 6901, 5003,            5, 0x00000800,   EN,   -3, 0x00000001, 6902, 5003,            5, 0x00000802,   EN,   -3, 0x00000001, 6902, 5003,            6, 0x00000801,   LK,    0, 0x00000040, 6902, 5006,            6, 0x00000080,   -1,    0, 0x00000000, 6902, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6906, 5000,            3, 0x00008000,   -1,    0, 0x00000000, 6906, 5000,            4, 0x00000000,   EN,   -3, 0x00000010, 6906, 5011,            4, 0x00000810,   -1,    0, 0x00000000, 6906, 5000,            4, 0x00000810,   -1,    0, 0x00000000, 6906, 5000,            4, 0x00000810,   -1,    0, 0x00000000, 6906, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6906, 5000,            3, 0x00008000,   -1,    0, 0x00000000, 6906, 5000,            4, 0x00000000,   EN,   -3, 0x00000020, 6906, 5000,            4, 0x00000820,   -1,    0, 0x00000000, 6906, 5000,            4, 0x00000820,   -1,    0, 0x00000000, 6906, 5000,            4, 0x00000820,   -1,    0, 0x00000000, 6906, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6900, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 6900, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 6904, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 6904, 5000,            6, 0x00000801,   -1,    0, 0x00000000, 6904, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 6904, 5000,
    3, 0x00000002,   -1,    0, 0x00000000, 6905, 5000,            3, 0x00000002,   EN,    0, 0x00000008, 6905, 5024,            4, 0x00000002,   EN,   -3, 0x00000008, 6905, 5024,            4, 0x0000080A,   -1,    0, 0x00000000, 6905, 5000,            4, 0x0000080A,   EN,    0, 0x00000001, 6905, 5026,            4, 0x00000809,   -1,    0, 0x00000000, 6905, 5000,
    3, 0x00000002,   -1,    0, 0x00000000, 6905, 5000,            3, 0x00000002,   EN,    0, 0x00000004, 6905, 5024,            4, 0x00000002,   EN,   -3, 0x00000004, 6905, 5024,            4, 0x00000806,   -1,    0, 0x00000000, 6905, 5000,            4, 0x00000806,   EN,    0, 0x00000001, 6905, 5026,            4, 0x00000805,   -1,    0, 0x00000000, 6905, 5000,
    4, 0x00000000,   LK,    4, 0x00000040, 6900, 5028,            4, 0x00000800,   LK,    3, 0x00000040, 6906, 5028,            6, 0x00000800,   LK,    2, 0x00000040, 6901, 5028,            6, 0x00008840,   -1,    0, 0x00000000, 6901, 5000,            8, 0x00000841,   -1,    0, 0x00000000, 6901, 5000,            8, 0x00000080,   -1,    0, 0x00000000, 6901, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6900, 5000,            3, 0x00000800,   EN,   -3, 0x00000002, 6900, 5035,            3, 0x00000002,   EN,   -3, 0x00000001, 6900, 5036,            3, 0x00000001,   -1,    0, 0x00000000, 6903, 5000,            4, 0x00000802,   EN,    0, 0x00000001, 6903, 5036,            4, 0x00000801,   -1,    0, 0x00000000, 6903, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6900, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 6900, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 6904, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 6904, 5000,            6, 0x00000801,   -1,    0, 0x00000000, 6904, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 6904, 5000,
// Big bad boss
    3, 0x00000000,   -1,    0, 0x00000000, 7101, 7100,            3, 0x00000000,   -1,    0, 0x00000000, 7102, 7103,            4, 0x00000000,   -1,    0, 0x00000000, 7102, 7103,            4, 0x00008000,   -1,    0, 0x00000000, 7104, 7103,            5, 0x00000002,   LK,    0, 0x00000040, 7105, 7106,            6, 0x00000002,   -1,    0, 0x00000000, 7105, 7100,
    3, 0x00000000,   -1,    0, 0x00000000, 7106, 7100,            3, 0x00000000,   -1,    0, 0x00000000, 7106, 7100,            3, 0x00008000,   -1,    0, 0x00000000, 7106, 7011,            4, 0x00008000,   -1,    0, 0x00000000, 7106, 7100,            4, 0x00000010,   -1,    0, 0x00000000, 7106, 7100,            4, 0x00000010,   -1,    0, 0x00000000, 7106, 7100,
    3, 0x00000000,   -1,    0, 0x00000000, 7106, 7100,            3, 0x00000000,   -1,    0, 0x00000000, 7106, 7100,            3, 0x00008000,   -1,    0, 0x00000000, 7106, 7100,            4, 0x00008000,   -1,    0, 0x00000000, 7106, 7100,            4, 0x00000020,   -1,    0, 0x00000000, 7106, 7100,            4, 0x00000020,   -1,    0, 0x00000000, 7106, 7100,
    3, 0x00000000,   -1,    0, 0x00000000, 7106, 7100,            3, 0x00000000,   -1,    0, 0x00000000, 7106, 7100,            3, 0x00000000,   -1,    0, 0x00000000, 7106, 7100,            4, 0x00000000,   -1,    0, 0x00000000, 7106, 7100,            4, 0x00000002,   -1,    0, 0x00000000, 7106, 7100,            5, 0x00000002,   -1,    0, 0x00000000, 7106, 7100,
    3, 0x00000002,   -1,    0, 0x00000000, 7106, 7100,            3, 0x00000002,   EN,    0, 0x00000008, 7106, 7106,            3, 0x00000002,   EN,   -3, 0x00000008, 7060, 7106,            4, 0x0000000A,   -1,    0, 0x00000000, 7106, 7100,            4, 0x0000000A,   -1,    0, 0x00000000, 7106, 7106,            4, 0x00000008,   -1,    0, 0x00000000, 7106, 7100,
    3, 0x00000002,   -1,    0, 0x00000000, 7106, 7100,            3, 0x00000002,   EN,    0, 0x00000004, 7106, 7024,            3, 0x00000002,   EN,   -3, 0x00000004, 7106, 7024,            4, 0x00000006,   -1,    0, 0x00000000, 7106, 7100,            4, 0x00000006,   -1,    0, 0x00000000, 7106, 7106,            4, 0x00000004,   -1,    0, 0x00000000, 7106, 7100,
    3, 0x00000000,   -1,    0, 0x00000000, 7106, 7106,            3, 0x00000000,   -1,    0, 0x00000000, 7106, 7106,            4, 0x00000000,   LK,    2, 0x00000040, 7106, 7106,            4, 0x00008000,   -1,    0, 0x00000000, 7106, 7100,            5, 0x00008040,   -1,    0, 0x00000000, 7106, 7100,            5, 0x00008040,   -1,    0, 0x00000000, 7106, 7100,
    3, 0x00000000,   -1,    0, 0x00000000, 7106, 7100,            3, 0x00000000,   EN,   -3, 0x00000002, 7106, 7106,            3, 0x00000002,   -1,    0, 0x00000000, 7106, 7106,            3, 0x00000002,   -1,    0, 0x00000000, 7106, 7100,            4, 0x00000000,   -1,    0, 0x00000000, 7106, 7106,            4, 0x00000002,   -1,    0, 0x00000000, 7106, 7100,
    3, 0x00000000,   -1,    0, 0x00000000, 7106, 7100,            3, 0x00000000,   -1,    0, 0x00000000, 7106, 7100,            4, 0x00000000,   -1,    0, 0x00000000, 7106, 7100,            4, 0x00000000,   -1,    0, 0x00000000, 7106, 7100,            5, 0x00000002,   -1,    0, 0x00000000, 7106, 7100,            5, 0x00000002,   -1,    0, 0x00000000, 7106, 7100,
// Giant Beetle
    4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            4, 0x00000000,   EN,    0, 0x00000002, 5016, 5023,            5, 0x00000000,   EN,   -3, 0x00000002, 5016, 5023,            5, 0x00000000,   EN,   -5, 0x00000002, 5016, 5023,            6, 0x00000000,   EN,   -4, 0x00008002, 5016, 5004,            6, 0x00000000,   EN,   -5, 0x00008002, 5016, 5004,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   EN,    0, 0x00000010, 5001, 7300,            3, 0x00000000,   EN,   -2, 0x00000010, 5001, 7300,            3, 0x00000000,   EN,   -4, 0x00000010, 5001, 7300,            3, 0x00000000,   EN,   -6, 0x00000010, 5001, 7300,            3, 0x00000000,   EN,   -8, 0x00000010, 5001, 7300,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   EN,    0, 0x00000020, 5001, 7301,            3, 0x00000000,   EN,   -2, 0x00000020, 5001, 7301,            3, 0x00000000,   EN,   -4, 0x00000020, 5001, 7301,            3, 0x00000000,   EN,   -6, 0x00000020, 5001, 7301,            3, 0x00000000,   EN,   -8, 0x00000020, 5001, 7301,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   EN,   -1, 0x00000800, 5001, 7302,            4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            4, 0x00000000,   EN,   -1, 0x00000800, 5016, 7302,            5, 0x00000802,   -1,    0, 0x00000000, 5004, 5000,            5, 0x00008802,   -1,    0, 0x00000000, 5005, 5000,
    3, 0x00000000,   AG,    0, 0x00000002, 5001, 5004,            3, 0x00000000,   EN,    0, 0x00000008, 5001, 5004,            3, 0x00000002,   EN,   -2, 0x00000008, 5001, 5004,            4, 0x00000002,   EN,   -4, 0x00000008, 5016, 5022,            4, 0x00000002,   EN,   -5, 0x00000008, 5023, 7307,            4, 0x00000002,   EN,   -6, 0x00000008, 5023, 7307,
    3, 0x00000000,   AG,    0, 0x00000002, 5001, 5004,            3, 0x00000000,   EN,    0, 0x00000008, 5001, 5004,            3, 0x00000002,   EN,   -2, 0x00000008, 5001, 5004,            4, 0x00000002,   EN,   -4, 0x00000008, 5016, 5022,            4, 0x00000002,   EN,   -5, 0x00000004, 5023, 7308,            4, 0x00000002,   EN,   -6, 0x00000008, 5023, 7308,
    4, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   EN,   -3, 0x00008000, 5001, 7303,            6, 0x00000800,   EN,   -6, 0x00008000, 7300, 7303,            6, 0x00000800,   EN,   -2, 0x00000040, 7302, 7306,            8, 0x00000840,   -1,    0, 0x00000000, 7309, 5000,            8, 0x00000840,   -1,    0, 0x00000000, 7309, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            5, 0x00000000,   AG,    0, 0x00000002, 5016, 5004,            5, 0x00000000,   AG,   -3, 0x00000002, 5016, 5004,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   EN,   -1, 0x00000800, 5001, 7302,            4, 0x00000000,   -1,    0, 0x00000000, 5016, 5000,            4, 0x00000000,   EN,   -1, 0x00000800, 5016, 7302,            5, 0x00000802,   -1,    0, 0x00000000, 5004, 5000,            5, 0x00008802,   -1,    0, 0x00000000, 5005, 5000,
// Giant Wasp
    4, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000000,   AG,    0, 0x00000002, 5001, 7200,            5, 0x00000000,   AG,   -3, 0x00000002, 5016, 7200,            5, 0x00000002,   EN,    0, 0x00000001, 7200, 7204,            6, 0x00000002,   EN,   -3, 0x00000001, 7201, 7204,            6, 0x00000080,   -1,    0, 0x00000000, 7210, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   EN,    0, 0x00008000, 5001, 7201,            4, 0x00000000,   EN,   -2, 0x00008000, 5001, 7201,            3, 0x00008800,   -1,    0, 0x00000000, 7205, 5000,            4, 0x00008800,   -1,    0, 0x00000000, 7205, 5000,            4, 0x00000080,   -1,    0, 0x00000000, 7210, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   EN,    0, 0x00008000, 5001, 7201,            4, 0x00000000,   EN,   -2, 0x00008000, 5001, 7201,            3, 0x00008800,   -1,    0, 0x00000000, 7205, 5000,            4, 0x00008800,   -1,    0, 0x00000000, 7205, 5000,            4, 0x00000080,   -1,    0, 0x00000000, 7210, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   AG,    0, 0x00000002, 5001, 7200,            3, 0x00000000,   AG,   -2, 0x00000002, 5001, 7200,            4, 0x00000002,   -1,    0, 0x00000000, 7200, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 7204, 5000,            4, 0x00000080,   -1,    0, 0x00000000, 7210, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   AG,    1, 0x00000002, 5001, 7200,            4, 0x00000000,   AG,   -1, 0x00000002, 5001, 7200,            4, 0x00000002,   EN,   -1, 0x0000000C, 7200, 7206,            4, 0x00000802,   EN,   -3, 0x0000000C, 7204, 7208,            6, 0x00000080,   -1,    0, 0x00000000, 7210, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00008000,   -1,    0, 0x00000000, 7201, 5000,            4, 0x00008000,   -1,    0, 0x00000000, 7201, 5000,            4, 0x00008030,   -1,    0, 0x00000000, 7208, 5000,            4, 0x00008030,   -1,    0, 0x00000000, 5808, 5000,
    4, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            4, 0x00000800,   -1,    0, 0x00000000, 7202, 5000,            5, 0x00000000,   EN,    0, 0x00000040, 5016, 7803,            5, 0x00000800,   EN,   -3, 0x00000040, 7202, 7207,            6, 0x00000840,   -1,    0, 0x00000000, 7207, 5000,            6, 0x00000842,   -1,    0, 0x00000000, 7209, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   EN,    0, 0x00000002, 5001, 7200,            3, 0x00000000,   EN,   -3, 0x00000002, 5001, 7200,            3, 0x00000802,   -1,    0, 0x00000000, 7200, 5000,            3, 0x00000802,   -1,    0, 0x00000000, 7204, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 5001, 5000,            3, 0x00000000,   AG,    0, 0x00000002, 5001, 7200,            3, 0x00000000,   AG,   -2, 0x00000002, 5001, 7200,            4, 0x00000002,   -1,    0, 0x00000000, 7200, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 7204, 5000,            4, 0x00000080,   -1,    0, 0x00000000, 7210, 5000,
// Player
    3, 0x00000000,   -1,    0, 0x00000000, 6500, 5000,            3, 0x00000800,   EN,    3, 0x00000002, 6501, 6503,            3, 0x00000800,   EN,    0, 0x00000002, 6501, 6503,            3, 0x00000802,   EN,    2, 0x00000001, 6503, 6502,            3, 0x00000801,   LK,    2, 0x00000040, 6502, 6504,            6, 0x00000800,   EN,   -2, 0x00000080, 6501, 6505,
    2, 0x00000000,   -1,    0, 0x00000000, 6506, 5000,            2, 0x00008000,   -1,    0, 0x00000000, 6507, 5000,            3, 0x00000000,   EN,    0, 0x00000010, 6508, 6509,            3, 0x00000800,   -1,    0, 0x00000000, 6501, 5000,            3, 0x00000810,   -1,    0, 0x00000000, 6510, 5000,            3, 0x00000810,   -1,    0, 0x00000000, 6510, 5000,
    2, 0x00000000,   -1,    0, 0x00000000, 6506, 5000,            2, 0x00008000,   -1,    0, 0x00000000, 6507, 5000,            3, 0x00000000,   EN,    0, 0x00000020, 6508, 6509,            3, 0x00000800,   -1,    0, 0x00000000, 6501, 5000,            3, 0x00000820,   -1,    0, 0x00000000, 6511, 5000,            3, 0x00000820,   -1,    0, 0x00000000, 6511, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6512, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6512, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 6508, 5000,            3, 0x00000802,   -1,    0, 0x00000000, 6503, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 6503, 5000,            4, 0x00000802,   LK,    2, 0x00000080, 6503, 6513,
    3, 0x00000000,   -1,    0, 0x00000000, 6512, 5000,            3, 0x00000002,   -1,    0, 0x00000000, 6514, 5000,            3, 0x00000002,   EN,    0, 0x00000008, 6514, 6515,            4, 0x0000080A,   -1,    0, 0x00000000, 6516, 5000,            4, 0x0000080A,   -1,    0, 0x00000000, 6516, 5000,            4, 0x00000809,   -1,    0, 0x00000000, 6517, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6512, 5000,            3, 0x00000002,   -1,    0, 0x00000000, 6514, 5000,            3, 0x00000002,   EN,    0, 0x00000004, 6514, 6515,            4, 0x00000806,   -1,    0, 0x00000000, 6516, 5000,            4, 0x00000806,   -1,    0, 0x00000000, 6516, 5000,            4, 0x00000805,   -1,    0, 0x00000000, 6517, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6518, 5000,            3, 0x00000000,   LK,    3, 0x00000040, 6518, 6519,            3, 0x00000800,   LK,    3, 0x00000040, 6501, 6519,            4, 0x00008800,   -1,    0, 0x00000000, 6520, 5000,            4, 0x00008840,   -1,    0, 0x00000000, 6521, 5000,            6, 0x00000080,   -1,    0, 0x00000000, 6522, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6523, 5000,            3, 0x00000000,   EN,    0, 0x00000002, 6523, 6524,            3, 0x00000002,   -1,    0, 0x00000000, 6524, 5000,            3, 0x00000002,   EN,    4, 0x00000001, 6524, 6525,            4, 0x00000002,   EN,    2, 0x00000001, 6524, 6525,            4, 0x00000001,   -1,    0, 0x00000000, 6526, 5000,
    3, 0x00000000,   -1,    0, 0x00000000, 6512, 5000,            3, 0x00000000,   -1,    0, 0x00000000, 6512, 5000,            3, 0x00000800,   -1,    0, 0x00000000, 6508, 5000,            3, 0x00000802,   -1,    0, 0x00000000, 6503, 5000,            4, 0x00000802,   -1,    0, 0x00000000, 6503, 5000,            4, 0x00000802,   LK,    2, 0x00000080, 6503, 6513
};

// fallout2.exe at file offset 0x1065A0 (517FA0 memory offset)
// row: weapon type (critfail list), column: critfail severity
const uint[] CriticalFailureTable =
{
    0x00000000, 0x00008000, 0x00008000, 0x00080002, 0x00200000,
    0x00000000, 0x00008000, 0x00004000, 0x00100000, 0x00010000,
    0x00000000, 0x00020000, 0x00004000, 0x00100000, 0x00002000,
    0x00008000, 0x00028000, 0x0000C000, 0x00100000, 0x00009000,
    0x00040000, 0x00004000, 0x00084000, 0x00100000, 0x00001000,
    0x00008000, 0x00040000, 0x00002000, 0x00100000, 0x00009002,
    0x00000000, 0x00008000, 0x00100000, 0x00002000, 0x00009400
};

// clang-format on
