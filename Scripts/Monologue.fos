namespace Monologue
{

#if SERVER

// Author rifleman17
// Монологи для НПЦ: несколько фраз. повторяемых через определенные промежутки времени.
// Указывается первая и последняя строка монолога, время, через которое повторится монолог и т.д.
// Строки должны быть записаны в FOTEXT.MSG
// Строки монолога должны нумероваться подряд.
// Если время следующего диалога равно нулю, все записи будут удалены после первого использования

///@ Property Critter Server uint8[] MonologueData Mutable Persistent

bool MonologueRunning(Critter cr)
{
    return valid(GetMonologue(cr));
}

void SetMonologue(Critter cr, int firstStr, int lastStr, timespan nextMsg, timespan nextDialog, SayType say)
{
    Monologue m = Monologue(firstStr, lastStr, nextMsg, nextDialog, say, cr.Id);
    if (valid(m)) {
        m.ScheduleMonologue();
    }
}

Monologue GetMonologue(Critter cr)
{
    if (!valid(cr)) {
        return null;
    }
    Monologue m = Monologue(cr.Id);
    if (!valid(m) || !m.Exist()) {
        return null;
    }
    m.Load();
    return m;
}

class Monologue
{
    Monologue(ident critterId)
    {
        CritterId = critterId;
    }

    Monologue(int firstStr, int lastStr, timespan nextMsg, timespan nextDialog, SayType say, ident critterId)
    {
        FirstString = firstStr;
        LastString = lastStr;
        CurrentString = 0;
        NextMessage = nextMsg;
        NextDialogue = nextDialog;
        Say = say;
        CritterId = critterId;
        Save();
    }

    int FirstString;       // Номер первой строки в монологе
    int LastString;        // Номер последней строки
    int CurrentString;     // Текущая строка
    timespan NextMessage;  // Время следующей фразы в монологе в секундах
    timespan NextDialogue; // Время следующего монолога
    SayType Say;           // Тип разговора (шепот, эмоции итд)
    ident CritterId;       // Код криттера, читающего монолог

    bool Exist()
    {
        return Game.GetCritter(CritterId).MonologueData.length() > 0;
    }

    // Сериализация
    void Save()
    {
        auto save = Serializator::Serializator();
        save.Set(FirstString);
        save.Set(LastString);
        save.Set(CurrentString);
        save.Set(NextMessage);
        save.Set(NextDialogue);
        save.Set(int(Say));
        save.Set(CritterId);
        Game.GetCritter(CritterId).MonologueData = save.GetData();
    }

    void Load()
    {
        auto load = Serializator::Serializator();
        if (load.SetData(Game.GetCritter(CritterId).MonologueData) == 0) {
            return;
        }
        load.Get(FirstString);
        load.Get(LastString);
        load.Get(CurrentString);
        load.Get(NextMessage);
        load.Get(NextDialogue);
        int say = 0;
        load.Get(say);
        Say = SayType(say);
        load.Get(CritterId);
    }

    void Erase()
    {
        Game.GetCritter(CritterId).MonologueData = array<uint8>();
    }

    void ScheduleMonologue()
    {
        Critter cr = Game.GetCritter(CritterId);
        if (!valid(cr)) {
            return;
        }

        if (cr.CountTimeEvent(cte_RunMonologue) == 0) {
            cr.StartTimeEvent(NextDialogue, cte_RunMonologue);
        }
    }

    void ScheduleMessage()
    {
        Critter cr = Game.GetCritter(CritterId);
        if (!valid(cr)) {
            return;
        }

        if (cr.CountTimeEvent(cte_NextMessage) == 0) {
            cr.StartTimeEvent(NextMessage, cte_NextMessage);
        }
    }
};

// Начало диалога
void cte_RunMonologue(Critter cr)
{
    Monologue m = GetMonologue(cr);
    if (valid(m)) {
        m.CurrentString = m.FirstString;
        m.Save();
        m.ScheduleMessage();
        if (m.NextDialogue != ZERO_TIMESPAN) {
            Game.RepeatCurrentTimeEvent(m.NextDialogue);
        }
    }
}

void cte_NextMessage(Critter cr)
{
    Monologue m = GetMonologue(cr);
    if (valid(m)) {
        if (m.CurrentString > m.LastString) {
            if (m.NextDialogue == ZERO_TIMESPAN) { // Диалог одноразовый
                m.Erase();
            }
            return;
        }
        Messaging::SayExt(cr, m.Say, true, "", TextPackName::Text, m.CurrentString, "");
        m.CurrentString++;
        m.Save();
        if (m.NextMessage != ZERO_TIMESPAN) {
            Game.RepeatCurrentTimeEvent(m.NextMessage);
        }
    }
}

// Баллада паладина БС
bool d_MonologueRunning(Critter player, Critter npc)
{
    return (valid(npc) && MonologueRunning(npc));
}

bool d_NotMonologueRunning(Critter player, Critter npc)
{
    return !d_MonologueRunning(player, npc);
}

void r_RunMonologue(Critter player, Critter npc, int firstStr, int lastStr, int nextMsgSeconds, int nextDialogSeconds, int sayType)
{
    SetMonologue(npc,
                 firstStr,
                 lastStr,
                 Time::Seconds(nextMsgSeconds),
                 (nextDialogSeconds == 0 ? ZERO_TIMESPAN : Time::Seconds(nextDialogSeconds)),
                 SayType(sayType));
}

#endif

}
