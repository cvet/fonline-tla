// FOS Server Client

///@ RemoteCall Server StartDialog(uint npcId)
///@ RemoteCall Server UseSkillOnItem(uint itemId, CritterProperty skill)

#ifdef __CLIENT

void ModuleInit()
{
    auto dropMenu = FixedDropMenu::FixedDropMenu(MouseButton::Left, CursorType::Default, 500, 40, "art/intrface/", "IACCUXX1");

    dropMenu.AddButton(20, CanDialog, Dialog, "TALKN.frm", "TALKH.frm");
    dropMenu.AddButton(30, CanUse, Use, "USEGETN.frm", "USEGETH.frm");
    dropMenu.AddButton(40, CanLook, Look, "LOOKN.frm", "LOOKH.frm");
    dropMenu.AddButton(50, CanDrop, Drop, "DROPN.frm", "DROPH.frm");
    dropMenu.AddButton(55, CanRotate, Rotate, "ROTATEN.frm", "ROTATEH.frm");
    dropMenu.AddButton(60, CanUnload, DoUnload, "UNLOADN.FRM", "UNLOADH.FRM");
    dropMenu.AddButton(70, CanUseSkill, DoUseSkill, "SKILLN.FRM", "SKILLH.FRM");
    dropMenu.AddButton(100, CanCloseMenu, CloseMenu, "CANCELN.frm", "CANCELH.frm");

    // INVENH/N - инвентарь кнопка PUSHH/PUSHN - толчок; ROTATEH/ROTATEN - поворот.USEGETH/N - рука использования/LOOKH|LOOKN - просмотр подробный

    Gui::SetDropMenu(dropMenu);
}

bool CanUseSkill(Critter cr, Item item)
{
    return valid(cr) || valid(item);
}

void DoUseSkill(Critter cr, Item item)
{
    uint itemId = 0;
    uint critterId = 0;
    uint isInventory = 0;

    if (valid(item)) {
        itemId = item.Id;
        if (item.Ownership == ItemOwnership::CritterInventory)
            isInventory = 1;
    }
    else {
        if (valid(cr))
            critterId = cr.Id;
    }
    Game.ShowScreen(CLIENT_SCREEN_SKILLBOX,
                    UtilsForArray::DictionaryToDict(dictionary = {{"TargetCritterId", critterId}, {"TargetItemId", itemId}, {"IsInventory", isInventory}}));
}

bool CanDialog(Critter cr, Item item)
{
    // ToDo - диалог с предметами
    return cr != null && IsChosenAlive() && cr.IsNpc() && cr.IsAlive() && cr.DialogId != hstring() && !cr.IsNoTalk;
}

void Dialog(Critter cr, Item item)
{
    // ServerCall.StartDialog( cr.Id );
    ChosenActions::SetChosenActions(array<uint> = {Tla::ChosenTalkNpc, cr.Id, 0, 0, 0, 0, 0});
}

bool IsChosenAlive()
{
    Critter chosen = Game.GetChosen();
    return chosen != null && chosen.IsAlive();
}

// Close menu
bool CanCloseMenu(Critter cr, Item item)
{
    return valid(cr) || valid(item);
}

void CloseMenu(Critter cr, Item item)
{
    //
}

// Look
bool CanLook(Critter cr, Item item)
{
    return valid(cr) || valid(item);
}

void Look(Critter cr, Item item)
{
    if (valid(item))
        Game.Message(ClientMain::item_description(item, ItemLookTypes::Default));
    else if (valid(cr))
        Game.Message(ClientMain::critter_description(cr, CritterLookTypes::LookFull));
}

bool CanUse(Critter cr, Item item)
{
    // Loot critter
    if (cr != null && IsChosenAlive() && !cr.IsChosen() && cr.IsDead() && !cr.IsNoLoot)
        return true;
    return item != null && IsChosenAlive() && item.Ownership == ItemOwnership::MapHex && !item.IsWall &&
           (item.IsCanUse || item.IsCanUseOnSmth || item.IsCanPickUp);
}

void Use(Critter cr, Item item)
{
    // if(item.Ownership != ItemOwnership::MapHex )
    //    return;
    if (valid(item) && item.Ownership == ItemOwnership::MapHex) {
        // ServerCall.UseSkillOnItem( item.Id, SKILL_PICK_ON_GROUND );
        ChosenActions::SetChosenActions(array<uint> = {Tla::ChosenPickItem, item.ProtoId.hash, item.HexX, item.HexY, item.Id, 0, 0});
    }
}

bool CanDrop(Critter cr, Item item)
{
    return item != null && IsChosenAlive() && IsChosenItem(item);
}

bool IsChosenItem(Item item)
{
    return item.Ownership == ItemOwnership::CritterInventory && item.CritId == Game.GetChosen().Id;
}

void Drop(Critter cr, Item item)
{
    if (item.Stackable && item.Count > 1)
        Game.ShowScreen(CLIENT_SCREEN_SPLIT, UtilsForArray::DictionaryToDict(dictionary = {{"TargetItemId", item.Id}, {"ItemsCollection", ITEMS_CHOSEN_ALL}}));
    else
        ChosenActions::SetChosenActions(array<uint> = {Tla::ChosenMoveItem, item.Id, item.Count, SLOT_GROUND, 0, 0, 0});
}

bool CanRotate(Critter cr, Item item)
{
    return cr != null && CurMap != null && cr.IsChosen() && cr.IsAlive();
}

void Rotate(Critter cr, Item item)
{
    ChosenActions::SetChosenActions(array<uint> = {Tla::ChosenDir, 0, 0, 0, 0, 0, 0});
}

bool CanUnload(Critter cr, Item item)
{
    return item != null && item.Type == ItemType::Weapon && IsChosenAlive() && IsChosenItem(item) && item.AmmoCount > 0;
}

void DoUnload(Critter cr, Item item)
{
    ChosenActions::SetChosenActions(array<uint> = {Tla::ChosenUseItem, item.Id, 0, TARGET_SELF_ITEM, uint(-1), USE_RELOAD, 0});
}

#endif

#ifdef __SERVER

void StartDialog(Critter client, uint npcId)
{
    Critter npc = Game.GetCritter(npcId);
    if (valid(client) && client.IsAlive() && valid(npc) && npc.IsAlive() && npc.IsNpc() && !npc.IsNoTalk) {
        Game.RunDialog(client, npc, false);
    }
}

void UseSkillOnItem(Player player, uint itemId, CritterProperty skill)
{
    Critter cr = player.GetOwnedCritter();
    Item item = Game.GetItem(itemId);
    if (valid(cr) && valid(item)) {
        if (item.Type == ItemType::Container || item.Type == ItemType::Door) {
            Lockers::UseSkillOnLocker(cr, item, SKILL_PICK_ON_GROUND);
        }
    }
}
#endif
