namespace HellMineMining
{

#if SERVER

///@ Property Critter Server synctime HellMineTimeoutEnd Mutable Persistent

#define BASE_TIMEOUT     (11) // real seconds

#define STR_NEED_REST    (2201)
#define STR_MINE_URANIUM (3035)
#define STR_MINE_STONE   (3036)
#define STR_MINE_GOLD    (3037)

bool s_MineGold(Critter cr, StaticItem sc, Item item, any skill)
{
    return s_MG(cr, sc, item, skill);
}

bool s_MG(Critter cr, StaticItem sc, Item item, any skill) // Mine Gold
{
    if (not IsMiningTool(item)) {
        return false;
    }

    if (not IsTimeoutExpired(cr)) {
        // critter need a rest
        Messaging::Info(cr, TextPackName::Text, STR_NEED_REST);
        return true;
    }
    else {
        Effects::Animate(cr, CritterStateAnim::Hammer, CritterActionAnim::Swing1H);
    }

    int successChance = (cr.Endurance + cr.Strength * 4);
    successChance = CLAMP(successChance, 10, 95);
    int roll = Game.Random(1, 100);

    if (roll <= successChance) {
        cr.AddItem(Content::Item::gold_nugget, 1);
        Messaging::Info(cr, TextPackName::Text, STR_MINE_GOLD);
    }
    else {
        Messaging::Info(cr, TextPackName::Text, STR_MINE_STONE);
        cr.AddItem(Content::Item::rock, 1);
    }

    SetTimeout(cr);
    return true;
}

bool s_Mine(Critter cr, StaticItem sc, Item item, any skill)
{
    if (not IsMiningTool(item)) {
        return false;
    }

    if (not IsTimeoutExpired(cr)) {
        // critter need a rest
        Messaging::Info(cr, TextPackName::Text, STR_NEED_REST);

        // cr.Animate(0xFF, STATE_ANIM_EMPTY, 0, 0xFF, 0, true, true, true);

        return true;
    }
    else {
        Effects::Animate(cr, CritterStateAnim::Hammer, CritterActionAnim::Swing1H);
    }

    int successChance = (cr.Luck) * 10;
    successChance = CLAMP(successChance, 10, 95);
    int roll = Game.Random(1, 100);

    // шанс выбить простой камень
    if (roll <= successChance) {
        cr.AddItem(Content::Item::uranium_ore, 1);
        // Messaging::Info(cr, "Success. Roll/Chance = " + roll + "/" + successChance);
        Messaging::Info(cr, TextPackName::Text, STR_MINE_URANIUM);
    }
    else {
        // Messaging::Info(cr, "Fail. Roll/Chance = " + roll + "/" + successChance);
        Messaging::Info(cr, TextPackName::Text, STR_MINE_STONE);
        // r17 091228>
        // добавление камня всегда, если не досталось урановой руды
        cr.AddItem(Content::Item::rock, 1);
        // <r17
    }

    SetTimeout(cr);
    return true;
}

/*
   Determines whether given item is appropriate for mining
 */
bool IsMiningTool(Item item)
{
    if (not valid(item)) {
        return false;
    }

    hstring pid = item.ProtoId;
    return pid == Content::Item::sledgehammer || pid == Content::Item::super_sledge;
}

/*
   Checks whether mining timeout for given critter is expired
 */
bool IsTimeoutExpired(Critter cr)
{
    if (Game.SynchronizedTime >= cr.HellMineTimeoutEnd) {
        return true;
    }

    Messaging::Info(cr, "Remaining time, seconds: " + (cr.HellMineTimeoutEnd - Game.SynchronizedTime).seconds);
    return false;
}

/*
   Sets mining timeout for given critter
 */
void SetTimeout(Critter cr)
{
    // basic formula for timeout time in real seconds
    int timeoutTime = (BASE_TIMEOUT - cr.Endurance);
    // set timeout end timestamp
    cr.HellMineTimeoutEnd = Game.SynchronizedTime + Time::Seconds(timeoutTime);
    Messaging::Info(cr, "Setting timeout, seconds: " + (cr.HellMineTimeoutEnd - Game.SynchronizedTime).seconds);
}

#endif

}
