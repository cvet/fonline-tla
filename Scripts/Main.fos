// FOS Server Sort 2
// Author: cvet

///@ Property Player PrivateServer ident MainCritterId

///@ Property Critter PrivateServer ident=>uint StealExpCount
///@ Property Critter PrivateServer ident=>uint FirstAidCount

void ModuleInit()
{
    Game.OnInit.Subscribe(init);
    Game.OnStart.Subscribe(start);
    Game.OnGenerateWorld.Subscribe(generate_world);
    Game.OnCritterAttack.Subscribe(critter_attack);
    Game.OnCritterAttacked.Subscribe(critter_attacked);
    Game.OnCritterStealing.Subscribe(critter_stealing);
    Game.OnCritterUseItemOn.Subscribe(critter_use_item);
    Game.OnCritterUseSkill.Subscribe(critter_use_skill);
    Game.OnCritterReloadWeapon.Subscribe(critter_reload_weapon);
    Game.OnCritterInit.Subscribe(critter_init);
    Game.OnCritterFinish.Subscribe(critter_finish);
    Game.OnCritterIdle.Subscribe(critter_idle);
    Game.OnCritterDead.Subscribe(critter_dead);
    Game.OnCritterKnockout.Subscribe(critter_knockout);
    Game.OnCritterRespawn.Subscribe(critter_respawn);
    Game.OnMapCritterIn.Subscribe(map_critter_in);
    Game.OnMapCritterOut.Subscribe(map_critter_out);
    Game.OnMapCheckLook.Subscribe(check_look);
    Game.OnMapCheckTrapLook.Subscribe(check_trap_look);
    Game.OnItemsBarter.Subscribe(items_barter);
    Game.OnPlayerRegistration.Subscribe(player_registration);
    Game.OnPlayerLogin.Subscribe(player_login);
    Game.OnPlayerEnter.Subscribe(OnPlayerEnter);
    Game.OnPlayerGetAccess.Subscribe(player_getaccess);
    Game.OnPlayerAllowCommand.Subscribe(player_allowcommand);
    Game.OnMapLoopEx.Subscribe(map_loop_ex);
    Game.OnPlayerCheckMove.Subscribe(OnPlayerCheckMove);
    Game.OnPlayerCheckDir.Subscribe(OnPlayerCheckDir);
    Game.OnCritterTalk.Subscribe(OnCritterTalk);
    Game.OnCritterBarter.Subscribe(OnCritterBarter);
}

// Called on map loop
void map_loop_ex(Map map, uint loopIndex)
{
    switch (loopIndex) {
    case 1:
        map.OnLoopEx1.Fire();
        break;
    case 2:
        map.OnLoopEx2.Fire();
        break;
    case 3:
        map.OnLoopEx3.Fire();
        break;
    case 4:
        map.OnLoopEx4.Fire();
        break;
    default:
        break;
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called before world generation.
void init()
{
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on start server.
bool start()
{
    // Global map initialization
    Worldmap::WorldmapInit();

    // Caravans initialization
    // Caravan::CaravansInit();

    // NoPvP initialization
    // NoPvpMaps::SetNoPvp();

    // Game Events initialization
    // GameEvent::DeclareEvents();
    // GameEvent::CheckAllGameEvents();

    // Bulletin boards
    // BulletinBoard::StartMessenger();

    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on world initialization.
// Parameter         Min    Max
// multiplier        1      50000
// year              1700   30000
// month             1      12
// day               1      31
// hour              0      23
// minute            0      59
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on world generation.
bool generate_world()
{
    Game.SFImperatorMemory = 50;

    uint16 multiplier = Settings.TimeMultiplier;
    uint16 year = 2246;
    uint16 month = 10;
    uint16 day = 30;
    uint16 hour = 1;
    uint16 minute = 0;
    Game.SetTime(multiplier, year, month, day, hour, minute, 0);

    if (!valid(Game.CreateLocation(Content::Location::replication_1, 383, 230, null)) ||
        !valid(Game.CreateLocation(Content::Location::klamath, 375, 125, null)) /*||
        !valid ( Game.CreateLocation( Content::Location::den, 475, 275, null )) 
        ||     ||
                                                                                ! valid(Game.CreateLocation( Content::Location::modoc, 925, 275, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::vault_city, 1225, 325, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::gecko, 1275, 225, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::broken_hills, 1175, 875, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::new_reno, 925, 925, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::sierra_army_depot, 914, 814, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::vault_15, 1275, 1425, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::ncr, 1125, 1425, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::cathedral, 932, 64, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::mariposa, 675, 1425, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::redding, 675, 525, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::san_francisco, 475, 1325, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::navarro, 168, 866, null ))
        || !valid(Game.CreateLocation(Content::Location::arroyo, 175, 125, null)) ||
                                                                                !valid(Game.CreateLocation( Content::Location::primal_tribe, 120, 578, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::vault_13, 975, 1425, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::barter_ground, 690, 760, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::atoll, 310, 1365, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::raiders, 1166, 666, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::replication_2, 964, 363, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::replication_3, 614, 637, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::replication_4, 1065, 832, null )) ||
                                                                                !valid(Game.CreateLocation( Content::Location::replication_hell, 777, 466, null ))*/
    ) {
        Game.Log("Generate world fail!");
        return false;
    }

    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter attack another.
void critter_attack(Critter cr, Critter target, Item weapon, uint8 weaponMode, ProtoItem ammo)
{
    if (cr.IsControlledByPlayer && valid(ammo) && ammo.ProtoId == Content::Item::emp_rocket && target.BodyType == BodyTypes::Robot) {
        Navarro::CountEmpRocketTests(cr, target);
    }
    cr.TimeoutAggressor = Game.GetFullSecond() + Time::RealMinute(1);
    Combat::CombatAttack(cr, target, weapon, weaponMode, ammo);

    Critter[] other = cr.GetCritters(true, CritterFindType::Alive);
    for (uint i = 0; i < other.length(); i++) {
        other[i].OnSomeCritterAttack.Fire(cr, target, weapon, weaponMode, ammo);
    }

    Game.OnCritterAttacked.Fire(target, cr);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter attack another.
void critter_attacked(Critter cr, Critter attacker)
{
    Critter[] other = cr.GetCritters(true, CritterFindType::Alive);
    for (uint i = 0; i < other.length(); i++) {
        other[i].OnSomeCritterAttacked.Fire(cr, attacker);
    }

    if (cr.IsControlledByPlayer) {
        return; // Diable player helping
    }
    else {
        NpcPlanes::AddAttackPlane(cr, 0, attacker); // Answer on attack
    }

    uint helpers = 0;
    uint maxHelpers = 10 - attacker.Charisma;
    maxHelpers = CLAMP(maxHelpers, 2, 8);

    Critter[] critters = cr.GetCritters(true, CritterFindType::AliveNpc);
    for (uint i = 0; i < critters.length(); i++) {
        NpcPlanes::NpcPlane plane = NpcPlanes::GetCurPlane(critters[i]);
        if (valid(plane) && plane.Type == AI_PLANE_ATTACK && plane.Attack_TargId == attacker.Id) {
            helpers++;
            if (helpers >= maxHelpers) {
                return; // No help needed
            }
            critters[i] = null; // Exclude this critter
        }
    }

    int crHpProc = cr.CurrentHp * 100 / cr.MaxLife;
    uint teamId = cr.TeamId;
    uint attackerTeamId = attacker.TeamId;
    for (uint i = 0; i < critters.length(); i++) {
        Critter someCr = critters[i];
        if (not valid(someCr)) {
            continue; // Skip excluded
        }

        uint someCrTeamId = someCr.TeamId;
        if (attackerTeamId == someCrTeamId) {
            continue; // No attack temmate
        }

        int teamParity = TEAM_PARITY(someCrTeamId, teamId); // From -> To
        switch (teamParity) {
        case TeamsTable::Ignore:
            continue;
        case TeamsTable::Anyway:
            break;
        case TeamsTable::NotBusy:
            if (NpcPlanes::IsCurPlane(someCr, AI_PLANE_ATTACK)) {
                continue;
            }
            break;
        case TeamsTable::HpLess10:
            if (crHpProc >= 10) {
                continue;
            }
            break;
        case TeamsTable::HpLess30:
            if (crHpProc >= 30) {
                continue;
            }
            break;
        case TeamsTable::HpLess50:
            if (crHpProc >= 50) {
                continue;
            }
            break;
        case TeamsTable::IfDead:
            if (not cr.IsDead()) {
                continue;
            }
            break;
        case TeamsTable::GoodPerson:
            if (!attacker.IsControlledByPlayer || cr.Charisma < 5 || cr.Karma < 0) {
                continue;
            }
            break;
        default:
            continue;
        }

        NpcPlanes::AddAttackPlane(someCr, 0, attacker);
        helpers++;
        if (helpers >= maxHelpers) {
            break; // Enough
        }
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter steal another.
bool critter_stealing(Critter cr, Critter thief, Item item, uint count)
{
    thief.TimeoutAggressor = Game.GetFullSecond() + Time::RealMinute(1);

    if (cr.IsDead() || IS_TIMEOUT(cr.TimeoutBattle) || IS_TIMEOUT(thief.TimeoutBattle)) {
        thief.LastStealCrId = ZERO_IDENT;
        thief.StealCount = 0;
        return false;
    }

    if (cr.IsNoPvp || thief.IsNoPvp) {
        thief.Say(SAY_NETMSG, "No PvP.");
        return false;
    }

    int dir1 = cr.Dir;
    int dir2 = thief.Dir;
    int kDir = MAX(dir1, dir2) - MIN(dir1, dir2);
    if (kDir > 3) {
        kDir = 6 - kDir;
    }

    int steal = thief.SkillSteal;
    if (steal <= 0) {
        steal = 1;
    }
    int size = item.Volume;
    if (size <= 0) {
        size = 1;
    }

    // Perk pickpocket, ignore size and facing
    if (thief.PerkPickpocket != 0) {
        kDir = 0;
        size = 1;
    }

    // Count modifier
    int kCount = count / steal;
    if (kCount <= 0) {
        kCount = 1;
    }

    // Check time of stealing
    ident lastStealCrId = thief.LastStealCrId;
    uint stealCount = thief.StealCount;
    if (lastStealCrId == cr.Id && IS_TIMEOUT(thief.TimeoutStealing)) {
        steal -= steal * stealCount * 9 / 100;
    }

    // Calc
    int k = (steal - kDir * 10) / (size * kCount);
    k = CLAMP(k, 5, 95);
    bool success = !(Game.Random(1, 100) > k);

    if (success) {
        // Add experience     10,30,60,100,150,210,280,360,450,550,660,780
        const int[] stealExp = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120};

        if (lastStealCrId == cr.Id && IS_TIMEOUT(thief.TimeoutStealing)) {
            stealCount++;
            if (stealCount > 11) {
                stealCount = 11;
            }
            thief.StealCount = stealCount;
        }
        else {
            thief.LastStealCrId = cr.Id;
            thief.StealCount = 0;
        }

        thief.TimeoutStealing = STEAL_TIMEOUT(thief);
        if (!cr.IsControlledByPlayer) {
            auto stealExpCount = cr.StealExpCount.clone();
            stealExpCount.setIfNotExist(thief.Id, 0);
            if (stealExpCount[thief.Id] < 12) {
                thief.Experience += stealExp[stealCount];
                Scores::AddScore(thief, EScores::Thief, 1);
            }
            stealExpCount[thief.Id] = stealExpCount[thief.Id] + 1;
            cr.StealExpCount = stealExpCount;
        }
    }
    else {
        thief.LastStealCrId = ZERO_IDENT;
        thief.StealCount = 0;

        if (!cr.IsControlledByPlayer) {
            int thiefHp = thief.CurrentHp;
            NpcPlanes::AddAttackPlane(cr,
                                      0,
                                      thief,
                                      thiefHp < 10 || Game.Random(1, 10) > cr.Luck + 4 || cr.Charisma < 3 ? Settings.DeadHitPoints :
                                                                                                            Game.Random(thiefHp / 4, thiefHp / 2));
        }
    }

    // Доп. события
    cr.OnStealing.Fire(thief, item, count);

    Critter[] other = thief.GetCritters(true, CritterFindType::Alive);
    for (uint i = 0; i < other.length(); i++) {
        other[i].OnSomeCritterUseSkill.Fire(thief, CritterProperty::SkillSteal, cr, null, null);
        other[i].OnSomeCritterStealing.Fire(thief, cr, item, count);

        /// Event SomeCritterUseSkill(Critter critter)
        // Critter whoUse, CritterProperty skill, Critter onCritter, Item onItem, StaticItem onScenery )" deferred
    }

    return success;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter use item.
bool critter_use_item(Critter cr, Item item, Critter targetCr, Item targetItem, StaticItem targetScen, uint param)
{
    bool isPlayer = cr.IsControlledByPlayer;
    hstring pid = item.ProtoId;
    bool useOnSelf = (not valid(targetCr) && not valid(targetItem) && not valid(targetScen));

    // Holodisk
    if (useOnSelf && item.IsHolodisk) {
        Holodisk::ReadHolodisk(cr, item);
        return true;
    }

    // Radio
    if (item.IsRadio && useOnSelf) {
        if (isPlayer) {
            Radio::EditRadioSettings(cr, item);
        }
        return true;
    }

    // Book reading
    if (useOnSelf && Books::IsReadableBook(pid)) {
        Books::TryReadBook(cr, item);
        return true;
    }

    // Explosion
    if (Explode::OnUseExplode(cr, item, targetCr, targetItem, targetScen, param)) {
        return true;
    }

    // Cars
    if (valid(targetItem) && targetItem.Type == ItemType::Car && Car::UseItemOnCar(cr, targetItem, item)) {
        return true;
    }

    // Drugs
    if (item.Type == ItemType::Drug) {
        if (useOnSelf) {
            Drugs::UseDrug(cr, item);
        }
        else if (valid(targetCr)) {
            Drugs::UseDrugOn(cr, targetCr, item);
        }
        else {
            cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrUseNothing);
        }
        return true;
    }

    // Play dice
    if (pid == Content::Item::dice) {
        cr.SayMsg(SAY_EMOTE_ON_HEAD, TextPackName::Text, MsgStr::StrDiceThrow, "$result" + Game.Random(1, 6));
        return true;
    }
    if (pid == Content::Item::loaded_dice) {
        cr.SayMsg(SAY_EMOTE_ON_HEAD, TextPackName::Text, MsgStr::StrDiceThrow, "$result" + uint((item.Id.value % 6) + 1));
        return true;
    }

    // Magic ball
    if (pid == Content::Item::magic_8_ball) {
        // cr.SayMsg(SAY_EMOTE_ON_HEAD,TextPackName::Text,Game.Random(1,2)==1?MsgStr::StrMagicBallYes:MsgStr::StrMagicBallNo);
        return true;
    }

    // Cosmetic
    if (pid == Content::Item::cosmetic_case && cr.Gender == GenderType::Female) {
        cr.SayMsg(SAY_EMOTE_ON_HEAD, TextPackName::Text, MsgStr::StrCosmeticUse);
        return true;
    }

    // Cigarettes smoking
    if (pid == Content::Item::cigarettes && cr.CountItem(Content::Item::lighter) > 0) {
        cr.SayMsg(SAY_EMOTE_ON_HEAD, TextPackName::Text, MsgStr::StrCigarettesSmoke);
        return true;
    }

    // Geiger counter
    if (pid == Content::Item::geiger_counter && useOnSelf && Geiger::UseGeiger(cr, item)) {
        return true;
    }
    if (valid(targetItem) && targetItem.ProtoId == Content::Item::geiger_counter && Geiger::UseItemOnGeiger(cr, targetItem, item)) {
        return true;
    }

    // Доп. события
    if (useOnSelf) {
        Game.OnCritterUseItem.Fire(cr, item, param);
    }

    Critter[] other = cr.GetCritters(true, CritterFindType::Alive);
    for (uint i = 0; i < other.length(); i++) {
        other[i].OnSomeCritterUseItem.Fire(cr, item, targetCr, targetItem, targetScen, param);
    }

    // Take process to engine
    return false;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter use skill.
bool critter_use_skill(Critter cr, CritterProperty skill, Critter targetCr, Item targetItem, StaticItem targetScen)
{
    bool isPlayer = cr.IsControlledByPlayer;

    // Cars
    if (valid(targetItem) && targetItem.Type == ItemType::Car && Car::UseSkillOnCar(cr, targetItem, skill)) {
        return true;
    }

    // Geiger counter
    if (valid(targetItem) && targetItem.ProtoId == Content::Item::geiger_counter && Geiger::UseSkillOnGeiger(cr, targetItem, skill)) {
        return true;
    }

    // Doors or containers
    if (valid(targetItem) && (targetItem.Type == ItemType::Door || targetItem.Type == ItemType::Container) &&
        Lockers::UseSkillOnLocker(cr, targetItem, skill)) {
        return true;
    }

    switch (skill) {
    case uint(CritterProperty::SpecialSkillPickOnGround): // Pick item or scenery on ground
    {
        // Scenery
        if (valid(targetScen)) {
            if (targetScen.SceneryScript != EMPTY_HSTRING && Game.CallStaticItemFunction(cr, targetScen, null, int(skill)))
			{
				return true;
            }
			if(targetScen.Grid_ToMap != EMPTY_HSTRING)
			{
				Map map  = Game.GetMap( targetScen.Grid_ToMap, 0 );
				if( valid(map))
				{
					hstring entry_proto = (targetScen.Grid_ToMapEntry == EMPTY_HSTRING ? hstring("" + 0) : targetScen.Grid_ToMapEntry);
					auto entry = Entrance::GetEntry(map, entry_proto, 0);
					cr.TransitToMap(map, entry.HexX, entry.HexY, targetScen.Grid_ToMapDir);
					return true;
				}
			}
			if (isPlayer) {
                cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrUseNothing);
			}
            return true;
        }

        // Wanted
        if (valid(targetItem) && targetItem.ProtoId == Content::Item::wanted_sign &&
            Wanted::WantedSignSet(Game.GetItem(targetItem.Id), cr.Name, Game.Random(1000, 2000))) {
            return true;
        }
        // Explosion
        if (valid(targetItem) && targetItem.ProtoId == Content::Item::active_mine && Explode::OnUseExplode(cr, targetItem, null, null, null, 0)) {
            return true;
        }
        // Pick some item
        if (valid(targetItem)) {
            Item item = targetItem;
            if (not item.IsCanPickUp) {
                if (isPlayer) {
                    cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrUseNothing);
                }
                break;
            }

            int freeWeight = cr.CarryWeight - cr.ItemsWeight;
            if (freeWeight >= int(item.Weight * item.Count)) {
                // Pick full
                ItemMovement::MoveItem(item, item.Count, cr);
            }
            else {
                // Pick half
                if (item.Stackable && freeWeight >= int(item.Weight)) {
                    ItemMovement::MoveItem(item, freeWeight / item.Weight, cr); //TODO: возможно, неверная формула, почему здесь вес, а не количество.
                }
                // Overweight
                else {
                    cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrOverweight);
                }
            }
        }
    } break;
    case SKILL_PUT_CONT:      // Put item in container, only targetItem is valid
    case SKILL_TAKE_CONT:     // Take item from container, only targetItem is valid
    case SKILL_TAKE_ALL_CONT: // Take all items from critter or item container
        return false;         // Allow transactions
    case SKILL_LOOT_CRITTER:  // Loot critter, only targetCr is valid
        cr.Action(CritterAction::PickCritter, 0, null);
        Lockers::ShowContainer(cr, targetCr, null, TransferTypes::CritLoot);
        return true;
    case SKILL_PUSH_CRITTER: // Push critter, only targetCr is valid
        cr.Action(CritterAction::PickCritter, 2, null);
        if ((!IS_TIMEOUT(cr.TimeoutBattle) && !IS_TIMEOUT(targetCr.TimeoutBattle)) &&
            (targetCr.IsControlledByPlayer || (NpcPlanes::IsNoPlanes(targetCr) && targetCr.GetTalkingCritters().length() == 0))) {
            MoveRandom::CritterMoveRandom(targetCr);
        }
        return true;
    case CritterProperty::SkillScience: {
        // Radio
        if (valid(targetItem) && targetItem.IsRadio && targetItem.Ownership == ItemOwnership::CritterInventory && targetItem.CritterId == cr.Id) {
            if (isPlayer) {
                Radio::EditRadioSettings(cr, targetItem);
            }
            return true;
        }
        if (valid(targetScen) && targetScen.SceneryScript != EMPTY_HSTRING) {
            Game.CallStaticItemFunction(cr, targetScen, null, int(skill));
            return true;
        }
        cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrUseNothing); // Todo: "You fail to learn anything."
    } break;
    case CritterProperty::SkillRepair: {
        // Generic repair
        if (valid(targetItem) && targetItem.Ownership == ItemOwnership::CritterInventory && targetItem.Deteriorable && Repair::TryRepairItem(cr, targetItem)) {
            return true;
        }

        cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrUseNothing);
    } break;
    case CritterProperty::SkillSneak: {
        if (cr.InSneakMode) {
            cr.InSneakMode = false;
        }
        else if (not isPlayer) {
            cr.InSneakMode = true;
        }
        else {
            if (IS_TIMEOUT(cr.TimeoutSneak)) {
                cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrTimeoutSneakWait);
            }
            else {
                cr.InSneakMode = true;
            }
        }
    } break;
    case CritterProperty::SkillSteal: {
        if (valid(targetItem)) {
            cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrUseNothing);
        }
        else if (valid(targetCr)) {
            // Loot
            if (targetCr.IsDead()) {
                cr.Action(CritterAction::PickCritter, 0, null);
                Lockers::ShowContainer(cr, targetCr, null, TransferTypes::CritLoot);
            }
            // Steal
            else {
                if (isPlayer && IS_TIMEOUT(cr.TimeoutSkSteal)) {
                    cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrSkillWeariness);
                }
                else {
                    if (targetCr.IsNoSteal) {
                        cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrNoStealCritter);
                    }
                    else {
                        cr.Action(CritterAction::PickCritter, 1, null);
                        Lockers::ShowContainer(cr, targetCr, null, TransferTypes::CritSteal);
                        cr.TimeoutSkSteal = STEAL_TIMEOUT(cr);
                        cr.LastStealCrId = ZERO_IDENT;
                        cr.StealCount = 0;
                    }
                }
            }
        }
        else {
            cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrUseNothing);
        }
    } break;
    case CritterProperty::SkillFirstAid: {
        if (valid(targetItem) || valid(targetScen)) {
            cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrUseNothing);
            break;
        }

        if (not valid(targetCr)) {
            targetCr = cr;
        }
        bool is_self = (targetCr.Id == cr.Id);

        if (targetCr.IsDead()) {
            cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrSkillNoressurect);
            break;
        }

        if (targetCr.CurrentHp >= targetCr.MaxLife) {
            if (_CritIsInjured(targetCr)) {
                cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrSkillNofirstaidNeeddoctor);
            }
            else if (is_self) {
                cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrSkillNoneedFirstaid);
            }
            break;
        }

        if (isPlayer && IS_TIMEOUT(cr.TimeoutSkFirstAid)) {
            cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrSkillWeariness);
            break;
        }

        int sk = cr.SkillFirstAid;
        auto mainSlotItem = cr.GetItem(ItemProperty::CritterSlot, CritterItemSlot::Main);
        if (valid(mainSlotItem)) {
            hstring activePid = mainSlotItem.ProtoId;
            if (activePid == Content::Item::first_aid_kit) {
                sk += 25;
                if (Game.Random(0, 30) == 0) {
                    cr.DestroyItem(Content::Item::first_aid_kit, 1);
                }
            }
            else if (activePid == Content::Item::field_medic_kit) {
                sk += 50;
                if (Game.Random(0, 30) == 0) {
                    cr.DestroyItem(Content::Item::field_medic_kit, 1);
                }
            }
        }
        int mod = 11 - cr.Luck;
        mod = CLAMP(mod, 1, 10);
        int heal = Game.Random(sk / mod, sk);
        if (heal < 1) {
            heal = 1;
        }
        if (cr.PerkVampireRegeneration != 0) {
            heal += 5;
        }
        int curHp = targetCr.CurrentHp;
        int maxHp = targetCr.MaxLife;
        if (curHp + heal > maxHp) {
            heal = maxHp - curHp;
        }
        targetCr.CurrentHp += heal;

        cr.Say(SAY_NETMSG, "+" + heal);
        if (not is_self) {
            targetCr.Say(SAY_NETMSG, "+" + heal);
        }

        if (isPlayer) {
            auto firstAidCount = cr.FirstAidCount.clone();
            firstAidCount.setIfNotExist(targetCr.Id, 0);
            if (firstAidCount[targetCr.Id] < 10) {
                cr.Experience += heal * 3;
            }
            firstAidCount[targetCr.Id] = firstAidCount[targetCr.Id] + 1;
            cr.FirstAidCount = firstAidCount;

            cr.TimeoutSkFirstAid = FIRST_AID_TIMEOUT(cr);
            Scores::AddScore(cr, EScores::Doctor, 1);
        }
    } break;
    case CritterProperty::SkillDoctor: {
        if (valid(targetItem) || valid(targetScen)) {
            cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrUseNothing);
            break;
        }

        if (not valid(targetCr)) {
            targetCr = cr;
        }
        bool is_self = (targetCr.Id == cr.Id);

        if (targetCr.IsDead()) {
            cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrSkillNoressurect);
            break;
        }

        if (not _CritIsInjured(targetCr)) {
            if (targetCr.CurrentHp < targetCr.MaxLife) {
                cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrSkillNodoctorNeedfirstaid);
            }
            else if (is_self) {
                cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrSkillNoneedDoctor);
            }
            break;
        }

        if (isPlayer && IS_TIMEOUT(cr.TimeoutSkDoctor)) {
            cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrSkillWeariness);
            break;
        }

        int uninjured = 0;
        int sk = cr.SkillDoctor;
        hstring activePid = cr.GetItem(ItemProperty::CritterSlot, CritterItemSlot::Main).ProtoId;
        if (activePid == Content::Item::doctors_bag) {
            sk += 25;
            if (Game.Random(0, 30) == 0) {
                cr.DestroyItem(Content::Item::doctors_bag, 1);
            }
        }
        else if (activePid == Content::Item::paramedics_bag) {
            sk += 50;
            if (Game.Random(0, 30) == 0) {
                cr.DestroyItem(Content::Item::paramedics_bag, 1);
            }
        }

        CritterProperty[] damages = {CritterProperty::IsDamagedEye,
                                     CritterProperty::IsDamagedRightArm,
                                     CritterProperty::IsDamagedLeftArm,
                                     CritterProperty::IsDamagedRightLeg,
                                     CritterProperty::IsDamagedLeftLeg};
        for (uint i = 0; i < damages.length(); i++) {
            if (targetCr.GetAsInt(damages[i]) != 0) {
                if (sk > Game.Random(5, 95)) {
                    targetCr.SetAsInt(damages[i], 0);
                    cr.SayMsg(SAY_NETMSG, TextPackName::Game, STR_SKILL_HEAL_DMG(damages[i]));
                    uninjured++;
                }
                else {
                    cr.SayMsg(SAY_NETMSG, TextPackName::Game, STR_SKILL_NOHEAL_DMG(damages[i]));
                }
                sk /= 2;
            }
        }

        if (isPlayer) {
            if (uninjured > 0) {
                cr.Experience += uninjured * 50;
            }
            cr.TimeoutSkDoctor = DOCTOR_TIMEOUT(cr);
            Scores::AddScore(cr, EScores::Doctor, uninjured);
        }
    } break;
    case CritterProperty::SkillLockpick: {
        // Lockers processed in lockers.fos
    } break;
    case CritterProperty::SkillTraps: {
        // Explosion
        if (valid(targetItem)) {
            hstring pid = targetItem.ProtoId;
            if ((pid == Content::Item::active_dynamite || pid == Content::Item::active_plastic_explosive || pid == Content::Item::active_mine) &&
                Explode::OnUseExplode(cr, targetItem, null, null, null, 0)) {
                return true;
            }
        }

        cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrUseNothing);
    } break;
    default: {
        cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrUseNothing);
    } break;
    }

    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter reload weapon.
// If ammo is not valid than only unload.
void critter_reload_weapon(Critter cr, Item weapon, Item ammo)
{
    // Special weapons
    if (weapon.Weapon_Caliber == 0) {
        if (weapon.ProtoId == Content::Item::solar_scorcher) {
            if (IS_NIGHT(GameTime::GetHour())) {
                cr.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrSolarScorcherNoLight);
            }
            else {
                weapon.AmmoCount = weapon.Weapon_MaxAmmoCount;
            }
        }

        return;
    }

    // Other weapons
    // Unload
    if (not valid(ammo) || (weapon.AmmoCount > 0 && weapon.AmmoPid != ammo.ProtoId)) {
        if (weapon.AmmoPid != EMPTY_HSTRING) {
            Item existAmmo = cr.GetItem(weapon.AmmoPid);
            if (existAmmo == null) {
                cr.AddItem(weapon.AmmoPid, weapon.AmmoCount);
            }
            else {
                existAmmo.Count += weapon.AmmoCount;
            }
        }
        weapon.AmmoCount = 0;
    }

    // Load
    if (valid(ammo)) {
        uint count = MIN(ammo.Count, weapon.Weapon_MaxAmmoCount - weapon.AmmoCount);
        weapon.AmmoCount += count;
        weapon.AmmoPid = ammo.ProtoId;
        Game.DestroyItem(ammo, count);
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on player register/login in game or npc created/loaded.
// Default start position for players is center of global map.
void critter_init(Critter cr, bool firstTime)
{
    if (firstTime) {
        if (cr.IsControlledByPlayer) {
            // Input: 7 special, 3 tag skills, 2 traits, age, gender
            uint traitsCount = 0;
            for (uint i = 0; i < CritterPropertyGroup::Traits.length(); i++) {
                if (cr.GetAsInt(CritterPropertyGroup::Traits[i]) != 0 && traitsCount < 2) {
                    traitsCount++;
                }
                else {
                    cr.SetAsInt(CritterPropertyGroup::Traits[i], 0);
                }
            }

            if (cr.Gender != GenderType::Male && cr.Gender != GenderType::Female) {
                cr.Gender = GenderType::Male;
            }
            if (cr.Age < 14 || cr.Age > 80) {
                cr.Age = 25;
            }

            cr.StrengthBase = CLAMP(cr.StrengthBase, 1, 10);
            cr.PerceptionBase = CLAMP(cr.PerceptionBase, 1, 10);
            cr.EnduranceBase = CLAMP(cr.EnduranceBase, 1, 10);
            cr.CharismaBase = CLAMP(cr.CharismaBase, 1, 10);
            cr.IntellectBase = CLAMP(cr.IntellectBase, 1, 10);
            cr.AgilityBase = CLAMP(cr.AgilityBase, 1, 10);
            cr.LuckBase = CLAMP(cr.LuckBase, 1, 10);

            if ((cr.StrengthBase + cr.PerceptionBase + cr.EnduranceBase + cr.CharismaBase + cr.IntellectBase + cr.AgilityBase + cr.LuckBase) !=
                Settings.StartSpecialPoints) {
                cr.StrengthBase = 5;
                cr.PerceptionBase = 5;
                cr.EnduranceBase = 5;
                cr.CharismaBase = 5;
                cr.IntellectBase = 5;
                cr.AgilityBase = 5;
                cr.LuckBase = 5;
            }

            cr.EmpResistanceBase = 500;
            Holodisk::AddHolodiskInfo(cr, 42); // Journalist's research

            // Default skin
            cr.ModelNameBase = (cr.Gender == GenderType::Male ? CRTYPE_DEFAULT_M : CRTYPE_DEFAULT_F);
            Assert(cr.ModelNameBase != EMPTY_HSTRING);
            cr.ModelName = cr.ModelNameBase;
        }

        if (cr.TagSkill1 != CritterProperty::Invalid && CritterPropertyGroup::Skills.find(cr.TagSkill1) == -1) {
            cr.TagSkill1 = CritterProperty::Invalid;
        }
        if (cr.TagSkill2 != CritterProperty::Invalid && CritterPropertyGroup::Skills.find(cr.TagSkill2) == -1) {
            cr.TagSkill2 = CritterProperty::Invalid;
        }
        if (cr.TagSkill3 != CritterProperty::Invalid && CritterPropertyGroup::Skills.find(cr.TagSkill3) == -1) {
            cr.TagSkill3 = CritterProperty::Invalid;
        }

        dict<CritterProperty, int> props = {};
        for (uint i = 0; i < Game.RegProperties.length(); i++) {
            props[Game.RegProperties[i]] = cr.GetAsInt(Game.RegProperties[i]);
        }
        Parameters::CritterGenerate(props);
        for (uint i = 0; i < props.length(); i++) {
            cr.SetAsInt(props.getKey(i), props.getValue(i));
        }

        cr.CurrentHp = cr.MaxLife;
        cr.CurrentAp = cr.ActionPoints * AP_DIVIDER;

        if (cr.IsControlledByPlayer) {
            cr.ReplicationCost = 100;
            cr.ReplicationMoney = 0;
            cr.ReplicationCount = 0;
            cr.TeamId = 1;
            cr.DamageType = DamageTypes::Normal;

            Replication::SetStartLocation(cr);

            // Main quest
            if (Settings.MainStoryLineActive) {
                MainIntro::SetPlayerStoryLineLocation(cr);
            }
            else {
                Replication::SetStartLocation(cr);
            }
        }
        else {
            cr.ModelNameBase = cr.ModelName;
            if (cr.Level != 0) {
                Parameters::NpcProcessLevel(cr);
            }
            if (cr.Condition == CritterCondition::Dead) {
                cr.ReplicationTime = -1;
            }
        }
    }
    else {
        // Main quest
        if (cr.IsControlledByPlayer && Settings.MainStoryLineActive) {
            MainIntro::SetPlayerStoryLineLocation(cr);
        }
        else {
            Replication::SetStartLocation(cr);
        }

        // Current skin validation
        Item armor = cr.GetItem(ItemProperty::CritterSlot, CritterItemSlot::Armor);
        if (not valid(armor)) {
            hstring modelName = cr.ModelNameBase;
            if (modelName == EMPTY_HSTRING) {
                modelName = (cr.Gender == GenderType::Male ? CRTYPE_DEFAULT_M : CRTYPE_DEFAULT_F);
            }
            if (cr.ModelName != modelName) {
                Assert(modelName != EMPTY_HSTRING);
                cr.ModelName = modelName;
            }
        }

        // Clear timeouts if too long (happens when saves got removed)
        for (uint i = 0; i < CritterPropertyGroup::Timeouts.length(); i++) {
            if (CritterPropertyGroup::Timeouts[i] != CritterProperty::TimeoutBattle && uint(cr.GetAsInt(CritterPropertyGroup::Timeouts[i])) > MAXIMUM_TIMEOUT) {
                cr.SetAsInt(CritterPropertyGroup::Timeouts[i], 0);
            }
        }

        // Erase zero time events
        cr.RemoveTimeEvents(0);

        // TRAIT_FAST_SHOT migration, delete in future
        if (cr.IsTraitFastShot) {
            cr.IsNoAim = true;
        }
    }

    if (cr.IsControlledByPlayer) {
        if (cr.Kills.length() != Tla::MaxBodyTypes) {
            uint[] kills = cr.Kills.clone();
            kills.resize(Tla::MaxBodyTypes);
            cr.Kills = kills;
        }
        if (cr.Addictions.length() != Tla::MaxAddictions) {
            bool[] addictions = cr.Addictions.clone();
            addictions.resize(Tla::MaxAddictions);
            cr.Addictions = addictions;
        }
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on critter exit from game.
void critter_finish(Critter cr)
{
    bool toDelete = true;
    if (toDelete && cr.DeadBlockerId != ZERO_IDENT) {
        Item block = Game.GetItem(cr.DeadBlockerId);
        if (valid(block)) {
            Game.DestroyItem(block);
        }
        cr.DeadBlockerId = ZERO_IDENT;
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call every Settings.CritterIdleTick time.
void critter_idle(Critter cr)
{
    // Replication
    if (cr.IsDead() && cr.ReplicationTime >= 0 && !IS_TIMEOUT(cr.TimeoutReplication)) {
        Replication::ReplicateCritter(cr);
    }

    // Healing
    if (!IS_TIMEOUT(cr.TimeoutHealing)) {
        if (!cr.IsDead() && !cr.IsNoHeal && !IS_TIMEOUT(cr.TimeoutBattle) && cr.CurrentHp < cr.MaxLife) {
            cr.CurrentHp += cr.HealingRate * (cr.PerkVampireRegeneration != 0 ? 2 : 1);

            if (cr.CurrentHp > cr.MaxLife) {
                cr.CurrentHp = cr.MaxLife;
            }
        }

        cr.TimeoutHealing = HEALING_TIMEOUT(cr);
    }

    // Ap regeneration
    if (cr.CurrentAp < cr.ActionPoints * AP_DIVIDER) {
        uint tick = Game.GetTick();

        if (cr.ApRegenerationTick == 0) {
            cr.ApRegenerationTick = tick;
        }

        int delta = tick - cr.ApRegenerationTick;

        if (delta >= 500) {
            cr.ApRegenerationTick = tick;

            uint apRegeneration = cr.ApRegenerationTime;

            if (apRegeneration == 0) {
                apRegeneration = Settings.ApRegeneration; // 7000
            }

            uint maxAp = cr.ActionPoints * AP_DIVIDER; // 100
            cr.CurrentAp = cr.CurrentAp + maxAp * delta / apRegeneration;

            if (cr.CurrentAp > int(maxAp)) {
                cr.CurrentAp = maxAp;
            }
        }
    }

    // Look distance and sneak coef
    uint lookDist = Parameters::GetCritterLookDistance(cr);
    uint sneakCoef = Parameters::GetCritterSneakCoefficient(cr);

    if (lookDist != cr.LookDistance || sneakCoef != cr.SneakCoefficient) {
        cr.LookDistance = lookDist;
        cr.SneakCoefficient = sneakCoef;
        cr.RefreshView();
    }

    // Auto unload player critter
    if (cr.IsControlledByPlayer && cr.GetPlayer() == null && cr.GetPlayerOfflineTime() >= Settings.MinimumOfflineTime &&
        !IS_TIMEOUT(cr.TimeoutRemoveFromGame)) {
        Game.UnloadCritter(cr);
    }
}

void critter_knockout(Critter cr)
{
    if (!cr.IsControlledByPlayer) {
        NpcPlanes::DropPlanes(cr);
    }
}
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter dies.
// Killer can be null.
void critter_dead(Critter cr, Critter killer)
{
    // Move slot items to inventory
    Item hands1 = cr.GetItem(ItemProperty::CritterSlot, CritterItemSlot::Main);
    Item hands2 = cr.GetItem(ItemProperty::CritterSlot, CritterItemSlot::Secondary);
    if (hands1 !is null) {
        cr.ChangeItemSlot(hands1.Id, CritterItemSlot::Inventory);
    }
    if (hands2 !is null) {
        cr.ChangeItemSlot(hands2.Id, CritterItemSlot::Inventory);
    }

    // Move inventory items to ground
    Map map = cr.GetMap();
    if ((cr.DeadActionAnim == CritterActionAnim::DeadPulseDust || cr.DeadActionAnim == CritterActionAnim::DeadExplode) && _CritCanDropItemsOnDead(cr)) {
        // Drop all, exclude armor
        Item[] items = {};
        items.insertLast(cr.GetItems(ItemProperty::CritterSlot, CritterItemSlot::Inventory));
        items.insertLast(cr.GetItems(ItemProperty::CritterSlot, CritterItemSlot::Main));
        items.insertLast(cr.GetItems(ItemProperty::CritterSlot, CritterItemSlot::Secondary));
        if (valid(map)) {
            // Disable drop of hidden items
            for (uint i = 0; i < items.length(); i++) {
                if (items[i].IsGag) {
                    Game.DestroyItem(items[i]);
                    items[i] = null;
                }
                else if (items[i].IsHidden) {
                    items[i] = null;
                }
            }
            ItemMovement::MoveItems(items, map, cr.HexX, cr.HexY);
        }
        else {
            Game.DestroyItems(items);
        }
    }

    // Mob drops
    hstring npcPid = cr.ProtoId;
    hstring dropPid;
    if (npcPid == Content::Critter::GoldenGecko || npcPid == Content::Critter::ToughGoldenGecko) {
        if (valid(killer) && killer.PerkGeckoSkinning != 0) {
            dropPid = Content::Item::golden_gecko_pelt;
        }
    }
    else if (npcPid == Content::Critter::SmallSilverGecko || npcPid == Content::Critter::ToughSilverGecko) {
        if (valid(killer) && killer.PerkGeckoSkinning != 0) {
            dropPid = Content::Item::gecko_pelt;
        }
    }
    else if (npcPid == Content::Critter::SmallRadscorpion || npcPid == Content::Critter::SmallRadscorpion2 || npcPid == Content::Critter::LargeRadscorpion ||
             npcPid == Content::Critter::LargeRadscorpion2 || npcPid == Content::Critter::LargeRadscorpion3) {
        dropPid = Content::Item::scorpion_tail;
    }
    else if (npcPid == Content::Critter::Brahmin || npcPid == Content::Critter::Brahmin2 || npcPid == Content::Critter::Brahmin3 ||
             npcPid == Content::Critter::WeakBrahmin || npcPid == Content::Critter::WildBrahmin) {
        if (valid(killer) && killer.PerkGeckoSkinning != 0) {
            dropPid = Content::Item::brahmin_skin;
        }
    }
    else if (npcPid == Content::Critter::GiantBeetle || npcPid == Content::Critter::GiantBeetle_2) {
        if (Game.Random(1, 3) == 3) {
            dropPid = Content::Item::radscorpion_parts;
        }
    }

    if (dropPid != EMPTY_HSTRING && cr.CountItem(dropPid) == 0) {
        cr.AddItem(dropPid, 1);
    }

    // Karma, temporary
    if (valid(killer) && killer.IsControlledByPlayer) {
        int karmaBefore = killer.Karma;
        uint team = cr.TeamId;
        if (team == Teams::Poorman) {
            killer.Karma -= 10;
        }
        else if (team == Teams::Narcoman) {
            killer.Karma += 10;
        }
        else if (team == Teams::Citizen) {
            killer.Karma -= 10;
        }
        else if (team == Teams::Guard) {
            killer.Karma -= 10;
        }
        else if (team == Teams::PrivateGuard) {
            killer.Karma -= 10;
        }
        else if (team == Teams::Trader) {
            killer.Karma -= 10;
        }
        else if (team == Teams::Bandit) {
            killer.Karma += 10;
        }
        else if (team == Teams::CasinoPlayer) {
            killer.Karma -= 10;
        }
        else if (team == Teams::CityElite) {
            killer.Karma -= 30;
        }
        else if (team == Teams::QuestNpc) {
            killer.Karma -= 30;
        }
        else if (team == Teams::Police) {
            killer.Karma -= 10;
        }
        else if (team == Teams::Slaver) {
            killer.Karma += 10;
        }
        else if (team == Teams::Slave) {
            killer.Karma -= 10;
        }
        else if (team == Teams::Trapper) {
            killer.Karma -= 10;
        }

        if (cr.BodyType == BodyTypes::Children) {
            killer.KarmaPerkChildkiller += 1;
        }

        TownSupply::CallTownSupply(cr, killer); // Town supply call
    }

    Replication::SetReplicationTime(cr);
    if (!cr.IsControlledByPlayer) {
        NpcPlanes::DropPlanes(cr); // Delete all planes
    }
    if (valid(map) && cr.IsNoFlatten) {
        Item blocker = map.AddItem(cr.HexX, cr.HexY, Content::Item::unvisible_block, 1);
        if (valid(blocker)) {
            cr.DeadBlockerId = blocker.Id;
        }
    }
    Hunter::OnCritterKilled(cr, killer);

    // Доп. события
    Critter[] other = cr.GetCritters(true, CritterFindType::Alive);
    for (uint i = 0; i < other.length(); i++) {
        other[i].OnSomeCritterDead.Fire(cr, killer);
    }

    if (valid(map)) {
        map.OnCritterDead.Fire(cr, killer);
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter reswapned.
void critter_respawn(Critter cr)
{
    if (cr.DeadBlockerId != ZERO_IDENT) {
        Item block = Game.GetItem(cr.DeadBlockerId);
        if (valid(block)) {
            Game.DestroyItem(block);
        }
        cr.DeadBlockerId = ZERO_IDENT;
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter in to map.
void map_critter_in(Map map, Critter cr)
{
    map.OnCritterIn.Fire(cr);

    cr.TimeoutTransfer = TRANSFER_TIMEOUT(cr);

    NoPvpMaps::OnCitterMapIn(cr, map);

    if (cr.IsControlledByPlayer) {
        GameEventCaches::PlaceLoot2Container(map, cr);
    }

    if (!cr.IsControlledByPlayer && cr.HomeMapId == ZERO_IDENT) {
        cr.HomeMapId = map.Id;
        cr.HomeMapPid = map.ProtoId;
        cr.HomeHexX = cr.HexX;
        cr.HomeHexY = cr.HexY;
        cr.HomeDir = cr.Dir;
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter out from map.
void map_critter_out(Map map, Critter cr)
{
    map.OnCritterOut.Fire(cr);

    cr.TimeoutBattle = 0;

    NoPvpMaps::OnCritterMapOut(cr, map);

    cr.MapLeaveHexX = cr.HexX;
    cr.MapLeaveHexY = cr.HexY;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something player votes for another.
// Already checked valid positions and timeout.
void karma_voting(Critter crFrom, Critter crTo, bool valUp)
{
    // Players karma system (not used)
    crTo.PlayerKarma += (valUp ? int(5) : -10);
    crFrom.TimeoutKarmaVoting = Game.GetFullSecond() + Time::RealHour(4); // 4 hours
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine visibility of critters.
// To start working set flag LOOK_CHECK_SCRIPT to Settings.LookChecks global var.
// Return true to allow see one critter another, false to disallow.
// Note: CRITTER_EVENT_SHOW_CRITTER_X, CRITTER_EVENT_HIDE_CRITTER_X is not processed.
bool check_look(Map map, Critter critter, Critter target)
{
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine visibility of items with ITEM_TRAP flag.
// To start working set flag LOOK_CHECK_SCRIPT to Settings.LookChecks global var.
bool check_trap_look(Map map, Critter critter, Item item)
{
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on barter transaction.
// Return false to cancel transaction.
bool items_barter(Item[] saleItems, uint[] saleItemsCount, Item[] buyItems, uint[] buyItemsCount, Critter player, Critter npc)
{
    if (npc.IsBarterOnlyCash) {
        for (uint i = 0, j = saleItems.length(); i < j; i++) {
            Item item = saleItems[i];
            if (valid(item) && item.ProtoId != Content::Item::bottle_caps) {
                npc.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrBarterOnlyCash);
                npc.SayMsg(SAY_DIALOG, TextPackName::Game, MsgStr::StrBarterOnlyCash);
                return false;
            }
        }
    }

    if (!LimitedBarter::BarterAllowed(npc.Id, buyItems, saleItems)) {
        npc.SayMsg(SAY_NETMSG, TextPackName::Game, MsgStr::StrBarterItemNotAllowed);
        return false;
    }

    return true;
}

// Call on player try register
// Return true to allow, false to disallow

bool player_registration(Player player, string name, TextPackName& textMsg, uint& strNum, string& lexems)
{
    Game.Log("player register. Name: " + name);
    uint nameError = Parameters::CheckPlayerName(name);
    if (nameError != 0) {
        textMsg = TextPackName::Game;
        strNum = nameError;
        Game.Log("player register failed error=" + nameError);
        return false;
    }
    Game.Log("player register success");
    return true;
}

// Call on player try login
// Return true to allow, false to disallow
bool player_login(Player player, string name, ident id, TextPackName& textMsg, uint& strNum, string& lexems)
{
    if (Settings.PermanentDeath > 0 && Replication::IsPermanentDeath(id)) {
        textMsg = TextPackName::Game;
        strNum = MsgStr::StrNetPermanentDeath;
        return false;
    }
    return true;
}

void OnPlayerEnter(Player player)
{
    Critter cr = player.GetControlledCritter();

    if (cr == null) {
        if (player.MainCritterId == ZERO_IDENT) {
            cr = Game.CreateCritter(Content::Critter::Player, true);

            player.MainCritterId = cr.Id;
        }
        else {
            cr = Game.GetCritter(player.MainCritterId);

            if (cr == null) {
                cr = Game.LoadCritter(player.MainCritterId, true);
            }
        }

        player.SwitchCritter(cr);
    }
}

// Call on player try change access
// Return true to allow, false to disallow
bool player_getaccess(Player player, int access, string& password)
{
    Game.Log("Access changed for player " + player.Name + ", from " + player.GetAccess() + " to " + access + ".");
    return true;
}

bool player_allowcommand(Player player, string adminPanel, uint8 command)
{
    if (adminPanel.isEmpty()) {
        return true;
    }

    switch (command) {
    // ACCESS_CLIENT
    case COMMAND_CHANGE_PASSWORD:
    case COMMAND_DELETE_ACCOUNT:
    case COMMAND_EXIT:
    case COMMAND_GETACCESS:
    case COMMAND_MYINFO:
        return true;
    // ACCESS_TESTER
    case COMMAND_DROP_UID:
    case COMMAND_PARAM:
    case COMMAND_TOGLOBAL:
        if (player.GetAccess() >= ACCESS_TESTER) {
            return true;
        }
        break;
    // ACCESS_MODER
    case COMMAND_ADDITEM:
    case COMMAND_ADDITEM_SELF:
    case COMMAND_ADDLOCATION:
    case COMMAND_ADDNPC:
    case COMMAND_CHECKVAR:
    case COMMAND_CRITID:
    case COMMAND_DISCONCRIT:
    case COMMAND_GAMEINFO:
    case COMMAND_KILLCRIT:
    case COMMAND_MOVECRIT:
    case COMMAND_RESPAWN:
    case COMMAND_SETVAR:
        if (player.GetAccess() >= ACCESS_MODER) {
            return true;
        }
        break;
    // ACCESS_ADMIN
    case COMMAND_RELOAD_PROTOS:
    case COMMAND_LOADDIALOG:
    // case COMMAND_LOADSCRIPT: OBSOLET? :( 646 revision
    case COMMAND_LOG:
    case COMMAND_RELOAD_CLIENT_SCRIPTS:
    case COMMAND_RELOADAI:
    case COMMAND_RELOADDIALOGS:
    case COMMAND_RELOADSCRIPTS:
    case COMMAND_RELOADTEXTS:
    case COMMAND_REGENMAP:
    case COMMAND_RUNSCRIPT:
    case COMMAND_SETTIME:
        if (player.GetAccess() == ACCESS_ADMIN) {
            return true;
        }
        break;
    // Unknown command
    default:
        player.GetControlledCritter().Say(SAY_NETMSG, "Unknown command.");
        return false;
    }

    player.GetControlledCritter().Say(SAY_NETMSG, "Access denied.");
    return false;
}

bool OnPlayerCheckMove(Player player, Critter cr, uint& speed)
{
    Player crOwner = cr.GetPlayer();
    if (crOwner == null || crOwner.Id != player.Id) {
        return false;
    }

    if (speed == 0) {
        return true;
    }

    if (cr.IsNoMove) {
        return false;
    }

    /*
                if (!Settings.RunOnCombat && IS_TIMEOUT(chosen.TimeoutBattle))
                isRun = false;
            else if (!Settings.RunOnTransfer && IS_TIMEOUT(chosen.TimeoutTransfer))
                isRun = false;
            else if (chosen.IsDamagedRightLeg || chosen.IsDamagedLeftLeg || chosen.IsOverweight)
                isRun = false;
            else if (chosen.IsNoRun)
                isRun = false;
    */

    uint walkSpeed = cr.WalkSpeed;
    uint maxSpeed = cr.IsNoRun ? walkSpeed : walkSpeed * 2;
    if (maxSpeed == 0) {
        return false;
    }

    if (speed > maxSpeed) {
        speed = maxSpeed;
    }
    if (speed < maxSpeed && speed != walkSpeed) {
        speed = walkSpeed;
    }

    if (speed > walkSpeed && cr.InSneakMode) {
        cr.InSneakMode = false;
    }

    return true;
}

bool OnPlayerCheckDir(Player player, Critter cr, int16& dirAngle)
{
    Player crOwner = cr.GetPlayer();
    if (crOwner == null || crOwner.Id != player.Id) {
        return false;
    }

    dirAngle = Game.DirToAngle(Game.AngleToDir(dirAngle));

    return true;
}

void OnCritterTalk(Critter cr, Critter trader, bool begin, uint talkers)
{
    cr.InSneakMode = false;
}

void OnCritterBarter(Critter cr, Critter trader, bool begin, uint barterCount)
{
    cr.InSneakMode = false;
}
