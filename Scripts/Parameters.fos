namespace Parameters
{

#if SERVER || CLIENT

// Author: cvet

///@ RemoteCall Server ProcessSkillsUp(any[] params)
///@ RemoteCall Server ProcessPerkUp(int perkIndex)

void ModuleInit()
{
    SetPropertyGetter(CritterProperty::Strength, Parameters::CritterGetStrength);
    SetPropertyGetter(CritterProperty::Perception, Parameters::CritterGetPerception);
    SetPropertyGetter(CritterProperty::Endurance, Parameters::CritterGetEndurance);
    SetPropertyGetter(CritterProperty::Charisma, Parameters::CritterGetCharisma);
    SetPropertyGetter(CritterProperty::Intellect, Parameters::CritterGetIntellegence);
    SetPropertyGetter(CritterProperty::Agility, Parameters::CritterGetAgility);
    SetPropertyGetter(CritterProperty::Luck, Parameters::CritterGetLuck);
    SetPropertyGetter(CritterProperty::IsNoMove, Parameters::CritterGetIsNoMove);
    SetPropertyGetter(CritterProperty::IsNoRun, Parameters::CritterGetIsNoRun);
    SetPropertyGetter(CritterProperty::WalkSpeed, Parameters::CritterGetWalkSpeed);
    SetPropertyGetter(CritterProperty::MaxLife, Parameters::CritterGetMaxLife);
    SetPropertyGetter(CritterProperty::ActionPoints, Parameters::CritterGetActionPoints);
    SetPropertyGetter(CritterProperty::IsOverweight, Parameters::CritterGetIsOverweight);
    SetPropertyGetter(CritterProperty::CarryWeight, Parameters::CritterGetCarryWeight);
    SetPropertyGetter(CritterProperty::MeleeDamage, Parameters::CritterGetMeleeDamage);
    SetPropertyGetter(CritterProperty::Sequence, Parameters::CritterGetSequence);
    SetPropertyGetter(CritterProperty::HealingRate, Parameters::CritterGetHealingRate);
    SetPropertyGetter(CritterProperty::CriticalChance, Parameters::CritterGetCriticalChance);
    SetPropertyGetter(CritterProperty::MaxCritical, Parameters::CritterGetMaxCritical);
    SetPropertyGetter(CritterProperty::ArmorClass, Parameters::CritterGetArmorClass);
    SetPropertyGetter(CritterProperty::DamageResistance, Parameters::CritterGetDamageResistance);
    SetPropertyGetter(CritterProperty::NormalResistance, Parameters::CritterGetNormalResistance);
    SetPropertyGetter(CritterProperty::PoisonResistance, Parameters::CritterGetPoisonResistance);
    SetPropertyGetter(CritterProperty::RadiationResistance, Parameters::CritterGetRadiationResistance);
    SetPropertyGetter(CritterProperty::DamageThreshold, Parameters::CritterGetDamageThreshold);
    SetPropertyGetter(CritterProperty::IsInjured, Parameters::CritterGetIsInjured);
    SetPropertyGetter(CritterProperty::IsAddicted, Parameters::CritterGetIsAddicted);
    SetPropertyGetter(CritterProperty::TagSkills, Parameters::CritterGetTagSkills);
    SetPropertyGetter(CritterProperty::CrTypeAlias, CritterTypes::CritterGetCrTypeAlias);
    SetPropertyGetter(CritterProperty::ItemsWeight, Parameters::CritterGetItemsWeight);

    AddPropertySetter(CritterProperty::HandsProtoItemId, Parameters::CritterSetHandsProtoItemId);
    AddPropertySetter(CritterProperty::HandsItemMode, Parameters::CritterSetHandsItemMode);

#if SERVER
    SetPropertyGetter(CritterProperty::BarterCoefficient, Parameters::CritterGetBarterCoefficient);
    AddPropertySetter(CritterProperty::Experience, Parameters::CritterSetExperience);
    AddPropertyDeferredSetter(CritterProperty::InSneakMode, Parameters::CritterSetHide);
    AddPropertyDeferredSetter(CritterProperty::IsTraitFastShot, Parameters::CritterSetFastShot);
    for (uint i = 0; i < CritterPropertyGroup::Perks.length(); i++) {
        AddPropertySetter(CritterPropertyGroup::Perks[i], Parameters::CritterSetPerks);
    }
    AddPropertyDeferredSetter(CritterProperty::KnownLocations, Parameters::CritterSetKnownLocations);
#endif

#if CLIENT
    AddPropertySetter(CritterProperty::Level, Parameters::CritterSetLevel);
    AddPropertySetter(CritterProperty::Experience, Parameters::CritterSetExperience);
    for (uint i = 0; i < CritterPropertyGroup::Quests.length(); i++) {
        AddPropertySetter(CritterPropertyGroup::Quests[i], Parameters::CritterSetPropertyQuests);
    }
#endif
}

#if !CLIENT
void ProcessSkillsUp(Player player, any[] params)
{
    if (params.length() % 2 > 0 || params.length() / 2 > CritterPropertyGroup::Skills.length()) {
        Game.Log("Wrong ProcessSkillsUp params length: " + params.length());
        return;
    }
    Critter cr = player.GetControlledCritter();
    for (uint i = 0; i < params.length(); i += 2) {
        CritterProperty skill = CritterProperty(int(params[i]));
        int skillPoints = params[i + 1];
        while (skillPoints > 0) {
            int skillValue = cr.GetAsInt(skill);
            if (skillValue >= Settings.SkillMaxValue) {
                break;
            }
            int needPoints = 1;
            if (skillValue > Settings.SkillModAdd6) {
                needPoints = 6;
            }
            else if (skillValue > Settings.SkillModAdd5) {
                needPoints = 5;
            }
            else if (skillValue > Settings.SkillModAdd4) {
                needPoints = 4;
            }
            else if (skillValue > Settings.SkillModAdd3) {
                needPoints = 3;
            }
            else if (skillValue > Settings.SkillModAdd2) {
                needPoints = 2;
            }

            if (cr.UnspentSkillPoints < needPoints) {
                break;
            }

            skillValue++;

            if (IsTagSkill(cr, skill) && skillValue < Settings.SkillMaxValue) {
                skillValue++;
            }
            cr.UnspentSkillPoints = cr.UnspentSkillPoints - needPoints;
            cr.SetAsInt(skill, skillValue);
            skillPoints--;
        }
    }
}

bool IsTagSkill(Critter cr, CritterProperty prop)
{
    return cr.TagSkill1 == prop || cr.TagSkill2 == prop || cr.TagSkill3 == prop;
}

void ProcessPerkUp(Player player, int perkIndex)
{
    Critter cr = player.GetControlledCritter();
    if (cr.UnspentPerks > 0) {
        CritterProperty perk = CritterProperty(perkIndex);
        if (Perks::PerkCheck(cr, perk)) {
            cr.UnspentPerks = cr.UnspentPerks - 1;
            cr.SetAsInt(perk, cr.GetAsInt(perk) + 1);
        }
    }
}

void CritterSetExperience(Critter cr, CritterProperty prop, int& newValue)
{
    if (cr.Level >= int(Settings.LevelCap) && not Settings.LevelCapAddExperience) {
        newValue = cr.Experience;
        return;
    }

    int exp = newValue - cr.Experience;
    if (exp > 0) {
        // SwiftLearner perk
        exp += exp * (cr.PerkSwiftLearner * 5) / 100; // SwiftLearner perk

        // Process new experience
        if (cr.Level < int(Settings.LevelCap)) {
            Game.StartTimeEvent(ZERO_TIMESPAN, UpdateExperienceLevel, cr.Id);
        }
    }
}

void UpdateExperienceLevel(any crId)
{
    Critter cr = Game.GetCritter(crId);
    if (cr is null) {
        return;
    }

    while (cr.Level < int(Settings.LevelCap) && cr.Experience >= NextLevelNeedExp(cr)) {
        cr.Level += 1;

        // Skill points
        cr.UnspentSkillPoints += 5 + cr.IntellectBase * 2;

        // Skilled trait
        if (cr.IsTraitSkilled) {
            cr.UnspentSkillPoints += 5;
        }

        // Educated perk
        cr.UnspentSkillPoints += cr.PerkEducated * 2;

        // Clamp skill points
        if (cr.UnspentSkillPoints > 99) {
            cr.UnspentSkillPoints = 99;
        }

        // Add max hp
        if (Settings.MaxLifeLevelSoftCap == 0 || uint(cr.Level) <= Settings.MaxLifeLevelSoftCap) {
            cr.MaxLifeBase += 2 + cr.EnduranceBase / 2 + cr.PerkLifegiver * 4;
        }

        // Add perk
        if ((cr.Level % (cr.IsTraitSkilled ? 4 : 3)) == 0) {
            cr.UnspentPerks = 1;
        }
    }
}

void CritterSetPerks(Critter cr, CritterProperty perk, uint8& newValue)
{
    uint8 curValue = cr.GetAsInt(perk);
    any[] values = {cr.Id, perk, MAX(newValue, curValue) - MIN(newValue, curValue), newValue > curValue ? 1 : 0};
    DoPerkUpDown(values);
    // Game.StartTimeEvent( 0, DoPerkUpDown, array< uint > = { cr.Id, perk, MAX( newValue, curValue ) - MIN( newValue, curValue ), newValue > curValue ? 1 : 0 } );
}

void DoPerkUpDown(any[] values)
{
    Critter cr = Game.GetCritter(values[0]);
    if (cr is null) {
        return;
    }
    CritterProperty perk = CritterProperty(int(values[1]));
    // target.GetAsInt( CritterProperty( stat ) )
    uint count = values[2];
    bool up = values[3] != 0;
    for (uint i = 0; i < count; i++) {
        if (up) {
            Perks::PerkUp(cr, perk);
        }
        else {
            Perks::PerkDown(cr, perk);
        }
    }
}

void CritterSetHide(Critter cr)
{
    cr.RefreshView();
}

void CritterSetFastShot(Critter cr)
{
    cr.IsNoAim = cr.IsTraitFastShot;
}

void CritterSetKnownLocations(Critter cr)
{
    ident[] knownLoc = cr.KnownLocations.clone();
    hstring[] knownLocPid = {};
    for (uint i = 0; i < knownLoc.length(); i++) {
        Location loc = Game.GetLocation(knownLoc[i]);
        if (loc !is null) {
            knownLocPid.insertLast(loc.ProtoId);
        }
    }
    cr.KnownLocProtoId = knownLocPid;
}

int NextLevelNeedExp(Critter cr)
{
    int level = cr.Level;
    return NUMERICAL_NUMBER(level) * 1000;
}
#endif

#if CLIENT
void CritterSetPropertyQuests(Critter cr, CritterProperty prop)
{
    uint str = hstring("" + prop).uhash + cr.GetAsInt(prop);
    if (Game.IsTextPresent(TextPackName::Quest, str)) {
        Game.Message(Game.GetText(TextPackName::Quest, str));
    }
}

void CritterSetLevel(Critter cr, CritterProperty, int& newValue)
{
    if (newValue > cr.Level) {
        Game.PlaySound("LEVELUP.ACM");
        Game.Message(TextPackName::Game, MsgStr::StrGainLevelup);
        ChosenTabs::SetChosenTabLevelUp(true);
    }
}

void CritterSetExperience(Critter cr, CritterProperty, int& newValue)
{
    if (newValue > cr.Experience) {
        Game.Message(Game.ReplaceText(Game.GetText(TextPackName::Game, MsgStr::StrGainExperience), "VALUE", newValue - cr.Experience));
    }
}

void CritterSetUnspentPerks(Critter cr)
{
    if (cr.UnspentPerks > 0 && Gui::IsScreenActive(GuiScreen::Character)) {
        Gui::ShowScreen(GuiScreen::Perk);
    }
}
#endif

// Parameters generation
// For server and client
// Both generation need be equal
// Input for player: 7 special, 3 tag skills, 2 traits, age, gender
// Imput for npc: data from prototype
void CritterGenerate(dict<CritterProperty, int> props)
{
    props.setIfNotExist(CritterProperty::StrengthBase, 0);
    props.setIfNotExist(CritterProperty::PerceptionBase, 0);
    props.setIfNotExist(CritterProperty::EnduranceBase, 0);
    props.setIfNotExist(CritterProperty::CharismaBase, 0);
    props.setIfNotExist(CritterProperty::IntellectBase, 0);
    props.setIfNotExist(CritterProperty::AgilityBase, 0);
    props.setIfNotExist(CritterProperty::LuckBase, 0);
    props.setIfNotExist(CritterProperty::HealingRateBase, 0);
    props.setIfNotExist(CritterProperty::ActionPointsBase, 0);
    props.setIfNotExist(CritterProperty::ArmorClassBase, 0);
    props.setIfNotExist(CritterProperty::SequenceBase, 0);
    props.setIfNotExist(CritterProperty::MeleeDamageBase, 0);
    props.setIfNotExist(CritterProperty::CriticalChanceBase, 0);
    props.setIfNotExist(CritterProperty::MaxCriticalBase, 0);
    props.setIfNotExist(CritterProperty::IsNoAim, 0);
    props.setIfNotExist(CritterProperty::MaxLifeBase, 0);
    props.setIfNotExist(CritterProperty::CarryWeightBase, 0);
    props.setIfNotExist(CritterProperty::CurrentAp, 0);
    props.setIfNotExist(CritterProperty::CurrentHp, 0);
    props.setIfNotExist(CritterProperty::Level, 0);
    props.setIfNotExist(CritterProperty::TagSkill1, CritterProperty::Invalid);
    props.setIfNotExist(CritterProperty::TagSkill2, CritterProperty::Invalid);
    props.setIfNotExist(CritterProperty::TagSkill3, CritterProperty::Invalid);
    for (uint i = 0; i < CritterPropertyGroup::Skills.length(); i++) {
        props.setIfNotExist(CritterPropertyGroup::Skills[i], 0);
    }
    for (uint i = 0; i < CritterPropertyGroup::Perks.length(); i++) {
        props.setIfNotExist(CritterPropertyGroup::Perks[i], 0);
    }
    for (uint i = 0; i < CritterPropertyGroup::Traits.length(); i++) {
        props.setIfNotExist(CritterPropertyGroup::Traits[i], 0);
    }
    for (uint i = 0; i < CritterPropertyGroup::ResistsBase.length(); i++) {
        props.setIfNotExist(CritterPropertyGroup::ResistsBase[i], 0);
    }
    for (uint i = 0; i < CritterPropertyGroup::ThresholdsBase.length(); i++) {
        props.setIfNotExist(CritterPropertyGroup::ThresholdsBase[i], 0);
    }

    if (props[CritterProperty::Level] <= 0) {
        props[CritterProperty::Level] = 1;
    }

    if (props[CritterProperty::IsTraitSmallFrame] != 0) {
        props[CritterProperty::AgilityBase] = props[CritterProperty::AgilityBase] + 1;
    }
    if (props[CritterProperty::IsTraitBruiser] != 0) {
        props[CritterProperty::StrengthBase] = props[CritterProperty::StrengthBase] + 2;
    }
    if (props[CritterProperty::IsTraitGoodNatured] != 0) {
        props[CritterProperty::SkillFirstAid] = props[CritterProperty::SkillFirstAid] + 15;
        props[CritterProperty::SkillDoctor] = props[CritterProperty::SkillDoctor] + 15;
        props[CritterProperty::SkillSpeech] = props[CritterProperty::SkillSpeech] + 15;
        props[CritterProperty::SkillBarter] = props[CritterProperty::SkillBarter] + 15;
        props[CritterProperty::SkillSmallGuns] = props[CritterProperty::SkillSmallGuns] - 10;
        props[CritterProperty::SkillBigGuns] = props[CritterProperty::SkillBigGuns] - 10;
        props[CritterProperty::SkillEnergyWeapons] = props[CritterProperty::SkillEnergyWeapons] - 10;
        props[CritterProperty::SkillUnarmed] = props[CritterProperty::SkillUnarmed] - 10;
        props[CritterProperty::SkillMeleeWeapons] = props[CritterProperty::SkillMeleeWeapons] - 10;
        props[CritterProperty::SkillThrowing] = props[CritterProperty::SkillThrowing] - 10;
    }

    props[CritterProperty::SkillSmallGuns] = props[CritterProperty::SkillSmallGuns] + (5 + 4 * props[CritterProperty::AgilityBase]);
    props[CritterProperty::SkillBigGuns] = props[CritterProperty::SkillBigGuns] + (0 + 2 * props[CritterProperty::AgilityBase]);
    props[CritterProperty::SkillEnergyWeapons] = props[CritterProperty::SkillEnergyWeapons] + (0 + 2 * props[CritterProperty::AgilityBase]);
    props[CritterProperty::SkillUnarmed] =
        props[CritterProperty::SkillUnarmed] + (30 + 2 * (props[CritterProperty::AgilityBase] + props[CritterProperty::StrengthBase]));
    props[CritterProperty::SkillMeleeWeapons] =
        props[CritterProperty::SkillMeleeWeapons] + (20 + 2 * (props[CritterProperty::AgilityBase] + props[CritterProperty::StrengthBase]));
    props[CritterProperty::SkillThrowing] = props[CritterProperty::SkillThrowing] + (0 + 4 * props[CritterProperty::AgilityBase]);
    props[CritterProperty::SkillFirstAid] =
        props[CritterProperty::SkillFirstAid] + (0 + 2 * (props[CritterProperty::PerceptionBase] + props[CritterProperty::IntellectBase]));
    props[CritterProperty::SkillDoctor] =
        props[CritterProperty::SkillDoctor] + (5 + props[CritterProperty::PerceptionBase] + props[CritterProperty::IntellectBase]);
    props[CritterProperty::SkillSneak] = props[CritterProperty::SkillSneak] + (5 + 3 * props[CritterProperty::AgilityBase]);
    props[CritterProperty::SkillLockpick] =
        props[CritterProperty::SkillLockpick] + (10 + props[CritterProperty::PerceptionBase] + props[CritterProperty::AgilityBase]);
    props[CritterProperty::SkillSteal] = props[CritterProperty::SkillSteal] + (0 + 3 * props[CritterProperty::AgilityBase]);
    props[CritterProperty::SkillTraps] =
        props[CritterProperty::SkillTraps] + (10 + props[CritterProperty::PerceptionBase] + props[CritterProperty::AgilityBase]);
    props[CritterProperty::SkillScience] = props[CritterProperty::SkillScience] + (0 + 4 * props[CritterProperty::IntellectBase]);
    props[CritterProperty::SkillRepair] = props[CritterProperty::SkillRepair] + (0 + 3 * props[CritterProperty::IntellectBase]);
    props[CritterProperty::SkillSpeech] = props[CritterProperty::SkillSpeech] + (0 + 5 * props[CritterProperty::CharismaBase]);
    props[CritterProperty::SkillBarter] = props[CritterProperty::SkillBarter] + (0 + 4 * props[CritterProperty::CharismaBase]);
    props[CritterProperty::SkillGambling] = props[CritterProperty::SkillGambling] + (0 + 5 * props[CritterProperty::LuckBase]);
    props[CritterProperty::SkillOutdoorsman] =
        props[CritterProperty::SkillOutdoorsman] + (0 + 2 * (props[CritterProperty::EnduranceBase] + props[CritterProperty::IntellectBase]));

    if (props[CritterProperty::TagSkill1] != CritterProperty::Invalid) {
        props[CritterProperty(props[CritterProperty::TagSkill1])] = props[CritterProperty(props[CritterProperty::TagSkill1])] + 20;
    }
    if (props[CritterProperty::TagSkill2] != CritterProperty::Invalid) {
        props[CritterProperty(props[CritterProperty::TagSkill2])] = props[CritterProperty(props[CritterProperty::TagSkill2])] + 20;
    }
    if (props[CritterProperty::TagSkill3] != CritterProperty::Invalid) {
        props[CritterProperty(props[CritterProperty::TagSkill3])] = props[CritterProperty(props[CritterProperty::TagSkill3])] + 20;
    }

    if (props[CritterProperty::IsTraitFastMetabolism] != 0) {
        props[CritterProperty::RadiationResistanceBase] = props[CritterProperty::RadiationResistanceBase] - props[CritterProperty::EnduranceBase] * 2;
        props[CritterProperty::PoisonResistanceBase] = props[CritterProperty::PoisonResistanceBase] - props[CritterProperty::EnduranceBase] * 5;
        props[CritterProperty::HealingRateBase] = props[CritterProperty::HealingRateBase] + 2;
    }
    if (props[CritterProperty::IsTraitBruiser] != 0) {
        props[CritterProperty::ActionPointsBase] = props[CritterProperty::ActionPointsBase] - 2;
    }
    if (props[CritterProperty::IsTraitKamikaze] != 0) {
        props[CritterProperty::ArmorClassBase] = props[CritterProperty::ArmorClassBase] - props[CritterProperty::AgilityBase];
        props[CritterProperty::SequenceBase] = props[CritterProperty::SequenceBase] + 5;
    }
    if (props[CritterProperty::IsTraitHeavyHanded] != 0) {
        props[CritterProperty::MeleeDamageBase] = props[CritterProperty::MeleeDamageBase] + 4;
    }
    if (props[CritterProperty::IsTraitFinesse] != 0) {
        props[CritterProperty::CriticalChanceBase] = props[CritterProperty::CriticalChanceBase] + 10;
    }
    if (props[CritterProperty::IsTraitHeavyHanded] != 0) {
        props[CritterProperty::MaxCriticalBase] = props[CritterProperty::MaxCriticalBase] - 30;
    }
    if (props[CritterProperty::IsTraitFastShot] != 0) {
        props[CritterProperty::IsNoAim] = 1;
    }

#if CLIENT
    // Runtime calculations, only for client registration
    props[CritterProperty::ArmorClassBase] = props[CritterProperty::ArmorClassBase] + (props[CritterProperty::AgilityBase]);
    props[CritterProperty::MaxLifeBase] =
        props[CritterProperty::MaxLifeBase] + (props[CritterProperty::StrengthBase] + props[CritterProperty::EnduranceBase] * 2);
    props[CritterProperty::ActionPointsBase] = props[CritterProperty::ActionPointsBase] + (props[CritterProperty::AgilityBase] / 2);
    props[CritterProperty::CarryWeightBase] = props[CritterProperty::CarryWeightBase] +
                                              (LBS_TO_GRAMM(25 + props[CritterProperty::StrengthBase] * (25 - props[CritterProperty::IsTraitSmallFrame] * 10)));
    props[CritterProperty::MeleeDamageBase] =
        props[CritterProperty::MeleeDamageBase] + ((props[CritterProperty::StrengthBase] > 6 ? props[CritterProperty::StrengthBase] - 5 : 1));
    props[CritterProperty::PoisonResistanceBase] = props[CritterProperty::PoisonResistanceBase] + (props[CritterProperty::EnduranceBase] * 5);
    props[CritterProperty::RadiationResistanceBase] = props[CritterProperty::RadiationResistanceBase] + (props[CritterProperty::EnduranceBase] * 2);
    props[CritterProperty::SequenceBase] = props[CritterProperty::SequenceBase] + (props[CritterProperty::PerceptionBase] * 2);
    props[CritterProperty::HealingRateBase] = props[CritterProperty::HealingRateBase] + (MAX(1, props[CritterProperty::EnduranceBase] / 3));
    props[CritterProperty::CriticalChanceBase] = props[CritterProperty::CriticalChanceBase] + (props[CritterProperty::LuckBase]);
#endif

    props[CritterProperty::MaxLifeBase] = props[CritterProperty::MaxLifeBase] + 15;
    props[CritterProperty::ActionPointsBase] = props[CritterProperty::ActionPointsBase] + 5;
    props[CritterProperty::CurrentHp] = props[CritterProperty::MaxLifeBase];
    props[CritterProperty::CurrentAp] = props[CritterProperty::ActionPointsBase] * 100;
}

#if CLIENT

dict<CritterProperty, int> GenerateRegProps()
{
    dict<CritterProperty, int> regProps = {};
    regProps[CritterProperty::StrengthBase] = 5;
    regProps[CritterProperty::PerceptionBase] = 5;
    regProps[CritterProperty::EnduranceBase] = 5;
    regProps[CritterProperty::CharismaBase] = 5;
    regProps[CritterProperty::IntellectBase] = 5;
    regProps[CritterProperty::AgilityBase] = 5;
    regProps[CritterProperty::LuckBase] = 5;
    regProps[CritterProperty::Age] = Game.Random(Tla::AgeMin, Tla::AgeMax);
    regProps[CritterProperty::Gender] = GenderType::Male;
    regProps[CritterProperty::TagSkill1] = CritterProperty::Invalid;
    regProps[CritterProperty::TagSkill2] = CritterProperty::Invalid;
    regProps[CritterProperty::TagSkill3] = CritterProperty::Invalid;
    for (uint i = 0; i < CritterPropertyGroup::Traits.length(); i++) {
        regProps.setIfNotExist(CritterPropertyGroup::Traits[i], 0);
    }
    return regProps;
}

// Check valid of input data
bool CritterGenerateCheck(dict<CritterProperty, int> props)
{
    // Check name
    uint nameError = CheckPlayerName(Game.GetCacheText("RegName__"));
    if (nameError != 0) {
        Game.Message(Game.GetText(TextPackName::Game, nameError));
        return false;
    }

    // Check special
    int special = 0;
    for (uint i = 0; i < CritterPropertyGroup::SpecialBase.length(); i++) {
        if (props[CritterPropertyGroup::SpecialBase[i]] < 1 || props[CritterPropertyGroup::SpecialBase[i]] > 10) {
            Game.Message(Game.GetText(TextPackName::Game, MsgStr::StrNetWrongSpecial));
            return false;
        }
        special += props[CritterPropertyGroup::SpecialBase[i]];
    }
    if (special != Settings.StartSpecialPoints) {
        Game.Message(Game.GetText(TextPackName::Game, MsgStr::StrNetWrongSpecial));
        return false;
    }

    // Check choosed tag skills
    if ((props[CritterProperty::TagSkill1] != CritterProperty::Invalid &&
         CritterPropertyGroup::Skills.find(CritterProperty(props[CritterProperty::TagSkill1])) == -1) ||
        (props[CritterProperty::TagSkill2] != CritterProperty::Invalid &&
         CritterPropertyGroup::Skills.find(CritterProperty(props[CritterProperty::TagSkill2])) == -1) ||
        (props[CritterProperty::TagSkill3] != CritterProperty::Invalid &&
         CritterPropertyGroup::Skills.find(CritterProperty(props[CritterProperty::TagSkill3])) == -1)) {
        Game.Message(Game.GetText(TextPackName::Game, MsgStr::StrNetWrongTagskill));
        return false;
    }
    return true;
}
#endif

#if !CLIENT
void NpcProcessLevel(Critter npc)
{
    for (int i = 0, j = npc.Level; i < j; i++) {
        // Todo: ...
        // npc.MaxLife += 10;
    }
}

uint GetCritterSneakCoefficient(Critter cr)
{
    return cr.SkillSneak;
}

int CritterGetBarterCoefficient(Critter cr)
{
    return cr.SkillBarter;
}
#endif

uint CheckPlayerName(string name)
{
    // Length
    if (name.length() < Settings.MinNameLength || name.length() > Settings.MaxNameLength) {
        return MsgStr::StrNetLoginpassWrong;
    }

    // Valid letters
    string allLetters = Settings.ValidNameLettersCommon + Settings.ValidNameLettersCulture1 + Settings.ValidNameLettersCulture2;

    for (uint i = 0, j = name.length(); i < j; i++) {
        if (allLetters.find(name[i]) == -1) {
            return MsgStr::StrNetPassWrongChars;
        }
    }
    // Spaces
    if (name[0] == " " || name[-1] == " ") {
        return MsgStr::StrNetBeginEndSpaces;
    }
    for (int i = 0, j = name.length() - 1; i < j; i++) {
        if (name[i] == " " && name[i + 1] == " ") {
            return MsgStr::StrNetTwoSpace;
        }
    }
    // Different cultures
    uint letters1 = 0;
    uint letters2 = 0;
    for (int i = 0, j = name.length() - 1; i < j; i++) {
        if (Settings.ValidNameLettersCulture1.find(name[i]) != -1) {
            letters1++;
        }
        else if (Settings.ValidNameLettersCulture2.find(name[i]) != -1) {
            letters2++;
        }
    }

    if (letters1 > 0 && letters2 > 0) {
        return MsgStr::StrNetDifferentLang;
    }
    // Too many common symbols
    if ((letters1 + letters2) * 100 / name.length() < 70) {
        return MsgStr::StrNetManySymbols;
    }

    // All fine, return zero
    return 0;
}

hstring[] UnarmedWeapons = {
    EMPTY_HSTRING, // Content::Item::default_weapon,
    Content::Item::unarmed_strong_punch,
    Content::Item::unarmed_hammer_punch,
    Content::Item::unarmed_haymaker,
    Content::Item::unarmed_jab,
    Content::Item::unarmed_palm_strike,
    Content::Item::unarmed_piercing_strike,
    Content::Item::unarmed_kick,
    Content::Item::unarmed_strong_kick,
    Content::Item::unarmed_snap_kick,
    Content::Item::unarmed_power_kick,
    Content::Item::unarmed_hip_kick,
    Content::Item::unarmed_hook_kick,
    Content::Item::unarmed_piercing_kick,
};

bool VerifyUnarmedItem(Critter cr, hstring pid)
{
    if (pid == EMPTY_HSTRING) {
        return true;
    }
    if (!UnarmedWeapons.exists(pid)) {
        return false;
    }
    ProtoItem proto = Game.GetProtoItem(pid);
    if (cr.Strength < proto.Weapon_MinStrength || cr.Agility < proto.Weapon_UnarmedMinAgility) {
        return false;
    }
    if (cr.Level < proto.Weapon_UnarmedMinLevel || cr.SkillUnarmed < proto.Weapon_UnarmedMinUnarmed) {
        return false;
    }
    return true;
}

#if CLIENT
void SwitchUnarmedWeapon(Critter cr, bool next)
{
    hstring curPid = cr.HandsProtoItemId;
    ProtoItem proto = Game.GetProtoItem(curPid != EMPTY_HSTRING ? curPid : Content::Item::default_weapon);
    uint8 mode = cr.HandsItemMode;
    uint8 use = mode & 0xF;
    uint8 aim = mode >> 4;
    if (next && aim == HitLocations::LocationNone && !cr.IsNoAim && _WeaponAim(proto, use)) {
        aim = HitLocations::LocationTorso;
        cr.HandsItemMode = use | (aim << 4);
        return;
    }

    if (!next && aim != HitLocations::LocationNone) {
        aim = HitLocations::LocationNone;
        cr.HandsItemMode = use | (aim << 4);
        return;
    }

    int index = UnarmedWeapons.find(curPid);
    if (index != -1) {
        int startIndex = index;
        while (true) {
            index += (next ? 1 : -1);
            if (index >= int(UnarmedWeapons.length())) {
                index = 0;
            }
            else if (index < 0) {
                index = UnarmedWeapons.length() - 1;
            }

            if (index == startIndex) {
                break;
            }
            if (VerifyUnarmedItem(cr, UnarmedWeapons[index])) {
                break;
            }
        }
    }
    else {
        index = 0;
    }

    hstring pid = UnarmedWeapons[index];
    if (pid != curPid) {
        cr.HandsItemMode = 0;
        cr.HandsProtoItemId = pid;

        proto = Game.GetProtoItem(pid != EMPTY_HSTRING ? pid : Content::Item::default_weapon);
        if (!next && !cr.IsNoAim && _WeaponAim(proto, 0)) {
            aim = HitLocations::LocationTorso;
            cr.HandsItemMode = aim << 4;
        }
    }
}

void UseMainItem()
{
    Critter chosen = Game.GetChosen();
    if (chosen is null) {
        return;
    }

    if (Settings.Cursor == CursorType::UseWeapon) {
        Settings.Cursor = CursorType::Default;
        return;
    }

    AbstractItem item = CritterItem::GetActive(chosen);
    if (item == null) {
        Settings.Cursor = CursorType::UseWeapon;
        return;
    }

    uint8 mode = item.Mode;
    uint8 use = _WeaponModeUse(mode);
    uint8 aim = _WeaponModeAim(mode);
    ident itemId = cast<Item>(item) != null ? cast<Item>(item).Id : ZERO_IDENT;
    if (mode == USE_RELOAD) {
        ChosenActions::SetChosenActions(array<any> = {Tla::ChosenUseItem, itemId, 0, TARGET_SELF_ITEM, 0, USE_RELOAD, 0});
    }
    else if (mode < MAX_USES && item.Type == ItemType::Weapon) {
        Settings.Cursor = CursorType::UseWeapon;
    }
    else if (mode == USE_USE && item.IsCanUseOnSmth) {
        // Self->CurUseItem = 0;
        // Self->SetCurMode( CUR_USE_ITEM );
        Settings.Cursor = CursorType::UseItem;
    }
    else if (mode == USE_USE && item.IsCanUse) {
        // Отдельная ветка на юз с таймером
        Gui::ShowScreen(GuiScreen::Timer, dict<string, any> = {{"TargetItemId", itemId}});
    }
}

void SwitchMainItemMode(bool next)
{
    Critter chosen = Game.GetChosen();
    if (chosen is null) {
        return;
    }

    AbstractItem item = CritterItem::GetActive(chosen);
    if (item is null || item.ProtoId == hstring("default_weapon") || item.ProtoId == "") {
        SwitchUnarmedWeapon(chosen, next);
    }
    else {
        if (item.Type != ItemType::Weapon) {
            if (item.IsCanUseOnSmth && item.IsCanUse) {
                SetWeaponMode(item, USE_USE);
            }
            else {
                SetWeaponMode(item, USE_NONE);
            }
        }
        else {
            uint8 use = _WeaponModeUse(item.Mode);
            uint8 aim = _WeaponModeAim(item.Mode);

            while (true) {
                if (next) {
                    if (_WeaponAim(item, use) && aim == 0 && !chosen.IsNoAim) // && CritType::IsCanAim( GetCrType() )
                    {
                        aim = HitLocations::LocationTorso;
                        break;
                    }
                    else {
                        use = use + 1;
                        aim = HitLocations::LocationNone;
                    }
                }
                else {
                    if (aim > 0 && _WeaponAim(item, use)) {
                        aim = HitLocations::LocationNone;
                        break;
                    }
                    if (use == 0) {
                        use = (item.IsCanUseOnSmth ? USE_USE : USE_RELOAD);
                    }
                    else {
                        use = use - 1;
                    }
                    if (_WeaponAim(item, use) && aim == 0 && !chosen.IsNoAim) // && CritType::IsCanAim( GetCrType() )
                    {
                        aim = HitLocations::LocationTorso;
                        break;
                    }
                }

                switch (use) {
                case USE_PRIMARY:
                    if (_WeaponIsPrimaryAvailable(item)) {
                        break;
                    }
                    continue;
                case USE_SECONDARY:
                    if (_WeaponIsSecondaryAvailable(item)) {
                        break;
                    }
                    continue;
                case USE_THIRD:
                    if (_WeaponIsThirdAvailable(item)) {
                        break;
                    }
                    continue;
                case USE_RELOAD:
                    if (item.Weapon_MaxAmmoCount > 0) {
                        break;
                    }
                    continue;
                case USE_USE:
                    if (item.IsCanUseOnSmth) {
                        break;
                    }
                    continue;
                default:
                    use = USE_PRIMARY;
                    break;
                }
                break;
            }
            SetWeaponMode(item, _WeaponModeMake(use, aim));
        }
    }
}

#endif

void SetWeaponMode(AbstractItem cItem, uint8 mode)
{
    Item item = cast<Item>(cItem);
    uint8 use = _WeaponModeUse(mode);
    uint8 aim = _WeaponModeAim(mode);

    if (item.Type != ItemType::Weapon) {
        if (use == USE_USE && !item.IsCanUse && !item.IsCanUseOnSmth) {
            use = USE_NONE;
        }
        else if (item.IsCanUse || item.IsCanUseOnSmth) {
            use = USE_USE;
        }
        else {
            use = USE_NONE;
        }
    }
    else {
        switch (use) {
        case USE_PRIMARY:
            if (_WeaponIsPrimaryAvailable(item)) {
                break;
            }
            use = 0xF;
            aim = 0;
            break;
        case USE_SECONDARY:
            if (_WeaponIsSecondaryAvailable(item)) {
                break;
            }
            use = USE_PRIMARY;
            aim = 0;
            break;
        case USE_THIRD:
            if (_WeaponIsThirdAvailable(item)) {
                break;
            }
            use = USE_PRIMARY;
            aim = 0;
            break;
        case USE_RELOAD:
            aim = 0;
            if (item.Weapon_MaxAmmoCount > 0) {
                break;
            }
            use = USE_PRIMARY;
            break;
        case USE_USE:
            aim = 0;
            if (item.IsCanUseOnSmth) {
                break;
            }
            use = USE_PRIMARY;
            break;
        default:
            use = USE_PRIMARY;
            aim = 0;
            break;
        }

        if (use < MAX_USES && aim > 0 && !_WeaponAim(item, use)) {
            aim = 0;
        }
        // mode = ( aim << 4 ) | ( use & 0xF );
        mode = _WeaponModeMake(use, aim);
    }

    item.Mode = mode;
}

void CritterSetHandsProtoItemId(Critter cr, CritterProperty prop, hstring& newValue)
{
    if (!VerifyUnarmedItem(cr, newValue)) {
        newValue = cr.HandsProtoItemId;
    }
}

void CritterSetHandsItemMode(Critter cr, CritterProperty prop, uint8& newValue)
{
    // Check uses and aiming
}

#define CONVERT_GRAMM           #(x)((x) * 453)
#define TB_BATTLE_TIMEOUT_CHECK #(to)((to) > Game.SynchronizedTime && (to) - Game.SynchronizedTime > 10000000)

int CritterGetStrength(Critter cr)
{
    // Base value
    int val = cr.StrengthBase;

    // Adrenaline rush perk
    if (cr.PerkAdrenalineRush != 0 && Time::IsTimeoutActive(cr.TimeoutBattle) &&
        cr.CurrentHp <= (cr.MaxLifeBase + cr.StrengthBase + cr.EnduranceBase * 2) / 2) {
        val += 1;
    }

    // Armor perk
    int armorPerk = cr.CurrentArmorPerk;
    if (armorPerk == ArmorPerks::Powered) {
        val += 3;
    }
    else if (armorPerk == ArmorPerks::AdvancedI || armorPerk == ArmorPerks::AdvancedII) {
        val += 4;
    }

    // Drug effect
    val += Drugs::GetDrugEffect(cr, CritterProperty::StrengthBase);

    return CLAMP(val, 1, 10);
}

int CritterGetPerception(Critter cr)
{
    // Base value
    int val = (cr.IsDamagedEye ? 1 : cr.PerceptionBase);

    // Night person perk
    if (cr.IsTraitNightPerson) {
        val += GetNightPersonBonus();
    }

    // Drug effect
    val += Drugs::GetDrugEffect(cr, CritterProperty::PerceptionBase);

    return CLAMP(val, 1, 10);
}

int CritterGetEndurance(Critter cr)
{
    // Base value
    int val = cr.EnduranceBase;

    // Drug effect
    val += Drugs::GetDrugEffect(cr, CritterProperty::EnduranceBase);

    return CLAMP(val, 1, 10);
}

int CritterGetCharisma(Critter cr)
{
    // Base value
    int val = cr.CharismaBase;

    // Armor perk
    if (cr.CurrentArmorPerk == ArmorPerks::Charisma) {
        val += 1;
    }

    // Drug effect
    val += Drugs::GetDrugEffect(cr, CritterProperty::CharismaBase);

    return CLAMP(val, 1, 10);
}

int CritterGetIntellegence(Critter cr)
{
    // Base value
    int val = cr.IntellectBase;

    // Night person perk
    if (cr.IsTraitNightPerson) {
        val += GetNightPersonBonus();
    }

    // Drug effect
    val += Drugs::GetDrugEffect(cr, CritterProperty::IntellectBase);

    return CLAMP(val, 1, 10);
}

int CritterGetAgility(Critter cr)
{
    // Base value
    int val = cr.AgilityBase;

    // Drug effect
    val += Drugs::GetDrugEffect(cr, CritterProperty::AgilityBase);

    return CLAMP(val, 1, 10);
}

int CritterGetLuck(Critter cr)
{
    // Base value
    int val = cr.LuckBase;

    // Drug effect
    val += Drugs::GetDrugEffect(cr, CritterProperty::LuckBase);

    return CLAMP(val, 1, 10);
}

bool CritterGetIsNoMove(Critter cr)
{
    return cr.IsNoMoveBase;
}

bool CritterGetIsNoRun(Critter cr)
{
    return cr.IsNoRunBase;
}

uint CritterGetWalkSpeed(Critter cr)
{
    return cr.WalkSpeedBase > 0 ? cr.WalkSpeedBase : 80;
}

int CritterGetMaxLife(Critter cr)
{
    int val = cr.MaxLifeBase + cr.StrengthBase + cr.EnduranceBase * 2;
    val += Drugs::GetDrugEffect(cr, CritterProperty::MaxLifeBase);
    return CLAMP(val, 1, 9999);
}

int CritterGetActionPoints(Critter cr)
{
    int val = cr.ActionPointsBase + CritterGetAgility(cr) / 2;
    val += Drugs::GetDrugEffect(cr, CritterProperty::ActionPointsBase);
    return CLAMP(val, 1, 9999);
}

bool CritterGetIsOverweight(Critter cr)
{
    return int(cr.ItemsWeight) > CritterGetCarryWeight(cr);
}

int CritterGetCarryWeight(Critter cr)
{
    int val = MAX(cr.CarryWeightBase, 0);
    val += Drugs::GetDrugEffect(cr, CritterProperty::CarryWeightBase);
    val += CONVERT_GRAMM(25 + CritterGetStrength(cr) * (25 - (cr.IsTraitSmallFrame ? 10 : 0)));
    return CLAMP(val, 0, 2000000000);
}

int CritterGetSequence(Critter cr)
{
    int val = cr.SequenceBase + CritterGetPerception(cr) * 2;
    val += Drugs::GetDrugEffect(cr, CritterProperty::SequenceBase);
    return CLAMP(val, 0, 9999);
}

int CritterGetMeleeDamage(Critter cr)
{
    int strength = CritterGetStrength(cr);
    int val = cr.MeleeDamageBase + (strength > 6 ? strength - 5 : 1);
    val += Drugs::GetDrugEffect(cr, CritterProperty::MeleeDamageBase);
    return CLAMP(val, 1, 9999);
}

int CritterGetHealingRate(Critter cr)
{
    int e = CritterGetEndurance(cr);
    int val = cr.HealingRateBase + MAX(1, e / 3);
    val += Drugs::GetDrugEffect(cr, CritterProperty::HealingRateBase);
    return CLAMP(val, 0, 9999);
}

int CritterGetCriticalChance(Critter cr)
{
    int val = cr.CriticalChanceBase + CritterGetLuck(cr);
    val += Drugs::GetDrugEffect(cr, CritterProperty::CriticalChanceBase);
    return CLAMP(val, 0, 100);
}

int CritterGetMaxCritical(Critter cr)
{
    int val = cr.MaxCriticalBase;
    val += Drugs::GetDrugEffect(cr, CritterProperty::MaxCriticalBase);
    return CLAMP(val, -100, 100);
}

int GetDeteriorationProc(AbstractItem item)
{
    if (!item.Deteriorable) {
        return 0;
    }
    if (item.IsBroken) {
        return 100;
    }
    int value = item.Deterioration * 100 / Tla::MaxDeterioration;
    return CLAMP(value, 0, 100);
}

int CritterGetArmorClass(Critter cr)
{
    int val = cr.ArmorClassBase + CritterGetAgility(cr);
    val += Drugs::GetDrugEffect(cr, CritterProperty::ArmorClassBase);
    AbstractItem armor = CritterItem::GetActive(cr, CritterItemSlot::Armor);
    if (valid(armor) && armor.Type == ItemType::Armor) {
        val += armor.Armor_AC * (100 - GetDeteriorationProc(armor)) / 100;
    }
    return CLAMP(val, 0, 90);
}

int[] CritterGetDamageResistance(Critter cr)
{
    AbstractItem armor = CritterItem::GetActive(cr, CritterItemSlot::Armor);
    uint dp = 0;
    if (cast<Item>(armor) != null && armor.Type == ItemType::Armor) {
        dp = 100 - GetDeteriorationProc(armor);
    }

    int[] result = {
        0,
        cr.NormalResistanceBase + armor.Armor_DRNormal * dp / 100,
        cr.LaserResistanceBase + armor.Armor_DRLaser * dp / 100,
        cr.FireResistanceBase + armor.Armor_DRFire * dp / 100,
        cr.PlasmaResistanceBase + armor.Armor_DRPlasma * dp / 100,
        cr.ElectricityResistanceBase + armor.Armor_DRElectr * dp / 100,
        cr.EmpResistanceBase + armor.Armor_DREmp * dp / 100,
        cr.ExplodeResistanceBase + armor.Armor_DRExplode * dp / 100,
        cr.PoisonResistanceBase + CritterGetEndurance(cr) * 5,
        cr.RadiationResistanceBase + CritterGetEndurance(cr) * 2,
    };

    // Armor perk
    int armorPerk = cr.CurrentArmorPerk;
    if (armorPerk == ArmorPerks::Powered) {
        result[DamageTypes::Radiation] += 30;
    }
    else if (armorPerk == ArmorPerks::Combat) {
        result[DamageTypes::Radiation] += 20;
    }
    else if (armorPerk == ArmorPerks::AdvancedI) {
        result[DamageTypes::Radiation] += 60;
    }
    else if (armorPerk == ArmorPerks::AdvancedII) {
        result[DamageTypes::Radiation] += 75;
    }

    // Drug effects
    for (uint i = 0; i < CritterPropertyGroup::ResistsBase.length(); i++) {
        result[i] += Drugs::GetDrugEffect(cr, CritterPropertyGroup::ResistsBase[i]);
    }

    // Clamp
    for (uint i = 0; i < result.length(); i++) {
        result[i] = CLAMP(result[i], 0, i != DamageTypes::Emp ? 90 : 999);
    }
    return result;
}

int CritterGetNormalResistance(Critter cr)
{
    return CritterGetDamageResistance(cr)[DamageTypes::Normal];
}

int CritterGetPoisonResistance(Critter cr)
{
    return CritterGetDamageResistance(cr)[DamageTypes::Poison];
}

int CritterGetRadiationResistance(Critter cr)
{
    return CritterGetDamageResistance(cr)[DamageTypes::Radiation];
}

int[] CritterGetDamageThreshold(Critter cr)
{
    AbstractItem armor = CritterItem::GetActive(cr, CritterItemSlot::Armor);
    uint dp = 0;
    if (cast<Item>(armor) != null && armor.Type == ItemType::Armor) {
        dp = 100 - GetDeteriorationProc(armor);
    }

    int[] result = {
        0,
        cr.NormalThresholdBase + armor.Armor_DTNormal * dp / 100,
        cr.LaserThresholdBase + armor.Armor_DTLaser * dp / 100,
        cr.FireThresholdBase + armor.Armor_DTFire * dp / 100,
        cr.PlasmaThresholdBase + armor.Armor_DTPlasma * dp / 100,
        cr.ElectricityThresholdBase + armor.Armor_DTElectr * dp / 100,
        cr.EmpThresholdBase + armor.Armor_DTEmp * dp / 100,
        cr.ExplodeThresholdBase + armor.Armor_DTExplode * dp / 100,
        0,
        0,
    };

    // Drug effects
    for (uint i = 0; i < CritterPropertyGroup::ThresholdsBase.length(); i++) {
        result[i] += Drugs::GetDrugEffect(cr, CritterPropertyGroup::ThresholdsBase[i]);
    }

    // Clamp
    for (uint i = 0; i < result.length(); i++) {
        result[DamageTypes::Emp] = CLAMP(result[DamageTypes::Emp], 0, 999);
    }
    return result;
}

bool CritterGetIsInjured(Critter cr)
{
    return cr.IsDamagedEye || cr.IsDamagedRightLeg || cr.IsDamagedLeftLeg || cr.IsDamagedRightArm || cr.IsDamagedLeftArm;
}

bool CritterGetIsAddicted(Critter cr)
{
    bool[] addictions = cr.Addictions.clone();
    for (uint i = 0; i < addictions.length(); i++) {
        if (addictions[i]) {
            return true;
        }
    }
    return false;
}

CritterProperty[] CritterGetTagSkills(Critter cr)
{
    CritterProperty[] result = {};
    if (cr.TagSkill1 != CritterProperty::Invalid) {
        result.insertLast(cr.TagSkill1);
    }
    if (cr.TagSkill2 != CritterProperty::Invalid) {
        result.insertLast(cr.TagSkill2);
    }
    if (cr.TagSkill3 != CritterProperty::Invalid) {
        result.insertLast(cr.TagSkill3);
    }
    return result;
}

uint GetCritterLookDistance(Critter cr)
{
    int look = Settings.LookNormal + cr.Perception * 3 + cr.BonusLook + cr.Multihex;
    if (look < int(Settings.LookMinimum)) {
        look = Settings.LookMinimum;
    }
    return look;
}

bool Item_Weapon_IsHtHAttack(AbstractItem item, uint8 mode)
{
    uint8 use = mode & 0xF;
    if (item.Type != ItemType::Weapon || item.Weapon_ActiveUses <= use) {
        return false;
    }
    CritterProperty skill = _WeaponSkill(item, use);
    return skill == CritterProperty::SkillUnarmed || skill == CritterProperty::SkillMeleeWeapons;
}

bool Item_Weapon_IsGunAttack(AbstractItem item, uint8 mode)
{
    uint8 use = mode & 0xF;
    if (item.Type != ItemType::Weapon || item.Weapon_ActiveUses <= use) {
        return false;
    }
    CritterProperty skill = _WeaponSkill(item, use);
    return skill == CritterProperty::SkillSmallGuns || skill == CritterProperty::SkillBigGuns || skill == CritterProperty::SkillEnergyWeapons;
}

bool Item_Weapon_IsRangedAttack(AbstractItem item, uint8 mode)
{
    uint8 use = mode & 0xF;
    if (item.Type != ItemType::Weapon || item.Weapon_ActiveUses <= use) {
        return false;
    }
    CritterProperty skill = _WeaponSkill(item, use);
    return skill == CritterProperty::SkillSmallGuns || skill == CritterProperty::SkillBigGuns || skill == CritterProperty::SkillEnergyWeapons ||
           skill == CritterProperty::SkillThrowing;
}

// Engine callbacks

uint GetItemUseApCost(Critter cr, AbstractItem item, uint8 mode)
{
    if (item == null) {
        return 0;
    }

    uint8 use = mode & 0xF;
    uint8 aim = mode >> 4;
    int apCost = 1;

    if (use == USE_USE) {
        apCost = Settings.RtApCostUseItem;
    }
    else if (use == USE_RELOAD) {
        apCost = Settings.RtApCostReloadWeapon;

        if (item.Type == ItemType::Weapon && item.Weapon_Perk == ItemPerks::FastReload) {
            apCost--;
        }
    }
    else if (use >= USE_PRIMARY && use <= USE_THIRD && item.Type == ItemType::Weapon) {
        bool hthAttack = Item_Weapon_IsHtHAttack(item, use);
        bool rangedAttack = Item_Weapon_IsRangedAttack(item, use);
        apCost = _WeaponApCost(item, use);
        if (aim != 0) {
            apCost += GetAimApCost(aim);
        }
        if (hthAttack && cr.PerkBonusHthAttacks != 0) {
            apCost--;
        }
        if (rangedAttack && cr.PerkBonusRateOfFire != 0) {
            apCost--;
        }
        if (cr.IsTraitFastShot && !hthAttack) {
            apCost--;
        }
    }

    if (apCost < 1) {
        apCost = 1;
    }
    return apCost;
}

void get_use_ap_cost(Critter cr, AbstractItem item, uint8 mode, uint& cost)
{
    cost = GetItemUseApCost(cr, item, mode);
}

uint GetItemAttackDistance(Critter cr, AbstractItem item, uint8 mode)
{
    if (item == null) {
        return 0;
    }
    if (item.Type != ItemType::Weapon) {
        return 0;
    }

    uint8 use = mode & 0xF;
    CritterProperty skill = _WeaponSkill(item, use);
    int dist = _WeaponMaxDist(item, use);
    int strength = CritterGetStrength(cr);
    int heaveHo = cr.PerkHeaveHo;
    if (skill == CritterProperty::SkillThrowing) {
        dist = MIN(dist, int(3) * MIN(int(10), strength + 2 * heaveHo));
    }
    if (Item_Weapon_IsHtHAttack(item, mode) && cr.IsRangeHth) {
        dist++;
    }
    dist += cr.Multihex;
    if (dist < 0) {
        dist = 0;
    }
    return dist;
}

uint GetActiveItemAttackDistance(Critter cr)
{
    AbstractItem item = CritterItem::GetActive(cr);
    if (valid(item)) {
        return GetItemAttackDistance(cr, item, item.Mode);
    }
    return 1;
}

uint GetCritterAttackDistance(Critter cr, AbstractItem item, uint8 mode)
{
    if (item == null) {
        return 0;
    }

    if (!valid(item) && valid(cr)) {
        item = CritterItem::GetActive(cr);
        mode = item.Mode;
    }

    return GetItemAttackDistance(cr, item, mode);
}

// Generic stuff

int GetNightPersonBonus()
{
    if (GameTime::GetHour() < 6 || GameTime::GetHour() > 18) {
        return 1;
    }
    if (GameTime::GetHour() == 6 && GameTime::GetMinute() == 0) {
        return 1;
    }
    if (GameTime::GetHour() == 18 && GameTime::GetMinute() > 0) {
        return 1;
    }
    return -1;
}

uint GetAimApCost(int hitLocation)
{
    switch (hitLocation) {
    case HitLocations::LocationTorso:
        return Settings.ApCostAimTorso;
    case HitLocations::LocationEyes:
        return Settings.ApCostAimEyes;
    case HitLocations::LocationHead:
        return Settings.ApCostAimHead;
    case HitLocations::LocationLeftArm:
    case HitLocations::LocationRightArm:
        return Settings.ApCostAimArms;
    case HitLocations::LocationGroin:
        return Settings.ApCostAimGroin;
    case HitLocations::LocationRightLeg:
    case HitLocations::LocationLeftLeg:
        return Settings.ApCostAimLegs;
    case HitLocations::LocationNone:
    case HitLocations::LocationUncalled:
    default:
        break;
    }
    return 0;
}

uint CritterGetItemsWeight(Critter cr)
{
#if CLIENT
    if (!cr.IsChosen) {
        return 0; // TODO
    }
#endif
    Item[] items = cr.GetItems();
    uint result = 0;
    for (uint i = 0; i < items.length(); i++) {
        result += items[i].Weight * items[i].Count;
    }
    return result;
}

#endif

}
