// FOS Server
// Author: cvet, heX, Tab10id

void ModuleInit()
{
    GameInstance.OnStaticItemWalk.Subscribe(OnMapExit);
}

void OnMapExit(ItemProto item, Critter cr, bool isIn, uint8 moveDir)
{
    if (!isIn)
        return;
    if (item.Type != ItemType::Grid)
        return;
    if (!cr.IsPlayer())
        return;
    if (IS_TIMEOUT(cr.TimeoutBattle) || IS_TIMEOUT(cr.TimeoutTransfer))
        return;

    hstring mapProto = item.Grid_ToMap;
    if (mapProto != 0) {
        Map map = cr.GetMap().GetLocation().GetMap(mapProto);
        if (map == null)
            ThrowException("Invalid exit map.", cr, mapProto);

        if (!map.GetLocation().Hidden) {
            auto knownLocations = cr.KnownLocations.clone();
            if (knownLocations.find(map.GetLocation().Id) == -1) {
                knownLocations.insertLast(map.GetLocation().Id);
                cr.KnownLocations = knownLocations;
            }
        }

        Obsolete::CritterTransitToMapEntry(cr, map.Id, item.Grid_ToMapEntry);
    }
    else {
        cr.TransitToGlobal();
    }
}

bool s_Dialog(Critter player, StaticItem scenery, Item item, int skill) // 691 revision CritterProperty skill )
{
    // Запускаем диалог, если игрок не применял к сценери скилл или итем
    int dialogId = scenery.SceneryParams[0];
    if (skill == SKILL_PICK_ON_GROUND && not valid(item))
        return RunDialog(player, dialogId, scenery.HexX, scenery.HexY, false);
    return false;
}

bool s_DoorControl(Critter player, StaticItem scenery, Item item, int skill)
{
    auto params = scenery.SceneryParams;
    int entryNum = params[0];
    int toOpen = params[1];

    if (toOpen == 1)
        Stdlib::DoorControl(player, entryNum, true);
    else
        Stdlib::DoorControl(player, entryNum, false);
    return true;
}

bool s_TransitToMap(Critter player, StaticItem scenery, Item item, int skill)
{
    auto params = scenery.SceneryParams;
    int locPid = params[0];
    int mapIndex = params[1];
    int entry = params[2];
    return Stdlib::TransitToMap(player, locPid, mapIndex, entry);
}
