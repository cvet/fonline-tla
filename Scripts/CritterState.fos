namespace CritterState
{

#if SERVER

///@ Property Critter PrivateServer int32 KnockoutAp
///@ Property Critter Protected nanotime WaitEndTick Temporary
///@ Property Critter PrivateServer CritterActionAnim ActionAnimKnockoutEnd
///@ Event Server Game OnCritterRespawn(Critter critter)
///@ Event Server Game OnCritterKnockout(Critter critter)
///@ RemoteCall Server Rpc_Wait(int32 ms)

void ModuleInit()
{
    Game.OnCritterInit.Subscribe(OnCritterInit);
}

void OnCritterInit(Critter cr, bool firstTime)
{
    if (firstTime) {
        cr.WaitEndTick = ZERO_NANOTIME;
    }
    cr.StartTimeEvent(Time::Milliseconds(Game.Random(0, 1000)), Time::Milliseconds(1000), OnCritterIdle);
}

void OnCritterIdle(Critter cr)
{
    if (cr.IsKnockout()) {
        TryUpOnKnockout(cr);
    }
}

void ToDead(Critter cr, CritterActionAnim actionAnim, Critter killer)
{
    // Already dead
    if (cr.IsDead()) {
        return;
    }

    cr.CloseDialog();
    if (cr.InSneakMode) {
        cr.InSneakMode = false;
    }
    if (cr.CurrentHp > 0) {
        cr.CurrentHp = 0;
    }

    cr.SetConditionAnims(CritterCondition::Dead, cr.DeadStateAnim, actionAnim);
    cr.SetCondition(CritterCondition::Dead, actionAnim, null);

    Game.OnCritterDead.Fire(cr, killer);
    cr.OnDead.Fire(killer);
    if (killer != null) {
        killer.OnKill.Fire(cr);
    }
}

bool ToAlive(Critter cr)
{
    // Already life
    if (cr.IsAlive()) {
        return true;
    }

    if (cr.IsDead()) {
        Map map = cr.GetMap();
        if (map is null) {
            ThrowException("Critter on global map");
        }

        if (!map.IsHexesMovable(cr.Hex, cr.Multihex)) {
            ThrowException("Hexes is busy");
        }

        cr.SetCondition(CritterCondition::Alive, CritterActionAnim::None, null);

        if (cr.CurrentHp < 1) {
            cr.CurrentHp = 1;
        }

        cr.Action(CritterAction::Respawn, 0, null);
        Game.OnCritterRespawn.Fire(cr);
    }
    else if (cr.IsKnockout()) {
        if (cr.CurrentHp <= 0) {
            cr.CurrentHp = 1;
        }
        if (cr.CurrentAp <= 0) {
            cr.CurrentAp = 1;
        }

        cr.KnockoutAp = 0;
        TryUpOnKnockout(cr);
    }

    return true;
}

class KnockoutTracer : LineTracer::ITraceContext
{
    Critter Cr;
    int Multihex;
    uint16 EndHx;
    uint16 EndHy;

    KnockoutTracer(Critter cr)
    {
        Cr = cr;
        Multihex = cr.Multihex;
        EndHx = cr.Hex.x;
        EndHy = cr.Hex.y;
    }

    void StartExec(Map map, mpos hex, mpos hexTo, int maxDist) override
    {
        // Nothing
    }

    void FinishExec(Map map, int resultDist) override
    {
        // Nothing
    }

    bool Exec(Map map, mpos hex) override
    {
        if (!map.IsHexesMovable(hex, Multihex)) {
            return true;
        }

        // Stop before trigger
        hstring pid = Content::Item::Trigger;
        if (!map.GetStaticItems(hex, Multihex, pid).isEmpty()) {
            return true;
        }

        EndHx = hex.x;
        EndHy = hex.y;
        return false;
    }
};

void ToKnockout(Critter cr, CritterActionAnim actionAnimBegin, CritterActionAnim actionAnimIdle, CritterActionAnim actionAnimEnd, int lostAp, uint16 knockHx,
                uint16 knockHy)
{
    if (cr.IsKnockout()) {
        cr.KnockoutAp += lostAp;
        cr.SetConditionAnims(CritterCondition::Knockout, cr.KnockoutStateAnim, actionAnimIdle);
        cr.ActionAnimKnockoutEnd = actionAnimEnd;
        return;
    }

    if (cr.IsDead()) {
        ThrowException("Critter is dead");
    }

    Map map = cr.GetMap();
    if (map is null) {
        ThrowException("Critter on global map");
    }

    if (knockHx >= map.Size.width || knockHy >= map.Size.height) {
        ThrowException("Invalid hexes args");
    }

    cr.CloseDialog();
    if (cr.InSneakMode) {
        cr.InSneakMode = false;
    }

    // Find destination
    uint8 dir = Game.GetDirection(mpos(knockHx, knockHy), cr.Hex);
    KnockoutTracer tracer = KnockoutTracer(cr);
    LineTracer::LineTracerHex(cr.Hex, mpos(knockHx, knockHy), map, 0, tracer);

    // Move to new place
    cr.TransitToHex(mpos(tracer.EndHx, tracer.EndHy), dir);
    cr.SetConditionAnims(CritterCondition::Knockout, cr.KnockoutStateAnim, actionAnimIdle);
    cr.SetCondition(CritterCondition::Knockout, actionAnimBegin, null);
    cr.ActionAnimKnockoutEnd = actionAnimEnd;
    cr.KnockoutAp = lostAp;

    Game.OnCritterKnockout.Fire(cr);
}

void TryUpOnKnockout(Critter cr)
{
    // Critter lie on ground
    if (cr.CurrentHp <= 0) {
        return;
    }
    // Subtract knockout ap
    if (cr.KnockoutAp > 0) {
        int curAp = cr.CurrentAp;
        if (curAp <= 0) {
            return;
        }

        int ap = MIN(int(cr.KnockoutAp), curAp);
        cr.KnockoutAp -= ap;
        if (cr.KnockoutAp > 0) {
            return;
        }
    }

    // Wait when ap regenerated to zero
    if (cr.CurrentAp < 0) {
        return;
    }

    // Stand up
    cr.SetCondition(CritterCondition::Alive, cr.ActionAnimKnockoutEnd, null);
    CritterState::Wait(cr, Settings.Breaktime);
}

void Wait(Critter cr, int ms)
{
    cr.WaitEndTick = Game.FrameTime + Time::Milliseconds(ms);
}

bool IsBusy(Critter cr)
{
    return Game.FrameTime < cr.WaitEndTick;
}

bool IsWait(Critter cr)
{
    return Game.FrameTime < cr.WaitEndTick;
}

bool IsFree(Critter cr)
{
    return Game.FrameTime >= cr.WaitEndTick;
}

void Rpc_Wait(Player player, int ms)
{
    Critter cr = player.GetControlledCritter();
    if (cr != null) {
        Wait(cr, ms);
    }
}

#endif

}
