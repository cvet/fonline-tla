namespace Traveller
{

#if SERVER

// Author: rifleman17
// Скрипт для реализации нпц-путешественников. (Beta)
// НПЦ перемещаются между различными городами по глобальной карте в случайном порядке.
// НПЦ либо честно идет по глобальной карте по прямой, и при заходе на энкаунтер разбирается с мобами, затем продолжает движение
// Либо просто телепортируется в следующую точку маршрута.
// НПЦ находится в каждом городе определенное время.
// Список точек маршрута и настройки нпц сохраняются в TravellerRoute для каждого нпц.
// Следующая точка маршрута выбирается в момент достижения предыдущей.
// Существует проблема: путешественник может застрять в некоем месте, например, на береговой линии, если пойдет из СФ в ароййо
// Поэтому при отправлении засекаем время начала движения, и назначаем время телепорта путешественника в точку назначения через 1 игровой месяц

///@ Property Critter Server uint8[] TravellerRoute Mutable Persistent

#define TYPE_TRANSIT   (0)
#define TYPE_TRAVEL    (1)
#define NEXT_TRY       (Time::Minutes(10))
#define CTE_FOUND_LOC  (11)
#define CTE_NEW_TRAVEL (12)
#define CTE_CHECK      (17)                   // Событие проверки, достиг ли НПЦ точки назначения
#define CTE_SHOW_LOC   (18)                   // Подсветка энкаунтеров Илая на глобальной карте
#define TIME_CHECK     (Time::GameDays(7))    // Время проверки в секундах
#define TIME_SHOWLOC   (Time::GameMinutes(1)) // отображение локации через игровую минуту
#define DIST_MAX       (10) // Минимальная дистанция в гексах до криттера, находясь на которой игрок попадет ему в группу при начале путешествия

// #define DL #(s) (Game.Log("traveller: " + s))
#define DL #(s)

// Присваевает скрипт для НПЦ и запускает его выполнение
// crId - Id нпц
// isTransit - признак, нпц перемещается телепортом
// entryNum - номер гекса, на который будет перемещаться нпц при заходе в локацию
// timeWaitLoc - время ожидания на локации до следующего путешествия
// timeWaitEnc - время ожидания на энкаунтере после завершения боя до продолжения путешествия
// locPids - массив кодов протоипов локаций, на которые может зайти НПЦ
void SetTraveller(ident crId, bool isTransit, int entryNum, timespan timeWaitLoc, timespan timeWaitEnc, hstring[] locPids, bool visibleEncounters)
{
    Critter cr = Game.GetCritter(crId);
    if (!valid(cr)) {
        return;
    }

    cr.IsGeck = true;

    Traveller t = Traveller(crId);
    t.TravelType = (isTransit ? TYPE_TRANSIT : TYPE_TRAVEL);
    t.EntryTo = entryNum;
    t.TimeWaitLocation = timeWaitLoc;
    t.TimeWaitEncounter = timeWaitEnc;
    t.VisibleEncounters = visibleEncounters;

    for (int i = 0, l = locPids.length(); i < l; i++) {
        t.AddLocPid(locPids[i]);
    }

    t.Save();

    if (valid(cr.GetMap())) {
        t.SheduleChooseLocation();
        t.SheduleTravel(true);
    }

    if (t.TravelType == TYPE_TRAVEL) {
        cr.OnGlobalMapInvite.Subscribe(_GlobalInvite);
        cr.OnGlobalMapProcess.Subscribe(_GlobalProcess);
    }
}

void CancelTraveller(ident crId)
{
    Traveller ti = Traveller(crId);
    ti.Erase();
    Critter cr = Game.GetCritter(crId);
    if (!valid(cr)) {
        return;
    }
    if (cr.CountTimeEvent(cte_ChooseTravelPoint) != 0) {
        cr.StopTimeEvent(cte_ChooseTravelPoint);
    }
    if (cr.CountTimeEvent(cte_Travel) != 0) {
        cr.StopTimeEvent(cte_Travel);
    }
}

class Traveller
{
    Traveller(ident crId)
    {
        CritterId = crId;
    }

    ident CritterId; // Id нпц-путешественника
    int TravelType;  // Тип перемещений.(Телепорт или путешествие через глобал)
    ident MapIdTo;   // Id карты на которую направляется НПЦ
    int EntryTo;     // Номер гекса, на котором будет стоять НПЦ
    timespan TimeWaitLocation; // Время ожидания в игровых секундах на локации перед следующим путешествием
    timespan TimeWaitEncounter; // Время ожидания в игровых секундах на энкаунтере во время путешествия
    bool VisibleEncounters;     // Признак - делать ли энкаунтер видимым, если на него зашел НПЦ
    synctime TimeLastStart;     // Время последнего отправления НПЦ из локации
    synctime TimeNextRoute;     // Время следующего отправления НПЦ из локации
    hstring[] LocationPids = {}; // Массив кодов прототипов локаций, на которые может отправиться НПЦ
    ident[] Followers = {};      // Массив Id спутников путешественника, может быть как игроки, так и нпц

    void AddLocPid(hstring locPid)
    {
        for (int i = 0; i < LocationPids.length(); i++) {
            if (locPid == LocationPids[i]) {
                return;
            }
        }
        LocationPids.insertLast(locPid);
    }

    void AddFollower(ident crId)
    {
        for (int i = 0; i < Followers.length(); i++) {
            if (crId == Followers[i]) {
                return;
            }
        }
        Followers.insertLast(crId);
        Save();
    }

    // Сериализация

    void Save()
    {
        auto save = Serializator::Serializator();
        save.Set(CritterId);
        save.Set(TravelType);
        save.Set(MapIdTo);
        save.Set(EntryTo);
        save.Set(TimeWaitLocation);
        save.Set(TimeWaitEncounter);
        save.Set(VisibleEncounters);
        save.Set(TimeLastStart);
        save.Set(TimeNextRoute);
        save.Set(LocationPids);
        save.Set(Followers);
        GetTraveller().TravellerRoute = save.GetData();
    }

    void Load()
    {
        auto load = Serializator::Serializator();
        if (load.SetData(GetTraveller().TravellerRoute) == 0) {
            return;
        }
        load.Get(CritterId);
        load.Get(TravelType);
        load.Get(MapIdTo);
        load.Get(EntryTo);
        load.Get(TimeWaitLocation);
        load.Get(TimeWaitEncounter);
        load.Get(VisibleEncounters);
        load.Get(TimeLastStart);
        load.Get(TimeNextRoute);
        load.Get(LocationPids);
        load.Get(Followers);
    }

    void Erase()
    {
        GetTraveller().TravellerRoute = array<uint8>();
    }

    Critter GetTraveller()
    {
        if (CritterId == ZERO_IDENT) {
            return null;
        }

        return Game.GetCritter(CritterId);
    }

    // Попытка найти новую точку перемещения
    bool TryFoundNewLocation()
    {
        int tries = 20;
        int idx = 0;
        int len = LocationPids.length();
        int maps = 0;
        if (len == 0) {
            return false;
        }

        Critter cr = GetTraveller();
        if (!valid(cr)) {
            return false;
        }

        ident mapId;
        Map mapCr = cr.GetMap();
        if (valid(mapCr)) {
            mapId = mapCr.Id;
        }

        while (tries > 0) {
            idx = Game.Random(0, len - 1);
            Location[] locations = Game.GetLocations(LocationPids[idx]);
            if (locations.length() > 0) {
                idx = Game.Random(0, locations.length() - 1);
                Location loc = locations[idx];
                if (valid(loc)) {
                    maps = loc.GetMapCount();
                    for (int i = 0; i < maps; i++) {
                        Map map = loc.GetMapByIndex(i);
                        if (valid(map) && (Entrance::MapCountEntry(map, HASHI(EntryTo)) > 0) && map.Id != mapId) {
                            DL("Target point found. Id = " + map.Id + "; ProtoMap = " + map.ProtoId);
                            MapIdTo = map.Id;
                            Save();
                            return true;
                        }
                    }
                }
            }
            tries--;
        }
        DL("Travel point not found");
        return false;
    }

    bool TransferToLocation()
    {
        Critter cr = GetTraveller();
        if (!valid(cr) || MapIdTo == ZERO_IDENT) {
            return false;
        }
        Map map = Game.GetMap(MapIdTo);
        if (!valid(map) || Entrance::MapCountEntry(map, HASHI(EntryTo)) == 0) {
            return false;
        }
        Entrance::CritterTransferToMapEntry(cr, map.Id, HASHI(EntryTo));

        // todo, check, critter is on new map
        if (true) {
            cr.HomeMapId = MapIdTo;
            cr.HomeHex = cr.Hex;
            cr.HomeDir = cr.Dir;
            return true;
        }
        return false;
    }

    // Собирает группу желающих и выходит на глобал
    // Если человек, желающий сопровождать нпц находится дальше DIST_MAX от нпц, в группу не попадает
    bool BeginTravelToLocation()
    {
        Critter cr = GetTraveller();
        if (!valid(cr)) {
            return false;
        }

        Map map = cr.GetMap();
        if (!valid(map)) {
            return false;
        }

        Critter[] grp = {};
        ident[] confirmedIds = {};
        grp.insertLast(cr);
        int ch = cr.Charisma;
        for (int i = 0, l = Followers.length(); i < l && confirmedIds.length() < ch; i++) {
            Critter follower = Game.GetCritter(Followers[i]);
            if (valid(follower) && follower.IsAlive() && valid(follower.GetMap()) && (follower.GetMap().Id == map.Id) &&
                (Game.GetDistance(cr, follower) <= DIST_MAX)) {
                grp.insertLast(follower);
                confirmedIds.insertLast(follower.Id);
            }
        }

        Followers.clear();
        for (int i = 0, l = confirmedIds.length(); i < l; i++) {
            Followers.insertLast(confirmedIds[i]);
        }

        cr.TransferToGlobal();
        TimeLastStart = Game.SynchronizedTime;
        Save();
        return true;
    }

    void SheduleChooseLocation()
    {
        Critter cr = GetTraveller();
        if (!valid(cr)) {
            return;
        }
        if (cr.CountTimeEvent(cte_ChooseTravelPoint) == 0) {
            cr.StartTimeEvent(ZERO_TIMESPAN, cte_ChooseTravelPoint);
        }
    }

    void SheduleTravel(bool fromLoc)
    {
        Critter cr = GetTraveller();
        if (!valid(cr)) {
            return;
        }
        if (fromLoc && cr.CountTimeEvent(cte_Check) != 0) {
            cr.StopTimeEvent(cte_Check); // В точку назначения прибыли, удаляем события проверки застрял/не застрял
        }
        if (cr.CountTimeEvent(cte_Travel) == 0) {
            cr.StartTimeEvent((fromLoc ? TimeWaitLocation : TimeWaitEncounter), cte_Travel);
            TimeNextRoute = Game.SynchronizedTime + (fromLoc ? TimeWaitLocation : TimeWaitEncounter);
            DL("time: " + TimeNextRoute + " or: " + GameTime::SynchronizedTimeToString(TimeNextRoute));
        }
        Save();
    }

    // Проверка маршрута и уточнение координат конечной точки маршрута
    // Актуально только для TYPE_TRAVEL
    bool ValidateRoute(float worldX, float worldY)
    {
        if (MapIdTo == ZERO_IDENT) {
            return false;
        }
        Map map = Game.GetMap(MapIdTo);
        if (!valid(map)) {
            return false;
        }
        Location loc = map.GetLocation();
        if (!valid(loc)) {
            return false;
        }
        worldX = loc.WorldPos.x;
        ;
        worldY = loc.WorldPos.y;
        return true;
    }

    // Проверка, что нпц не застрял на глобале
    void SetCheck()
    {
        Critter cr = GetTraveller();
        if (!valid(cr)) {
            return;
        }

        if (cr.CountTimeEvent(cte_Check) == 0) {
            cr.StartTimeEvent(TIME_CHECK, cte_Check);
        }
        else {
            // Если событие уже существует, не отменяем
            // cr.ChangeTimeEvent(indexes[0], TIME_CHECK, 0);
        }
    }
};

Traveller TravellerFromCritter(ident crId)
{
    if (Game.GetCritter(crId).TravellerRoute.length() == 0) {
        return null;
    }

    Traveller t = Traveller(crId);
    t.Load();
    return t;
}

// Начало путешествия. Либо телепорт, либо переход по глобалу
void cte_Travel(Critter cr)
{
    if (!NpcPlanes::IsNoPlanes(cr) || !valid(cr.GetMap())) {
        timespan delayTicks = NEXT_TRY;
        if (delayTicks != ZERO_TIMESPAN) {
            Game.RepeatCurrentTimeEvent(delayTicks);
        }
    }

    Traveller t = TravellerFromCritter(cr.Id);
    DL("travel started!" + "time next: " + t.TimeNextRoute + ":" + GameTime::SynchronizedTimeToString(Game.SynchronizedTime));
    if (valid(t)) {
        if (t.TravelType == TYPE_TRANSIT) {
            if (!t.TransferToLocation()) {
                DL("Error, can't transit to new location");
                timespan delayTicks = NEXT_TRY;
                if (delayTicks != ZERO_TIMESPAN) {
                    Game.RepeatCurrentTimeEvent(delayTicks);
                }
            }
            else {
                t.SheduleChooseLocation();
                t.SheduleTravel(true);
            }
        }
        else {
            if (!t.BeginTravelToLocation()) {
                DL("Error, can't begin travel to new location");
                timespan delayTicks = NEXT_TRY;
                if (delayTicks != ZERO_TIMESPAN) {
                    Game.RepeatCurrentTimeEvent(delayTicks);
                }
            }
            else {
                t.SetCheck();
            }
        }
    }
    return;
}

// Проверка, достиг ли НПЦ последней точки назначения в отведенное время
// если нет, переносится c  помощью TransferToMap
void cte_Check(Critter cr)
{
    Map map = cr.GetMap();
    if (valid(map) && valid(map.GetLocation()) && !map.GetLocation().AutoGarbage) {
        return;
    }
    Traveller t = TravellerFromCritter(cr.Id);
    if (valid(t)) {
        if (!t.TransferToLocation()) {
            DL("Error, can't transit to new location");
            timespan delayTicks = NEXT_TRY;
            if (delayTicks != ZERO_TIMESPAN) {
                Game.RepeatCurrentTimeEvent(delayTicks);
            }
        }
        else {
            t.Followers.clear();
            t.Save();
            t.SheduleChooseLocation();
            t.SheduleTravel(true);
        }
    }
    return;
}

// Поиск новой точки маршрута нпц, производится при заходе в локацию
void cte_ChooseTravelPoint(Critter cr)
{
    DL("Sheduled");
    Traveller t = TravellerFromCritter(cr.Id);
    if (valid(t)) {
        if (!t.TryFoundNewLocation()) {
            DL("cannot foun new location");
            timespan delayTicks = NEXT_TRY;
            if (delayTicks != ZERO_TIMESPAN) {
                Game.RepeatCurrentTimeEvent(delayTicks);
            }
        }
    }
    return;
}

void cte_ShowLoc(Critter cr)
{
    Map map = cr.GetMap();
    if (valid(map)) {
        Location loc = map.GetLocation();
        if (valid(loc) && loc.Hidden) {
            loc.Hidden = false;
            return;
        }
    }
    timespan delayTicks = TIME_SHOWLOC;
    if (delayTicks != ZERO_TIMESPAN) {
        Game.RepeatCurrentTimeEvent(delayTicks);
    }
}

// Обработка событий
bool _GlobalProcess(Critter cr, int type, Item car, float x, float y, float toX, float toY, float speed, int encounterDescriptor, bool waitForAnswer)
{
    // DL("type: " + type + "; coords " + x + ":" + y + "; pointTo " + toX + ":" + toY + "cr.Id" + cr.Id + "; speed" + speed);
    Traveller t = TravellerFromCritter(cr.Id);
    if (encounterDescriptor != 0) {
        return false; // Энкаунтер
    }
    if (valid(t) && type != Tla::GlobalProcessMove) {
        if (t.ValidateRoute(toX, toY)) {
            if (toX == x && toY == y) // Добрались до точки назначения
            {
                if (Entrance::CritterTransferToMapEntry(cr, t.MapIdTo, HASHI(t.EntryTo))) {
                    cr.HomeMapId = t.MapIdTo;
                    cr.HomeHex = cr.Hex;
                    cr.HomeDir = cr.Dir;
                    t.Followers.clear();
                    t.Save();
                    t.SheduleChooseLocation();
                    t.SheduleTravel(true);

                    // Сброс проверок на застревание при достижении точки назначения
                    if (cr.CountTimeEvent(cte_Check) != 0) {
                        cr.StopTimeEvent(cte_Check);
                    }
                    return true;
                }
            }
            else {
                speed = 2 * GLOBAL_MAP_BASE_SPEED;
                return true;
            }
        }
        else {
            t.SheduleChooseLocation();
        }
    }
    waitForAnswer = false;
    return false;
}

bool _GlobalInvite(Critter cr, Item car, int encounterDescriptor, int combatMode, ident mapId, mpos hex, uint8 dir)
{
    DL("global invite");
    Traveller t = TravellerFromCritter(cr.Id);
    if (valid(t)) {
        t.SheduleTravel(false);
        if (cr.CountTimeEvent(cte_ShowLoc) == 0) {
            cr.StartTimeEvent(TIME_SHOWLOC, cte_ShowLoc);
        }
    }
    return false;
}

// Диалоги
void r_AddFollower(Critter player, Critter npc)
{
    if (!valid(npc)) {
        return;
    }
    Traveller t = TravellerFromCritter(npc.Id);
    if (!valid(t)) {
        return;
    }
    if (valid(t)) {
        t.AddFollower(player.Id);
    }
}

// Проверка, находится ли нпц на энкаунтере или в одной из локаций маршрута
bool d_OnEncounter(Critter player, Critter npc)
{
    if (!valid(npc)) {
        return false;
    }
    Traveller t = TravellerFromCritter(npc.Id);
    if (valid(t)) {
        Map map = npc.GetMap();
        if (!valid(map)) {
            return false;
        }
        Location loc = map.GetLocation();
        if (!valid(loc)) {
            return false;
        }
        return loc.AutoGarbage;
    }
    return false;
}

bool d_NotOnEncounter(Critter player, Critter npc)
{
    if (!valid(npc)) {
        return false;
    }
    Traveller t = TravellerFromCritter(npc.Id);
    if (valid(t)) {
        Map map = npc.GetMap();
        if (!valid(map)) {
            return false;
        }
        Location loc = map.GetLocation();
        if (!valid(loc)) {
            return false;
        }
        return !loc.AutoGarbage;
    }
    return false;
}

void r_BeginTravel(Critter player, Critter npc)
{
    if (!valid(npc)) {
        return;
    }
    Traveller t = TravellerFromCritter(npc.Id);
    if (valid(t)) {
        if (t.BeginTravelToLocation()) {
            t.SetCheck();
        }
    }
}

// Генерация лексем: куда и когда отправится путешественник
void dlg_WhereAndWhen(Critter player, Critter npc, string& lexems)
{
    if (!IS_DIALOG_GENERATED(lexems)) {
        return;
    }
    if (!valid(npc)) {
        return;
    }
    Traveller t = TravellerFromCritter(npc.Id);
    if (!valid(t)) {
        return;
    }
    lexems = "";
    if (t.MapIdTo != ZERO_IDENT) {
        Map map = Game.GetMap(t.MapIdTo);
        if (valid(map)) {
            Location loc = map.GetLocation();
            if (valid(loc)) {
                lexems = "$where@text Locations " + STR_LOC_NAME(loc.ProtoId) + "@";
            }
        }
    }
    if (t.TimeNextRoute != ZERO_SYNCTIME) {
        lexems += "$when" + GameTime::SynchronizedTimeToString(t.TimeNextRoute);
    }
}

#endif

}
