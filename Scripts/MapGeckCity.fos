namespace MapGeckCity // Sort 2
{

#if SERVER

// Author: rifleman17
// Скрипты для города, который можно построить, использовав ГЕКК.
// ГЭКК нужно использовать на пустынном энкаунтере (Content::Location::desert_1..Content::Location::desert_12)

// Свойство, по которому будет проверяться, житель ли это города из ГЕКК или нет
///@ Property Critter Server ident GCityCitizen Mutable Persistent
///@ Property Critter Server int32 MapGeckCityTraderSkillBarter Mutable Persistent
///@ Property Location Server ident[] GeckCityMembers Mutable Persistent
///@ Property Location Server ident GeckCityLeader Mutable Persistent
///@ Property Map Server ident GeckCityDoor Mutable Persistent
///@ Property Map Server int32 GeckCityCharges Mutable Persistent
///@ Property Map Server synctime GeckCityTimeBroken Mutable Persistent

#define STR_WRONG_LOC            (5500) // Это место совершенно не подходит для строительства города из Г.Э.К.К.
#define STR_WRONG_PASS           (5501) // Код неверный. Активация отменена.
#define STR_RIGHT_PASS           (5502) // Код принят. Начат процесс активации Г.Э.К.К.а.
#define STR_ACCESS_LEADER        (5503) // Сохранены сведения о жителе Города. Имя:lex pname
#define STR_ACCESS_MEMBER        (5504) // Поздравляем! Ваши сведения записаны в базу данных Города. Вы получите расширенный доступ ко всем системам.
#define STR_CREATION_END         (5505) // Работа Генератора Эдемских Кущ Компактного завершена. Добро пожаловать в Город из Г.Э.К.К.а!
#define STR_CANT_OPEN_DOOR       (5506) // Электронный замок на этой двери невозможно открыть стандартными способами. От отмычек или динамита не будет никакого толку.
#define STR_CITIZEN_ADDED        (5507) // lex leadername включил вас в списки жителей Города из Г.Э.К.К.
#define STR_CITIZEN_REMOVED      (5508) // lex leadername исключил вас из списка жителей Города из Г.Э.К.К.
#define STR_GENERATOR_CHARGED    (5509) // Генератор заряжен, всего зарядов:lex charges. Примерное время бесперебойной работы барьера, часов:lex time.
#define STR_CONSOLE_OUT_OF_ORDER (5510) // Терминал не функционирует. Система перезагружается.
#define STR_BRAKE_CONSOLE        (5511) // Посмотрим, что здесь можно сделать...
#define LOC_PID_GECK_CITY        (Content::Location::geck_city)
#define CLOSE_DOOR_TIME          (Time::Minutes(1)) // Время в игровых секундах до автоматического закрытия двери. (одна реальная минута
// В этой переменной сохраняется Id локации с городом из Гекка
#define HOMEPOS_RADIUS               (10)    // Радиус, в котором от домашней позиции должен находиться НПЦ, чтобы считалось, что он добрался до места.
#define XP_CREATE_CITY               (25000) // Опыт за создание города
#define FORCE_DIALOG_PLAYER_NOTFOUND (10)    // Номер строки диалога с главным компьютером города, в котором пишется, что игрок не найден
#define FORCE_DIALOG_PLAYER_ADDED    (7)     // Номер строки диалога с главным компьютером города, в котором пишется, что игрок добавлен в списки жителей города
#define FORCE_DIALOG_PLAYER_REMOVED  (8)     // Номер строки диалога с главным компьютером города, в котором пишется, что игрок удален из списков жителей города
#define FORCE_DIALOG_ERROR           (9)     // Неизвестная ошибка
#define ENTRY_CITYHALL               (17)    // Номер гекса на который перемещается житель при входе в город.
#define ENTRY_DOCTOR                 (18)    // Номер гекса клиники, в которую можно привести доктора.
#define ENTRY_TRADER                 (19)    // Номер гекса магазина, в него можно привести торговца.
#define ENTRY_OUTER_TERMINAL         (20)    // Гекс рядом с внешним терминалом
#define ENTRY_GUARD                  (21)    // Гекс для размещения наемных охранников
#define ENTRY_BARMAN                 (22)    // Кафе. Гекс для  бармена
#define ENTRY_BAR                    (23)    // Кафе. Гекс для посетителей
#define ENTRY_CELLAR_ENTRANCE        (24)    // Штабквартира. Гекс перед входом
#define ENTRY_CITIZEN_CAR            (100)   // Два гекса для машин жителей
#define ENTANCE_CITYHALL             (1)     // Порядковый номер входа "штабквартира"
#define ENTRY_CITIZEN_EXIT           (2)     // Специальный закрытый выход для жителей
#define ENTRY_REPLICATOR_TANK        (30)    // Номер гекса, на котором устанавливается репликатор
#define ENTRY_REPLICATOR_SPAWN       hstring("31") // Номер гекса, на котором появляется возрожденный игрок
#define MAPLOOP_0                    (65000)       // Период, на который тратится 1 батарейка в генераторе, при расчете: активен барьер на входе или нет
#define _GetUptime                   #(charges)(int(charges * (MAPLOOP_0 / 1000) / 3600)) // Время в часах игровое в зависимости от числа зарядов
#define CHARGES_MFC                  (10)                                                 // Число зарядов генератора c одного реактора
#define CHARGES_CEC                  (1)                                                  // Число зарядов генератора c одной малой батареи
#define MAX_CELLS                    (100) // Максимальное число батареек за раз, которые можно загрузить в генератор
#define GATES_NET_NUM                (1)   // Номер сети для барьера на входе.
#define CITIZENS_TRADING_SKILL       (10)  // Навык бартера для нпц-торговца в ГизГ
// energy_barrier.fos
#define BM_OFF          (1)
#define BM_ON           (0)
#define BM_HALF_ON      (2)
#define BM_OFF_NO_GUARD (3)

void ModuleInit()
{
    Game.OnGlobalMapCheckEntranceAllowed.Subscribe(entrance_Geck);
}

bool entrance_Geck(Location geck, Critter[] critters, int entrance)
{
    if (geck.ProtoId == Content::Location::geck_city) {
        if (entrance == ENTANCE_CITYHALL) {
            for (int k = 0, l = critters.length(); k < l; k++) {
                Critter cr = critters[k];
                if (valid(cr) && !IsPlayerCitizen(cr, geck)) {
                    return false;
                }
            }
        }
    }
    return true;
}

// Выдача ГЕККА игроку с присвоением скрипта
void r_GiveGeck(Critter cr, Critter npc)
{
    Item geck = cr.AddItem(Content::Item::geck, 1);
    if (valid(geck)) {
        geck.SetupScript(_GeckInit);
    }
}

void _GeckInit(Item geck, bool firstTime)
{
    geck.IsCanUse = true;
    geck.OnCritterUse.Subscribe(_GeckUse);
}

bool _GeckUse(Item geck, Critter cr, int param)
{
    Map map = cr.GetMap();
    if (!valid(map)) {
        return false;
    }

    Location loc = map.GetLocation();
    if (!valid(loc)) {
        return false;
    }

    if (!loc.AutoGarbage) {
        return false;
    }

    if (PidsGroups::Pids_MapDeserts.find(loc.ProtoId) == -1) {
        Messaging::Info(cr, TextPackName::Text, STR_WRONG_LOC);
        return true;
    }

    CreateCity(cr, geck);
    return true;
}

void CreateCity(Critter player, Item geck)
{
    Game.DestroyItem(geck);

    Critter[] grp = {};
    Critter leader = GlobalmapGroupExtended::GetFollowLeader(player);
    if (!valid(leader)) {
        leader = player;
    }

    grp.insertLast(leader);
    GlobalmapGroupExtended::GetFollowGroup(leader, CritterFindType::NonDead, grp);

    Location loc = Location::CreateLocation(LOC_PID_GECK_CITY, ipos(player.WorldPos.x, player.WorldPos.y), grp);
    if (!valid(loc)) {
        return;
    }

    loc.AutoGarbage = false;
    loc.Hidden = false;
    loc.Radius = 6;

    ident[] acceptedPlayers = {};
    for (int i = 0, l = grp.length(); i < l; i++) {
        Critter cr = grp[i];
        if (!valid(cr)) {
            continue;
        }
        if (!cr.ControlledByPlayer) {
            continue;
        }

        if (cr.GCityCitizen != ZERO_IDENT) {
            continue; // Невозможно быть жителем двух городов одновременно
        }

        cr.GCityCitizen = loc.Id;
        acceptedPlayers.insertLast(cr.Id);
        Messaging::Info(leader, TextPackName::Text, STR_ACCESS_LEADER, "$pname" + PlayerRegistration::GetPlayerName(cr.Id));
        Messaging::Info(cr, TextPackName::Text, STR_ACCESS_MEMBER);
        cr.Experience += XP_CREATE_CITY;
        Messaging::Info(cr, TextPackName::Text, 3480, "$exp" + XP_CREATE_CITY);
    }
    Messaging::Info(player, TextPackName::Text, STR_CREATION_END);
    player.AddItem(Content::Item::used_geck, 1);
    loc.GeckCityLeader = player.Id;
    loc.GeckCityMembers = acceptedPlayers;
    leader.TransferToGlobal();
}

// Проверка, является ли криттер жителем данного города из ГЕККА
bool IsPlayerCitizen(Critter cr)
{
    if (!valid(cr)) {
        return false;
    }

    Map map = cr.GetMap();
    if (!valid(map)) {
        return false;
    }

    Location loc = map.GetLocation();
    if (!valid(loc)) {
        return false;
    }

    return IsPlayerCitizen(cr, loc);
}

bool IsPlayerCitizen(Critter cr, Location loc)
{
    if (!valid(cr) || !valid(loc)) {
        return false;
    }

    ident[] acceptedPlayers = loc.GeckCityMembers.clone();
    for (int i = 0; i < acceptedPlayers.length(); i++) {
        if (cr.Id == acceptedPlayers[i]) {
            return true;
        }
    }
    return false;
}

// Проверка, является ли криттер лидером данного города из ГЕККА
// Лидер может исключать или удалять игрока из списка жителей города
bool IsPlayerLeader(Critter cr)
{
    if (!valid(cr)) {
        return false;
    }

    Map map = cr.GetMap();
    if (!valid(map)) {
        return false;
    }

    Location loc = map.GetLocation();
    if (!valid(loc)) {
        return false;
    }

    return loc.GeckCityLeader == cr.Id;
}

// Добавление игрока в списки жителей
bool AddCitizen(Critter leader, Critter player)
{
    if (!valid(leader)) {
        return false;
    }

    Map map = leader.GetMap();
    if (!valid(map)) {
        return false;
    }

    Location loc = map.GetLocation();
    if (!valid(loc)) {
        return false;
    }

    ident[] acceptedPlayers = loc.GeckCityMembers.clone();
    for (int i = 0; i < acceptedPlayers.length(); i++) {
        if (player.Id == acceptedPlayers[i]) {
            return true;
        }
    }

    player.GCityCitizen = loc.Id;
    acceptedPlayers.insertLast(player.Id);
    loc.GeckCityMembers = acceptedPlayers;
    return true;
}

// Исключение игрока из списков жителей
bool RemoveCitizen(Critter leader, Critter player)
{
    if (!valid(leader)) {
        return false;
    }

    Map map = leader.GetMap();
    if (!valid(map)) {
        return false;
    }

    Location loc = map.GetLocation();
    if (!valid(loc)) {
        return false;
    }

    ident[] acceptedPlayers = loc.GeckCityMembers.clone();
    for (int i = 0; i < acceptedPlayers.length(); i++) {
        if (player.Id == acceptedPlayers[i]) {
            acceptedPlayers.removeAt(i);
            loc.GeckCityMembers = acceptedPlayers;
            if (player.GCityCitizen != ZERO_IDENT) {
                player.GCityCitizen = ZERO_IDENT;
            }
            return true;
        }
    }
    return false;
}

// Очистка списка
void ClearCitizens(Critter leader)
{
    if (!valid(leader)) {
        return;
    }

    Map map = leader.GetMap();
    if (!valid(map)) {
        return;
    }

    Location loc = map.GetLocation();
    if (!valid(loc)) {
        return;
    }

    ident[] acceptedPlayers = {};
    acceptedPlayers.insertLast(leader.Id);
    loc.GeckCityMembers = acceptedPlayers;
}

// Работа со списком жителей города
bool d_IsPlayerLeader(Critter player, Critter none)
{
    return IsPlayerLeader(player);
}

int dlg_RemoveCitizen(Critter player, Critter npc, string& playerName)
{
    if (!IS_DIALOG_SAY_MODE(playerName)) {
        return 0;
    }

    Player playerOwner = Game.GetPlayer(playerName);
    if (playerOwner == null) {
        return FORCE_DIALOG_PLAYER_NOTFOUND;
    }

    Critter cr = playerOwner.GetControlledCritter();
    if (cr.Id == player.Id) {
        return FORCE_DIALOG_PLAYER_NOTFOUND;
    }

    if (RemoveCitizen(player, cr)) {
        Messaging::Info(cr, TextPackName::Text, STR_CITIZEN_REMOVED, "$leadername" + PlayerRegistration::GetPlayerName(player.Id));
        return FORCE_DIALOG_PLAYER_REMOVED;
    }

    return FORCE_DIALOG_ERROR;
}

int dlg_AddCitizen(Critter player, Critter npc, string& playerName)
{
    if (!IS_DIALOG_SAY_MODE(playerName)) {
        return 0;
    }

    Critter cr = Game.GetCritter(Game.GetPlayer(playerName).Id);
    if (valid(cr)) {
        if (cr.Id == player.Id) {
            return FORCE_DIALOG_PLAYER_NOTFOUND;
        }
        if (AddCitizen(player, cr)) {
            Messaging::Info(cr, TextPackName::Text, STR_CITIZEN_ADDED, "$leadername" + PlayerRegistration::GetPlayerName(player.Id));
            return FORCE_DIALOG_PLAYER_ADDED;
        }
        else {
            return FORCE_DIALOG_ERROR;
        }
    }
    return FORCE_DIALOG_PLAYER_NOTFOUND;
}

void r_ClearCitizens(Critter player, Critter none)
{
    ClearCitizens(player);
}

// Двери центрального здания (Штабквартиры)
// К штабквартире имеют доступ только граждане города. Гражданами считаются те, кто был в группе, установившей ГЕКК, а также добавленные лидером позже.
// bool s_UseDoorComputer( Critter player, StaticItem scenery, CritterProperty skill, Item item )
bool s_UseDoorComputer(Critter player, StaticItem scenery, Item item, any skill)
{
    if (valid(item) || skill != CritterProperty::SpecialSkillPickOnGround) {
        return true;
    }

    Dialogs::RunDialog(player, Content::Dialog::geck_door_outer, false);
    return true;
}

bool d_IsCitizen(Critter player, Critter npc)
{
    return IsPlayerCitizen(player);
}

bool d_NotCitizen(Critter player, Critter npc)
{
    return !d_IsCitizen(player, npc);
}

void _DoorInit(Item door, bool firstTime)
{
    Map map = Game.GetMap(door.MapId);
    if (valid(map)) {
        map.GeckCityDoor = door.Id;
    }

    door.OnCritterUseSkill.Subscribe(_DoorSkill);
}

bool _DoorSkill(Item door, Critter cr, CritterProperty skill)
{
    if (door.Opened) {
        return false;
    }

    Messaging::Info(cr, TextPackName::Text, STR_CANT_OPEN_DOOR);
    return true;
}

void r_OpenDoor(Critter player, Critter none)
{
    Item door = GetGeckDoor(player.GetMap());
    if (!valid(door)) {
        return;
    }

    Lockers::SwitchLocker(door, true);
    Game.StartTimeEvent(CLOSE_DOOR_TIME, Item::AutoCloseDoor, door.Id); //SavedDeferredCall
}

void r_CloseDoor(Critter player, Critter none)
{
    Item door = GetGeckDoor(player.GetMap());
    if (!valid(door)) {
        return;
    }

    Lockers::SwitchLocker(door, false);
}

Item GetGeckDoor(Map map)
{
    if (!valid(map)) {
        return null;
    }

    return Game.GetItem(map.GeckCityDoor);
}

// Найм НПЦ для службы в своем городе из ГЕККа.
// Нанимать можно только одного НПЦ за раз.
// НПЦ будет следовать за игроком, пока тот не приведет его к месту назначения
Location GetGeckLocation(Critter player)
{
    if (!valid(player) || player.GCityCitizen == ZERO_IDENT) {
        return null;
    }

    return Game.GetLocation(player.GCityCitizen);
}

// Проверка, может ли игрок нанять НПЦ для службы в своем городе
// npcPid - прототип НПЦ
// maxNum - максимальное число НПЦ такого типа на карте
// homeEntry - номер гекса с домашней позицией НПЦ
bool d_CanHireNpc(Critter player, Critter npc, int npcPidHash, int maxNum, int homeEntry)
{
    if (maxNum < 1) {
        return false;
    }

    Location loc = GetGeckLocation(player);
    if (!valid(loc)) {
        return false;
    }

    // На данный момент, локация Город из ГЕККА состоит только из двух карт.
    // НПЦ могут находиться только на первой из них.
    Map map = loc.GetMapByIndex(0);
    if (!valid(map)) {
        return false;
    }

    int count = map.GetCritters(hstring_fromHash(npcPidHash), CritterFindType::Any).length();
    if (count >= int(maxNum)) {
        return false;
    }

    return Entrance::MapCountEntry(map, homeEntry) > count;
}

bool d_CanNotHireNpc(Critter player, Critter npc, int npcPidHash, int maxNum, int homeEntry)
{
    return !d_CanHireNpc(player, npc, npcPidHash, maxNum, homeEntry);
}

bool d_CanHireNpc(Critter player, Critter npc, int maxNum, int homeEntry)
{
    if (!valid(npc)) {
        return false;
    }

    return d_CanHireNpc(player, npc, npc.ProtoId.hash, maxNum, homeEntry);
}

bool d_CanNotHireNpc(Critter player, Critter npc, int maxNum, int homeEntry)
{
    return !d_CanHireNpc(player, npc, maxNum, homeEntry);
}

// Проверка, найдена ли новая домашняя позиция в Городе из ГЕККа для НПЦ
// homeEntry - номер гекса с домашней позицией НПЦ
bool d_HomeFound(Critter player, Critter npc, int homeEntry)
{
    if (!valid(npc)) {
        return false;
    }

    Location loc = GetGeckLocation(player);
    if (!valid(loc)) {
        return false;
    }

    Map map = loc.GetMapByIndex(0);
    if (!valid(map)) {
        return false;
    }

    Map npcMap = npc.GetMap();
    if (!valid(npcMap)) {
        return false;
    }

    if (map.Id != npcMap.Id) {
        return false;
    }

    Entrance::Entry[] entries = Entrance::ParseEntries(map, homeEntry);
    for (int i = 0; i < entries.length(); i++) {
        if (Game.GetDistance(npc.Hex, entries[i].Hex) <= HOMEPOS_RADIUS) {
            return true;
        }
    }
    return false;
}

bool d_NotHomeFound(Critter player, Critter npc, int homeEntry)
{
    return !d_HomeFound(player, npc, homeEntry);
}

// Установка новой домашней позиции для НПЦ рядом с ближайшим Entry гексом
// homeEntry - номер гекса с домашней позицией НПЦ
void r_SetNewHome(Critter player, Critter npc, int homeEntry)
{
    if (!valid(npc)) {
        return;
    }

    Map map = npc.GetMap();
    if (!valid(map)) {
        return;
    }

    Entrance::Entry[] entries = Entrance::ParseEntries(map, homeEntry);
    for (int i = 0; i < entries.length(); i++) {
        if (Game.GetDistance(npc.Hex, entries[i].Hex) <= HOMEPOS_RADIUS) {
            npc.HomeMapId = map.Id;
            npc.HomeHex = entries[i].Hex;
            npc.HomeDir = Game.GetDirection(entries[i].Hex, npc.Hex);
            return;
        }
    }
}

// Скрипт карты
void _MapInit(Map map, bool firstTime)
{
    map.OnCritterIn.Subscribe(_GeckMapInCritter);
    map.StartTimeEvent(Time::Milliseconds(0), Time::Milliseconds(MAPLOOP_0), _GeckMapLoop);
}

void _GeckMapLoop(Map map)
{
    Location loc = map.GetLocation();
    if (!valid(loc)) {
        return;
    }

    if (EnergyBarier::GetNetState(loc.Id, GATES_NET_NUM) == BM_ON) {
        int charges = map.GeckCityCharges;
        if (charges > 0) {
            charges--;
            map.GeckCityCharges = charges;
        }
        else {
            any[] values = {GATES_NET_NUM, loc.Id};
            Game.StartTimeEvent(ZERO_TIMESPAN, EnergyBarier::DisableForceField, values);
        }
    }
}

// Жители сразу попадают в штабквартиру, если заходят на карту города из ГЕККа
// Отменено, теперь попадание на карту зависит определяется функцией входа
// Оставлено на будущее, возможно будет логика для автомобилей
void _GeckMapInCritter(Map map, Critter cr) // obsolete
{
    if (cr.ControlledByPlayer && !cr.ControlledByPlayer) {
        if (IsPlayerCitizen(cr)) {
            // Проверка, что игрок ближе к обычному гексу, чем к выходу для граждан
            mpos hex;
            int distDefault = 0;
            int distCitizen = 0;
            if (Entrance::GetEntryFreeHex(map, ENTRY_DEFAULT, hex)) {
                distDefault = Game.GetDistance(cr.Hex, hex);
            }
            if (Entrance::GetEntryFreeHex(map, ENTRY_CITIZEN_EXIT, hex)) {
                distCitizen = Game.GetDistance(cr.Hex, hex);
            }
            if (distDefault > distCitizen) {
                return;
            }
            if (Entrance::GetEntryFreeHex(map, ENTRY_CITYHALL, hex)) {
                cr.TransferToHex(hex, Game.Random(0, 5));
                TryMoveCar(cr, map);
            }
        }
    }
}

// Отключено до момента, когда будет решена проблема с багажниками
void TryMoveCar(Critter cr, Map map)
{
    Item[] items = {}; // cr.GetItems(ItemProperty::Type, ItemType::Key);
    for (int k = 0; k < items.length(); k++) {
        Item key = items[k];
        Entrance::Entry[] entries = {};
        entries.insertLast(Entrance::ParseEntries(map, ENTRY_CAR));
        entries.insertLast(Entrance::ParseEntries(map, ENTRY_BIG_CAR));
        for (int i = 0; i < entries.length(); i++) {
            Item car = Maps::GetMapCar(map, entries[i].Hex);
            if (valid(car) && car.LockerId == key.LockerId) {
                Entrance::Entry[] entries2 = Entrance::ParseEntries(map, ENTRY_CITIZEN_CAR);
                for (int j = 0; j < entries2.length(); j++) {
                    Entrance::Entry ent = entries[j];
                    if (map.CheckPlaceForItem(ent.Hex, car.ProtoId)) {
                        ItemMovement::MoveItem(car, 1, map, ent.Hex);
                        return;
                    }
                }
            }
        }
    }
}

// Энергобарьер на карте города из ГЭКК требует подпитки батареями
bool d_HasGeneratorCharges(Critter player, Critter npc)
{
    Map map = player.GetMap();
    if (!valid(map)) {
        return false;
    }

    return map.GeckCityCharges > 0;
}

bool d_NoGeneratoreCharges(Critter player, Critter npc)
{
    Map map = player.GetMap();
    if (!valid(map)) {
        return false;
    }
    return map.GeckCityCharges < 1;
}

// bool s_TerminalOuter( Critter player, StaticItem terminal, CritterProperty skill, Item item )
bool s_TerminalOuter(Critter player, StaticItem terminal, Item item, any skill)
{
    Map map = player.GetMap();
    if (valid(map) && map.GeckCityTimeBroken > Game.SynchronizedTime) {
        Messaging::Info(player, TextPackName::Text, STR_CONSOLE_OUT_OF_ORDER);
        return true;
    }
    return EnergyBarier::s_Terminal(player, terminal, item, skill);
}

bool d_IsTerminalBroken(Critter player, Critter npc)
{
    Map map = player.GetMap();
    if (!valid(map)) {
        return false;
    }
    return map.GeckCityTimeBroken > Game.SynchronizedTime;
}

bool d_NotTerminalBroken(Critter player, Critter npc)
{
    return !d_IsTerminalBroken(player, npc);
}

// НПЦ, который может сломать терминал
void r_BrakeTerminal(Critter player, Critter npc)
{
    if (!valid(npc)) {
        return;
    }

    Map map = npc.GetMap();
    mpos hex;
    if (!valid(map) || !Entrance::GetEntryFreeHex(map, ENTRY_OUTER_TERMINAL, hex)) {
        return;
    }

    if (map.GetPathLength(npc, hex, 1) > 0) {
        if (NpcPlanes::AddWalkPlane(npc, 0, hex, 0, true, 1)) {
            NpcPlanes::AddMiscPlane(npc, 0, Time::Seconds(1), MapGeckCity::plane_Brake);
        }
    }
}

void plane_Brake(Critter npc)
{
    Messaging::Say(npc, TextPackName::Text, STR_BRAKE_CONSOLE);
    Map map = npc.GetMap();
    if (valid(map)) {
        map.GeckCityTimeBroken = Game.SynchronizedTime + Time::Hours(16);
    }
}

// Использование батарей на генератор
// bool s_UseGenerator( Critter cr, StaticItem scen, CritterProperty skill, Item item )
bool s_UseGenerator(Critter cr, StaticItem scen, Item item, any skill)
{
    if (!valid(item)) {
        return false;
    }

    Map map = cr.GetMap();
    if (!valid(map)) {
        return false;
    }

    hstring itemPid = item.ProtoId;
    int charges = 0;
    int itemCount = CLAMP(item.Count, 0, MAX_CELLS);
    if (itemPid == Content::Item::small_energy_cell) {
        charges = CHARGES_CEC * itemCount;
    }
    else if (itemPid == Content::Item::micro_fusion_cell) {
        charges = CHARGES_MFC * itemCount;
    }
    if (charges == 0) {
        return false;
    }

    charges = map.GeckCityCharges + charges;
    map.GeckCityCharges = charges;
    Messaging::Info(cr, TextPackName::Text, STR_GENERATOR_CHARGED, "$charges" + charges + "$time" + _GetUptime(charges));
    Game.DestroyItem(item, itemCount);
    return true;
}

bool d_BarrierOn(Critter player, Critter npc)
{
    Map map = player.GetMap();
    if (!valid(map)) {
        return false;
    }

    Location loc = map.GetLocation();
    if (!valid(loc)) {
        return false;
    }

    return (EnergyBarier::GetNetState(loc.Id, GATES_NET_NUM) == BM_ON);
}

bool d_BarrierOff(Critter player, Critter npc)
{
    Map map = player.GetMap();
    if (!valid(map)) {
        return false;
    }

    Location loc = map.GetLocation();
    if (!valid(loc)) {
        return false;
    }

    int state = EnergyBarier::GetNetState(loc.Id, GATES_NET_NUM);
    return (state == BM_OFF || state == BM_OFF_NO_GUARD);
}

void r_SwitchBarrierMode(Critter player, Critter npc, int mode)
{
    Map map = player.GetMap();
    if (!valid(map)) {
        return;
    }

    Location loc = map.GetLocation();
    if (!valid(loc)) {
        return;
    }

    any[] values = {GATES_NET_NUM, loc.Id};
    if (mode == BM_ON) {
        Game.StartTimeEvent(ZERO_TIMESPAN, EnergyBarier::EnableForceField, values);
    }
    else {
        Game.StartTimeEvent(ZERO_TIMESPAN, EnergyBarier::DisableForceField, values);
    }
}

// Общий скрипт для торговца на карте ГЕККа. Торговец должен быть прописан в trader_table.fos
void _GeckTraderInit(Critter cr, bool firstTime)
{
    Trader::_TraderInit(cr, firstTime);
    cr.OnBarter.Subscribe(_GeckTraderBarter);
}

bool _GeckTraderBarter(Critter cr, Critter player, bool attach, int barterCount)
{
    // Для сохранения оригинального значения навыка торговли НПЦ используется VAR_0
    if (cr.MapGeckCityTraderSkillBarter == 0) {
        cr.MapGeckCityTraderSkillBarter = cr.SkillBarter;
    }

    if (attach && barterCount < 2 && IsPlayerCitizen(player)) {
        cr.SkillBarter = CITIZENS_TRADING_SKILL;
    }
    else {
        cr.SkillBarter = cr.MapGeckCityTraderSkillBarter;
    }

    return true;
}

// Проверка на наличие предмета на карте ГизГ
bool d_ItemExist(Critter player, Critter npc, int pidItem)
{
    Location loc = GetGeckLocation(player);
    if (!valid(loc)) {
        return false;
    }

    for (int i = 0; i < loc.GetMapCount(); i++) {
        Map map = loc.GetMapByIndex(i);
        if (map.GetItems(hstring_fromHash(pidItem)).length > 0) {
            return true;
        }
    }

    return false;
}

bool d_NotItemExist(Critter player, Critter npc, int pidItem)
{
    return !d_ItemExist(player, npc, pidItem);
}

void r_AddReplicator(Critter player, Critter npc)
{
    Location loc = GetGeckLocation(player);
    if (!valid(loc)) {
        return;
    }

    // ENTRY_REPLICATOR_TANK
    for (int i = 0, l = loc.GetMapCount(); i < l; i++) {
        Map map = loc.GetMapByIndex(i);
        if (valid(map)) {
            Entrance::Entry entry = Entrance::GetEntry(map, ENTRY_REPLICATOR_TANK, 0);
            if (valid(entry) && !valid(map.GetItem(entry.Hex, Content::Item::replicator_tank))) {
                map.AddItem(entry.Hex, Content::Item::replicator_tank, 1);
                return;
            }
        }
    }
}

void r_SetGeckReplication(Critter player, Critter npc)
{
    Location loc = GetGeckLocation(player);
    if (!valid(loc)) {
        return;
    }

    for (int i = 0, l = loc.GetMapCount(); i < l; i++) {
        Map map = loc.GetMapByIndex(i);
        if (valid(map) && !loc.AutoGarbage) {
            Entrance::Entry entry = Entrance::GetEntry(map, ENTRY_REPLICATOR_SPAWN, 0);
            if (valid(entry)) {
                player.NextReplicationMap = map.Id;
                player.NextReplicationEntry = ENTRY_REPLICATOR_SPAWN;
                return;
            }
        }
    }
}

void AddGeck(Critter cr, int, int, int)
{
    Item geck = cr.AddItem(Content::Item::geck, 1);
    if (valid(geck)) {
        geck.SetupScript(_GeckInit);
    }
}

#endif

}
