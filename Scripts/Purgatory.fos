namespace Purgatory // Sort 3
{

#if SERVER

// Author: rifleman17
// Групповые поединки на локациях. //wip
// Проходят в 4 этапа, участвует несколько команд/групп.
// Ведется учет убийств членами команд.
// Подразумевается, что изначально команды закрыты друг от друга. Доступ к сражению команды получают только на стадии 3.
// TODO: Сделать расписание этапов по эвентам
// * ВНИМАНИЕ: при использовании BattleInfo необходимо включить battle_info.fos в соответствующий скрипт #include'ом, и объявить экземпляр
// BattleInfo bInfo;

#define STAGE_NONE            (0) // Поединок не начинался
#define STAGE_PREPARE         (1) // Идет прием заявок на участие. Известно время начала. На картах появляются наниматели
#define STAGE_BEGIN           (2) // Начало поединка, персонажи помещаются на исходные позиции.
#define STAGE_FIGHT           (3) // Открытие дверей во внутренний двор. Начало сражение.
#define STAGE_FINISH          (4) // Открытие дверей во внешний мир, бой закончен

#define _PlayerName           #(cr)(cr.ControlledByPlayer ? PlayerRegistration::GetPlayerName(cr.Id) : "@text Dialogs " + STR_NPC_NAME_DLG(cr.DialogId) + "@")

#define ANSWER_CONFIRM_INVITE (0)
#define ANSWER_REJECT_INVITE  (1)
#define ANSWER_DELAY_INVITE   (2)

#define STR_PLAYER_JOINED     (7125) // Команда |lex teamColorlex team|lex baseColor К сражению присоединяется |lex teamColorlex name.
#define STR_KILL              (7126) // Участник Испытания |lex team1Colorlex dead|lex baseColor убит участником по имени |lex team2Colorlex killer.

hstring[] LocPids = {Content::Location::den,           Content::Location::klamath,       Content::Location::modoc,         Content::Location::vault_city,
                     Content::Location::gecko,         Content::Location::broken_hills,  Content::Location::new_reno,      Content::Location::sierra_army_depot,
                     Content::Location::vault_15,      Content::Location::ncr,           Content::Location::cathedral,     Content::Location::mariposa,
                     Content::Location::redding,       Content::Location::navarro,       Content::Location::arroyo,        Content::Location::primal_tribe,
                     Content::Location::vault_13,      Content::Location::barter_ground, Content::Location::raiders,       Content::Location::replication_1,
                     Content::Location::replication_2, Content::Location::replication_3, Content::Location::replication_4, Content::Location::replication_hell};

interface IBattleTeamInviteCallback
{
    void OnInvite(Critter cr, bool transit, BattleTeam team);
    void OnTransit(Critter cr);
};
interface IBattleInfoStageChangedHandler
{
    void OnStageChanged(int stage);
};
interface IBattleInfoCallBack
{
    void OnCritterDead(Critter dead, Critter killer);
};

class BattleTeam
{
    int Index;          // Условный индекс команды, начинается с 0
    hstring StartEntry; // Спецгекс, на котором появляются игроки команды во время этапа STAGE_BEGIN
    ident StartMap;     // Индекс карты среди карт локаций, на котором размещается команда
    ident[] Requests = {}; // Id персонажей, подавших заявку на участие в поединке в составе данной команды
    ident[] Players = {};      // Id персонажей, подтвердивших свое участие в поединке
    int TeamKills;             // Счетчик убийств, произведенных персонажами в составе группы
    ident LastPeekedRequestId; // Код персонажа для последней заявки в команде, по которой было отправлено приглашение, получен ответ.
    bool LastRequestAccepted;
    int BattlePoints; // Игровые очки, исходя из количества очков команды формируется призовой фонд
    bool Winner;
    ucolor Color;

    BattleTeam()
    {
        Color = COLOR_LGRAY;
    }

    IBattleTeamInviteCallback CallBackInvite;

    void SetInviteCallback(IBattleTeamInviteCallback callback)
    {
        CallBackInvite = callback;
    }

    bool HasRequest(ident crId)
    {
        return (LastPeekedRequestId == crId || UtilsForArray::FindInArray(Requests, crId) >= 0);
    }

    bool HasPlayer(ident crId)
    {
        return (UtilsForArray::FindInArray(Players, crId) >= 0);
    }

    int CountAlive() // Подсчет персонажей команды, оставшихся вживых
    {
        int alive = 0;
        Critter player;
        for (int i = 0, l = Players.length(); i < l; i++) {
            player = Game.GetCritter(Players[i]);
            if (valid(player) && player.IsAlive()) {
                alive++;
            }
        }
        return alive;
    }

    // Достает Id персонажа, подавшего заявку по порядку
    // Одновременно удаляет его из массива
    ident PeekRequest()
    {
        DL("Peek request");
        ident crId;
        while (crId == ZERO_IDENT) {
            if (Requests.length() == 0) {
                crId = ZERO_IDENT;
                break;
            }
            crId = Requests[0];
            Requests.removeFirst();
            if (!valid(Game.GetCritter(crId))) {
                crId = ZERO_IDENT;
            }
        }
        LastPeekedRequestId = crId;
        DL("founded crId = " + crId);
        return crId;
    }

    bool SendTeamInvite()
    {
        LastRequestAccepted = false;
        ident crId = PeekRequest();
        if (crId != ZERO_IDENT) {
            Critter cr = Game.GetCritter(crId);
            if (valid(cr)) {
                if (cr.ControlledByPlayer) {
                    any[] data = {Index, cr.Id};
                    Game.StartTimeEvent(Time::Seconds(10), CheckInvite, data);
                    Dialogbox::RunDialogBox(cr, DialogBoxType::PurgatoryInvite, 2, "");
                }
                else {
                    LastRequestAccepted = true;
                    bInfo.TeamInviteConfirmed();
                }
                return true;
            }
        }
        return false;
    }

    void ConfirmInvite()
    {
        LastRequestAccepted = true;
        bInfo.TeamInviteConfirmed();
    }

    void RequestToPlayer(Location loc)
    {
        DL("Request confirmed");
        if (!valid(loc)) {
            return;
        }

        Map map = Game.GetMap(StartMap);
        bool transit = true;
        if (valid(map)) {
            Critter cr = Game.GetCritter(LastPeekedRequestId);
            if (valid(cr)) {
                if (!HasPlayer(LastPeekedRequestId)) {
                    Players.insertLast(LastPeekedRequestId);
                }
                if (valid(CallBackInvite)) {
                    CallBackInvite.OnInvite(cr, transit, this);
                }
                if (transit) {
                    DL("Transit critter 2 map" + cr.Id);
                    Entrance::CritterTransferToMapEntry(cr, map.Id, StartEntry);
                    if (valid(CallBackInvite)) {
                        CallBackInvite.OnTransit(cr);
                    }
                }
            }
        }
    }
};

class BattleInfo
{
    ident LocId; // Id локации, на которой идет поединок
    int Stage;   // Текущая стадия события
    int MaxPlayers;
    BattleTeam[] Teams = {};

    IBattleInfoStageChangedHandler StageChangedHandler;
    IBattleInfoCallBack Callback;

    void SetStageHandler(IBattleInfoStageChangedHandler handler)
    {
        StageChangedHandler = handler;
    }

    void SetCallBack(IBattleInfoCallBack callback)
    {
        Callback = callback;
    }

    void AddTeam(hstring entry, ident mapId, ucolor color, IBattleTeamInviteCallback callback)
    {
        BattleTeam t = BattleTeam();
        t.StartMap = mapId;
        t.StartEntry = entry;
        t.Index = Teams.length();
        t.SetInviteCallback(callback);
        t.Color = color;
        Teams.insertLast(t);
    }

    bool HasRequest(ident crId)
    {
        for (int i = 0, l = Teams.length(); i < l; i++) {
            if (Teams[i].HasRequest(crId)) {
                return true;
            }
        }
        return false;
    }

    void AddRequest(int team, ident crId) // Индексация с нуля
    {
        if (!HasRequest(crId) && Teams.length() > 0 && (team + 1 <= Teams.length())) {
            DL("Adding Request. Team#" + team + "; crId = " + crId);
            if (!Teams[team].HasRequest(crId)) {
                Teams[team].Requests.insertLast(crId);
            }
        }
    }

    BattleTeam GetCritterTeam(ident crId)
    {
        DL("get cr team: " + crId);
        for (int i = 0, l = Teams.length(); i < l; i++) {
            if (Stage < STAGE_FIGHT && Teams[i].HasRequest(crId)) {
                return Teams[i];
            }
            if (Teams[i].HasPlayer(crId)) {
                return Teams[i];
            }
        }
        DL("team invalid");
        return null;
    }

    // false - рассылка провалилась
    // true - найдены по одному персонажу в каждой команде
    bool SendTeamsInvite()
    {
        // Порядок рассылки приглашений
        // 1. В списках заявок на участие в каждой команде начинается поиск ПЕРВОГО существующего игрока
        // 2. Если это игрок - ему отправляется приглашение, участие НПЦ сразу подтверждается
        // 3. При каждом ответе игрока, если это согласие, проверяется, все ли команды получили по одному участнику. Если нет, ждем дальше.
        // 4. Если каждая команда получила своего участника, отправляются следующие приглашения по той же схеме.
        // TODO: После отправки каждого приглашения запускать эвенты-проверки, чтобы убедиться что ожидание не ушло в бесконечность.
        int crId;
        for (int i = 0, l = Teams.length(); i < l; i++) {
            if (!Teams[i].SendTeamInvite()) {
                return false; // В одной из команд некому отправлять приглашение
            }
        }
        return true;
    }

    void TeamInviteConfirmed()
    {
        // Подтверждение заявки одной из команд
        for (int i = 0, l = Teams.length(); i < l; i++) {
            if (!Teams[i].LastRequestAccepted) { // Найдена команда, не подтвердившая последний запрос
                return;
            }
            if (Teams[i].LastPeekedRequestId != ZERO_IDENT) { // В одной из команд кончились персонажи, подавшие заявку
                return;
            }
        }
        // Перенос согласившихся игроков на поле боя
        for (int i = 0, l = Teams.length(); i < l; i++) {
            Teams[i].RequestToPlayer(Game.GetLocation(LocId));
            Teams[i].LastRequestAccepted = false;
        }
        // Следующая итерация 2ой, 3ий, четвертый участник в каждой команде и т.д.
        SendTeamsInvite();
    }

    void Notify() // Сообщение о смене этапа поединка
    {
        if (valid(StageChangedHandler)) {
            StageChangedHandler.OnStageChanged(Stage);
        }
    }

    void PrepareBattle()
    {
        Stage = STAGE_PREPARE;
        Notify();
        for (int i = 0, l = Teams.length(); i < l; i++) {
            Teams[i].Winner = false;
            Teams[i].Requests.clear();
            Teams[i].Players.clear();
            Teams[i].TeamKills = 0;
            Teams[i].LastPeekedRequestId = ZERO_IDENT;
            Teams[i].LastRequestAccepted = false;
            Teams[i].BattlePoints = 0;
        }
    }

    void BeginBattle()
    {
        Stage = STAGE_BEGIN;
        Location loc = Game.GetLocation(LocId);
        if (valid(loc)) {
            Map[] maps = loc.GetMaps();
            if (maps != null && maps.length() > 0) {
                for (int i = 0, l = maps.length(); i < l; i++) {
                    maps[i].OnCritterIn.Subscribe(_BattleMapCritterIn);
                }
            }
        }
        SendTeamsInvite();
        Notify();
    }

    void Fight()
    {
        Stage = STAGE_FIGHT;
        Notify();
        Location loc = Game.GetLocation(LocId);
        if (valid(loc)) {
            Map[] maps = loc.GetMaps();
            if (maps.length() > 0) {
                for (int i = 0, l = maps.length(); i < l; i++) {
                    maps[i].OnCritterDead.Subscribe(_BattleMapCritterDead);
                }
            }
        }
        // Для НПЦ добавляем всех игроков из других команд во врагов
        Critter cr;
        for (int i = 0, l = Teams.length(); i < l; i++) {
            for (int j = 0, k = Teams[i].Players.length(); j < k; j++) {
                cr = Game.GetCritter(Teams[i].Players[j]);
                if (valid(cr) && !cr.ControlledByPlayer) {
                    for (int m = 0, n = Teams.length(); m < n; m++) {
                        if (i != m) {
                            for (int x = 0, z = Teams[m].Players.length(); x < z; x++) {
                                EnemyStack::AddEnemyToStack(cr, Teams[m].Players[x]);
                                NpcPlanes::AddAttackPlane(cr, 0, Teams[m].Players[x]);
                            }
                        }
                        NpcPlanes::AddWalkPlane(cr, Teams[m].StartEntry, 5, true);
                    }
                    cr.StartTimeEvent(Time::Minutes(5), cte_BattleNpcSearchForTarget);
                }
            }
        }
    }

    void CheckWinner()
    {
        // победитель известен, если число
        int activeTeams = 0;
        for (int i = 0, l = Teams.length(); i < l; i++) {
            if (Teams[i].CountAlive() > 0) {
                activeTeams++;
            }
        }
        if (activeTeams == 1) {
            for (int i = 0, l = Teams.length(); i < l; i++) {
                if (Teams[i].CountAlive() > 0) {
                    Teams[i].Winner = true;
                    Teams[i].BattlePoints += Teams[i].CountAlive(); // Бонус к очкам за живых членов команды
                }
            }
        }
        if (activeTeams < 2) // может быть ни одного победителя, если все мертвы
        {
            Finish();
        }
    }

    void Finish()
    {
        Critter cr;
        Stage = STAGE_FINISH;
        Notify();
        Location loc = Game.GetLocation(LocId);
        if (valid(loc)) {
            Map[] maps = loc.GetMaps();
            if (maps.length() > 0) {
                for (int i = 0, l = maps.length(); i < l; i++) {
                    // maps[ i ].SetEvent( MAP_EVENT_CRITTER_DEAD, "" );
                    maps[i].OnCritterDead.Unsubscribe(_BattleMapCritterDead);
                }
            }
        }
        for (int i = 0, l = Teams.length(); i < l; i++) {
            for (int j = 0, k = Teams[i].Players.length(); j < k; j++) {
                cr = Game.GetCritter(Teams[i].Players[j]);
                if (valid(cr) && !cr.ControlledByPlayer) {
                    // НПЦ возвращаются на домашние позиции, иначе карта не будет удалена да и вообще возможны проблемы
                    cr.StartTimeEvent(Time::Minutes(Game.Random(1, 2)), cte_RemoveNpc);
                }
            }
        }
    }

    BattleTeam GetWinnerTeam()
    {
        for (int i = 0, l = Teams.length(); i < l; i++) {
            if (Teams[i].Winner) {
                return Teams[i];
            }
        }
        return null;
    }
};

// Вспомогательные функции

// Оповещения
// Приглашение на участие
void answer_BattleInvite(Critter player, int answerI)
{
    DL("Answer called. Answ " + answerI);
    BattleTeam bt = bInfo.GetCritterTeam(player.Id);
    if (valid(bt) && bt.LastPeekedRequestId == player.Id) {
        DL("team valid");
        if (answerI == ANSWER_CONFIRM_INVITE) {
            DL("Invite confirmed");
            bt.ConfirmInvite();
            return;
        }
        bt.SendTeamInvite();
    }
}

// Если по каким то причинам последняя заявка не получила ответа, или игрок слишком долго думает
void CheckInvite(any[] values)
{
    BattleTeam bt = bInfo.Teams[values[0]];
    ident crId = values[1];
    if (crId == bt.LastPeekedRequestId) {
        bt.SendTeamInvite();
    }
}

// Диалоги
// Проверка стадии
bool d_IsStage(Critter player, Critter npc, int stage)
{
    return bInfo.Stage == stage;
}

// Может ли персонаж подать заявку
bool d_CanRequestBattle(Critter player, Critter npc)
{
    return d_IsStage(player, npc, STAGE_PREPARE);
}

// Игрок в составе любой из команд
bool d_PlayerRequested(Critter player, Critter npc)
{
    return bInfo.HasRequest(player.Id);
}

// Игрок не в составе
bool d_PlayerNotRequested(Critter player, Critter npc)
{
    return !bInfo.HasRequest(player.Id);
}

bool d_IsEnemy(Critter player, Critter npc)
{
    BattleTeam tPlayer = bInfo.GetCritterTeam(player.Id);
    BattleTeam tNpc = bInfo.GetCritterTeam(npc.Id);

    return (bInfo.Stage >= STAGE_BEGIN && bInfo.Stage <= STAGE_FIGHT && valid(tPlayer) && valid(tNpc) && tPlayer.StartMap == tNpc.StartMap &&
            tPlayer.Index != tNpc.Index);
}

bool d_IsFriend(Critter player, Critter npc)
{
    BattleTeam tPlayer = bInfo.GetCritterTeam(player.Id);
    BattleTeam tNpc = bInfo.GetCritterTeam(npc.Id);

    return (bInfo.Stage >= STAGE_BEGIN && bInfo.Stage <= STAGE_FIGHT && valid(tPlayer) && valid(tNpc) && tPlayer.StartMap == tNpc.StartMap &&
            tPlayer.Index == tNpc.Index);
}

// Запись заявки на участие
// team - индекс команды в поединке, начиная с 0
void r_SaveRequest(Critter player, Critter npc, int team)
{
    bInfo.AddRequest(team, player.Id);
}

// генерация лексем: Количество поданных заявок, за команду и всего
// число заявок в команде пишется в виде lex team1
// общее число заявок lex total
void dlg_TeamCount(Critter player, Critter npc, string& lexems)
{
    if (!IS_DIALOG_GENERATED(lexems)) {
        return;
    }
    lexems = "";
    int total = 0;
    for (int i = 0, l = bInfo.Teams.length(); i < l; i++) {
        lexems = lexems + "$team" + i + bInfo.Teams[i].Requests.length();
        total += bInfo.Teams[i].Requests.length();
    }
    lexems = lexems + "$total" + total;
}

void cte_RemoveNpc(Critter cr)
{
    if (!cr.ControlledByPlayer) {
        Map map = Game.GetMap(cr.HomeMapId);
        if (cr.HomeMapId != ZERO_IDENT && map !is null) {
            cr.TransferToMap(map, cr.HomeHex, cr.HomeDir);
            return;
        }
        // домашняя позиция не найдена или карта уже удалена
        Game.DestroyCritter(cr);
    }
    return;
}

void cte_BattleNpcSearchForTarget(Critter cr)
{
    if (cr.IsAlive() && NpcPlanes::IsNoPlanes(cr) && valid(bInfo)) {
        BattleTeam team = bInfo.GetCritterTeam(cr.Id);
        if (valid(team)) {
            for (int i = 0, n = bInfo.Teams.length(); i < n; i++) {
                if (team.Index != i) {
                    for (int x = 0, z = bInfo.Teams[i].Players.length(); x < z; x++) {
                        EnemyStack::AddEnemyToStack(cr, bInfo.Teams[i].Players[x]);
                        NpcPlanes::AddAttackPlane(cr, 0, bInfo.Teams[i].Players[x]);
                    }
                }
                NpcPlanes::AddWalkPlane(cr, bInfo.Teams[i].StartEntry, 5, true);
            }
        }
    }
    timespan delayTicks = Time::Minutes(1);
    if (delayTicks != ZERO_TIMESPAN) {
        Game.RepeatCurrentTimeEvent(delayTicks);
    }
}

// Предметы
// Дверь/контейнер, открываемые только в определенную стадию
// Value1 - указывается минимальный номер этапа, начиная с которого контейнер/дверь будут открыты
// Value2 - если это значение больше 0, контейнер доступен только для участников сражения
// Value3 - ели значение больше 0, контейнер доступен только победителям
#define STR_STAGE_ERROR  (7001) // Невозможно использовать. Возможно, нужно дождаться следующего этапа сражения.
#define STR_PLAYER_ERROR (7002) // Невозможно использовать. Доступ только для участников сражения.
#define STR_WINNER_ERROR (7003) // Невозможно использовать. Доступ только для победителей.
void _BattleDoorInit(Item item, bool firstTime)
{
    item.OnCritterUseSkill.Subscribe(_UseBattleDoor);
}

bool _UseBattleDoor(Item item, Critter cr, CritterProperty skill)
{
    if (int(bInfo.Stage) < item.Val1) {
        Messaging::Info(cr, TextPackName::Text, STR_STAGE_ERROR);
        return true;
    }
    BattleTeam bt = bInfo.GetCritterTeam(cr.Id);
    if (item.Val2 > 0) {
        if (!valid(bt)) {
            Messaging::Info(cr, TextPackName::Text, STR_PLAYER_ERROR);
            return true;
        }
    }
    if (item.Val3 > 0) {
        if (!bt.Winner) {
            Messaging::Info(cr, TextPackName::Text, STR_WINNER_ERROR);
            return true;
        }
    }
    return false;
}

// Карты
void _BattleMapCritterDead(Map map, Critter cr, Critter killer)
{
    // Убитый должен быть членом одной из команд, чтобы убийство пошло в зачет
    BattleTeam btDead = bInfo.GetCritterTeam(cr.Id);
    if (valid(bInfo.Callback)) {
        bInfo.Callback.OnCritterDead(cr, killer);
    }
    if (!valid(btDead)) {
        return;
    }
    if (valid(killer)) {
        BattleTeam btKiller = bInfo.GetCritterTeam(killer.Id);
        if (valid(btKiller)) {
            btKiller.BattlePoints += GetPoints(cr, killer);
            PlayerDeadMessage(cr, killer, map);
            btKiller.TeamKills++;
        }
    }
    bInfo.CheckWinner();
}

void _BattleMapCritterIn(Map map, Critter cr)
{
    DL("critter in");
    BattleTeam team = bInfo.GetCritterTeam(cr.Id);
    DL("stage: " + bInfo.Stage);
    if (valid(team) && bInfo.Stage == STAGE_BEGIN) {
        DL("get critters");
        Critter[] critters = map.GetCritters(CritterFindType::Players);
        for (int i = 0; i < critters.length(); i++) {
            DL("messagin");
            PlayerJoinedMessage(cr, critters[i]);
        }
    }
}

// Сообщения
void PlayerJoinedMessage(Critter cr, Critter crTo)
{
    DL("joined msg");
    if (!valid(crTo)) {
        return;
    }
    DL("Check team");
    BattleTeam team = bInfo.GetCritterTeam(cr.Id);
    if (!valid(team)) {
        return;
    }
    string lexems = "$baseColor" + COLOR_TEXT;
    lexems += "$team" + (team.Index + 1) + "$teamColor" + team.Color;
    lexems += "$name" + _PlayerName(cr);
    DL(lexems);
    Messaging::Info(crTo, TextPackName::Text, STR_PLAYER_JOINED, lexems);
}

void PlayerDeadMessage(Critter crDead, Critter crKiller, Map map)
{
    if (!valid(map) || !valid(crKiller)) {
        return;
    }
    BattleTeam teamDead = bInfo.GetCritterTeam(crDead.Id);
    BattleTeam teamKill = bInfo.GetCritterTeam(crKiller.Id);
    if (valid(teamDead) && valid(teamKill)) {
        string lexems = "$baseColor" + COLOR_TEXT;
        lexems += "$team1Color" + teamDead.Color + "$dead" + _PlayerName(crDead);
        lexems += "$team2Color" + teamKill.Color + "$killer" + _PlayerName(crKiller);
        Critter[] critters = map.GetCritters(CritterFindType::Players);
        for (int i = 0; i < critters.length(); i++) {
            Messaging::Info(critters[i], TextPackName::Text, STR_KILL, lexems);
        }
        DL(lexems);
    }
}

string GetTeamPlayers(BattleTeam team)
{
    string teamText = "";
    if (valid(team)) {
        Critter cr;
        int l = bInfo.Stage >= STAGE_BEGIN ? team.Players.length() : team.Requests.length();
        if (l == 0) {
            teamText += "@text Text 7127@";
        }
        else {
            for (int i = 0; i < l; i++) {
                cr = Game.GetCritter(bInfo.Stage >= STAGE_BEGIN ? team.Players[i] : team.Requests[i]);
                if (valid(cr)) {
                    teamText += _PlayerName(cr) + " (" + cr.Level + ")";
                    if (cr.IsDead()) {
                        teamText += "[Dead]";
                    }
                    teamText += "\n";
                }
                else {
                    teamText += PlayerRegistration::GetPlayerName(team.Players[i]) + "[Offline]\n";
                    // оффлайн персонаж
                }
            }
        }
    }
    DL(teamText);
    return teamText;
}

int GetPoints(Critter cr, Critter killer)
{
    if (!valid(cr) || !valid(killer)) {
        return 0;
    }
    BattleTeam teamCr = bInfo.GetCritterTeam(cr.Id);
    BattleTeam teamKiller = bInfo.GetCritterTeam(killer.Id);
    if (!valid(teamCr) || !valid(teamKiller)) {
        return -1;
    }
    int points = 1;
    if (killer.ControlledByPlayer) {
        points++;
    }
    if (cr.ControlledByPlayer) {
        points++;
    }
    if (killer.Level <= cr.Level) {
        points += 3;
    }
    if (cr.Level > 10) {
        points += 2;
    }
    if (cr.Level > 20) {
        points += 3;
    }
    if (cr.Level > 30) {
        points += 5;
    }
    if (killer.Luck > 4) {
        points++;
    }
    // Максимум за одного убитого 17 очков
    // Максимум за бой, если команда убила всех противников
    // 17*3*6 = 306
    // Чем меньше участников, чем ниже их уровень, тем ниже шансы получить что-то полезное
    return (teamCr.Index == teamKiller.Index ? (-1) * points : points);
}

void test(Critter crp, any id)
{
    Critter crDead = Game.GetCritter(id);
    string lexems = "$baseColor" + COLOR_TEXT;
    lexems += "$team1Color" + COLOR_RED + "$dead" + _PlayerName(crDead);
    lexems += "$team2Color" + COLOR_BLUE + "$killer" + _PlayerName(crp);
    Critter[] critters = crp.GetMap().GetCritters(CritterFindType::Players);
    for (int i = 0; i < critters.length(); i++) {
        Messaging::Info(critters[i], TextPackName::Text, STR_KILL, lexems);
    }
    DL(lexems);
}

///@ Property Location Server synctime LastLootTransfer Mutable Persistent

#define TIME_NEXT_RADIO_STAGE1 (Time::Minutes(5))
#define STR_RADIO_STAGE1 \
    (7120) // Внимание! Открыт набор участников для Испытания в Чистилище. Для того, чтобы подать заявку найдите Экзекутора на входе любого города Пустоши.
#define STR_KILL          (7121) // Мощный электрически разряд из пипбоя отправляет вас на небеса. Правда, вам показалось, что удар был нанесен в шею, откуда-то сзади.
#define STR_ITEMS         (7122)
#define SPAWN_ENTRY       #(locPid)((locPid == Content::Location::replication_hell) ? hstring("242") : hstring("0"))
#define ENTRY_NOPVP_FIRST (100)              // Первый спецгекс нопвп зоны
#define ENTRY_NOPVP_LAST  (103)              // Первый спецгекс нопвп зоны
#define CTE_NOPVP_OFF     (42)               // Идентификатор события "очистить нопвп режим"
#define TIME_CHECK        (Time::Minutes(1)) // Время проверки, не вышел ли игрок с нопвп зоны
#define PURGATORY_WORLD_X (800)
#define PURGATORY_WORLD_Y (500)
#define ENTRY_TEAM_1      (hstring("33"))
#define ENTRY_TEAM_2      (hstring("34"))
#define ENTRY_TEAM_3      (hstring("35"))
#define ENTRY_TEAM_4      (hstring("36"))

#define _RndCont          #(containers)(containers[Game.Random(0, containers.length() - 1)])

BattleInfo bInfo;

ident TeamContainerId; // код контейнера для игроков в составе команды

// Обработчики смены состояний и инвайта

class PurgatoryStageChangedHandler : IBattleInfoStageChangedHandler, IBattleInfoCallBack
{
    void OnStageChanged(int stage)
    {
        if (bInfo.Stage == STAGE_FIGHT) {
            Radio::SendChannelRadioMessage(0, TextPackName::Text, 7132);
            Location loc = Game.GetLocation(Content::Location::hub_purgatory);
            if (valid(loc)) {
                Map map = loc.GetMapByIndex(0);
                if (valid(map)) {
                    map.StartTimeEvent(Time::Milliseconds(0), Time::Milliseconds(25000), _PurgatoryLoop);
                    // Раз в 25 секунд
                    Critter[] players = map.GetCritters(CritterFindType::Players);
                    for (int i = 0; i < players.length(); i++) {
                        Messaging::Info(players[i], TextPackName::Text, 7132);
                    }
                }
            }
            return;
        }

        if (bInfo.Stage == STAGE_FINISH) {
            // Завершение испытания
            Location loc = Game.GetLocation(Content::Location::hub_purgatory);
            if (valid(loc)) {
                loc.Hidden = true;
                loc.AutoGarbage = true;
                Game.StartTimeEvent(Time::GameMinutes(20), DeletePurgatory, loc.Id); //SavedDeferredCall
            }

            BattleTeam winners = bInfo.GetWinnerTeam();
            if (valid(winners)) {
                Map mapInfo = loc.GetMapByIndex(0);
                Critter[] players = mapInfo.GetCritters(CritterFindType::Players);
                for (int i = 0; i < players.length(); i++) {
                    Messaging::Info(players[i], TextPackName::Text, 7131, "$team" + (winners.Index + 1));
                }

                int points = winners.BattlePoints;
                int alive = winners.CountAlive();
                Map map = loc.GetMapByIndex(1);

                Item[] containers = map.GetItems(ItemProperty::Type, ItemType::Container);
                if (!containers.isEmpty()) {
                    Item[] prizeContainers = {};
                    for (int i = 0; i < containers.length(); i++) {
                        if (containers[i].Val0 != 0) {
                            prizeContainers.insertLast(containers[i]);
                        }
                    }

                    if (!prizeContainers.isEmpty() && points > 0) {
                        // Раздача призов
                        // Сначала обязательные призы
                        for (int i = 0; i < alive; i++) {
                            _RndCont(prizeContainers).AddItem(Content::Item::bottle_caps, points * 50, ROOT_CONTAINER_STACK);
                            _RndCont(prizeContainers).AddItem(Content::Item::metal_armor_mk_ii, 1, ROOT_CONTAINER_STACK);
                            _RndCont(prizeContainers).AddItem(Content::Item::_223_pistol, 1, ROOT_CONTAINER_STACK);
                            _RndCont(prizeContainers).AddItem(Content::Item::_223_fmj, points * 2, ROOT_CONTAINER_STACK);
                            _RndCont(prizeContainers).AddItem(Content::Item::stimpak, 5, ROOT_CONTAINER_STACK);
                        }

                        int rnd = Game.Random(1, 3);
                        // ПА
                        if (points > 200 && rnd == 1) {
                            _RndCont(prizeContainers).AddItem(Content::Item::powered_armor, 1, ROOT_CONTAINER_STACK);
                            points -= 50;
                        }
                        if (points > 200) {
                            _RndCont(prizeContainers).AddItem(Content::Item::cats_paw_issue_5, 2, ROOT_CONTAINER_STACK);
                        }
                        if (points > 200) {
                            if (rnd == 1) {
                                _RndCont(prizeContainers).AddItem(Content::Item::m72_gauss_rifle, Game.Random(1, 2), ROOT_CONTAINER_STACK);
                                _RndCont(prizeContainers).AddItem(Content::Item::_2mm_ec_ammo, Game.Random(333, 444), ROOT_CONTAINER_STACK);
                            }
                            if (rnd == 2) {
                                _RndCont(prizeContainers).AddItem(Content::Item::vindicator_minigun, Game.Random(1, 2), ROOT_CONTAINER_STACK);
                                _RndCont(prizeContainers).AddItem(Content::Item::_4_7mm_caseless, Game.Random(4000, 6000), ROOT_CONTAINER_STACK);
                            }
                            if (rnd == 3) {
                                _RndCont(prizeContainers).AddItem(Content::Item::yk42b_pulse_rifle, Game.Random(1, 2), ROOT_CONTAINER_STACK);
                                _RndCont(prizeContainers).AddItem(Content::Item::turbo_plasma_rifle, Game.Random(1, 2), ROOT_CONTAINER_STACK);
                                _RndCont(prizeContainers).AddItem(Content::Item::micro_fusion_cell, Game.Random(200, 300), ROOT_CONTAINER_STACK);
                            }
                            points -= 50;
                        }
                        if (points > 150) {
                            for (int i = 0; i < alive; i++) {
                                _RndCont(prizeContainers).AddItem(Content::Item::combat_armor, 1, ROOT_CONTAINER_STACK);
                                _RndCont(prizeContainers).AddItem(Content::Item::fn_fal_hpfa, 1, ROOT_CONTAINER_STACK);
                                _RndCont(prizeContainers).AddItem(Content::Item::avenger_minigun, 1, ROOT_CONTAINER_STACK);
                                _RndCont(prizeContainers).AddItem(Content::Item::_5mm_jhp, 500, ROOT_CONTAINER_STACK);
                            }
                            points -= 50;
                        }
                        if (points > 100) {
                            _RndCont(prizeContainers).AddItem(Content::Item::super_stimpak, 4 * alive, ROOT_CONTAINER_STACK);
                            _RndCont(prizeContainers).AddItem(Content::Item::psycho, 5 * alive, ROOT_CONTAINER_STACK);
                            _RndCont(prizeContainers).AddItem(Content::Item::hypo, 2 * alive, ROOT_CONTAINER_STACK);
                            points -= 50;
                        }
                        if (points > 50) {
                            _RndCont(prizeContainers).AddItem(Content::Item::super_stimpak, 5 * alive, ROOT_CONTAINER_STACK);
                            _RndCont(prizeContainers).AddItem(Content::Item::buffout, 2 * alive, ROOT_CONTAINER_STACK);
                            _RndCont(prizeContainers).AddItem(Content::Item::jet, 2 * alive, ROOT_CONTAINER_STACK);
                            _RndCont(prizeContainers).AddItem(Content::Item::big_book_of_science, 2, ROOT_CONTAINER_STACK);
                            _RndCont(prizeContainers).AddItem(Content::Item::first_aid_book, 2, ROOT_CONTAINER_STACK);
                            _RndCont(prizeContainers).AddItem(Content::Item::scout_handbook, 2, ROOT_CONTAINER_STACK);
                            _RndCont(prizeContainers).AddItem(Content::Item::guns_and_bullets, 2, ROOT_CONTAINER_STACK);
                        }
                    }
                }
            }
        }
    }

    void OnCritterDead(Critter dead, Critter killer)
    {
        BattleTeam btDead = bInfo.GetCritterTeam(dead.Id);
        BattleTeam btKiller = bInfo.GetCritterTeam(killer.Id);
        if (valid(btKiller) && valid(btDead) && killer.ControlledByPlayer) {
            if (btKiller.Index == btDead.Index) {
                killer.ReplicationMoney -= 1000;
                Messaging::Info(killer, TextPackName::Text, 7129);
            }
            else {
                int xp = killer.Level * 100;
                killer.ReplicationMoney += 300;
                killer.Experience += xp;
                Messaging::Info(killer, TextPackName::Text, 7130, "$xp" + xp);
            }
        }
    }
}

bool
NeedReplicateCritterToBattle(Critter cr)
{
    DL("replication called");
    if (valid(bInfo) && cr.NextReplicationMap != ZERO_IDENT && cr.NextReplicationEntry != EMPTY_HSTRING) {
        BattleTeam team = bInfo.GetCritterTeam(cr.Id);
        if (valid(team) && bInfo.Stage == STAGE_BEGIN) {
            if (team.StartMap == cr.NextReplicationMap && team.StartEntry == cr.NextReplicationEntry) {
                cr.ReplicationMoney += cr.ReplicationCost;
                cr.ReplicationCount -= 1;
                return true;
            }
        }
    }
    DL("false");
    return false;
}

class PurgatoryInviteCallback : IBattleTeamInviteCallback
{
    void OnInvite(Critter cr, bool transit, BattleTeam team)
    {
        if (valid(cr) && !cr.ControlledByPlayer) {
            return;
        }

        Item container;
        if (TeamContainerId != ZERO_IDENT) {
            container = Game.GetItem(TeamContainerId);
        }

        if (!valid(cr)) {
            return;
        }

        if (valid(container)) {
            Item[] items = cr.GetItems();
            ItemMovement::MoveItems(items, container, MAKE_CONTAINER_STACK(cr.Id));
        }

        CritterState::ToDead(cr, CritterActionAnim::DeadPulseDust, null);
        Messaging::Info(cr, TextPackName::Text, STR_KILL);
        Messaging::Info(cr, TextPackName::Text, STR_ITEMS);
        if (valid(team)) {
            cr.NextReplicationMap = team.StartMap;
            cr.NextReplicationEntry = team.StartEntry;
        }

        transit = false;
    }

    void OnTransit(Critter cr)
    {
        // не требуется
    }
}

PurgatoryStageChangedHandler stageHandler;
PurgatoryInviteCallback inviteCallback;

void RunPreparationStage()
{
    Game.Log("purg RunPreparationStage");
    bInfo = BattleInfo();
    bInfo.SetStageHandler(stageHandler);
    bInfo.SetCallBack(stageHandler);
    Location loc = Game.GetLocation(Content::Location::hub_purgatory);
    if (valid(loc)) {
        loc.Hidden = true;
        loc.AutoGarbage = true;
    }

    loc = Location::CreateLocation(Content::Location::hub_purgatory, ipos(PURGATORY_WORLD_X, PURGATORY_WORLD_Y), null);
    if (!valid(loc)) {
        return;
    }

    bInfo.LocId = loc.Id;
    Map map = loc.GetMapByIndex(0);
    bInfo.AddTeam(ENTRY_TEAM_1, map.Id, COLOR_SAND, inviteCallback);
    bInfo.AddTeam(ENTRY_TEAM_2, map.Id, COLOR_LBLUE, inviteCallback);
    bInfo.AddTeam(ENTRY_TEAM_3, map.Id, COLOR_LRED, inviteCallback);
    bInfo.AddTeam(ENTRY_TEAM_4, map.Id, COLOR_GREEN_RED, inviteCallback);
    bInfo.PrepareBattle();
    mpos hex;

    // Расстановка нпц-нанимателей
    for (int i = 0; i < LocPids.length(); i++) {
        if (LOCATION_IS_CITY(LocPids[i]) || LocPids[i] == Content::Location::replication_hell) {
            loc = Game.GetLocation(LocPids[i]);
            if (!valid(loc)) {
                continue;
            }

            map = loc.GetMapByIndex(0);
            if (!valid(map)) {
                continue;
            }

            if (Entrance::GetNearEntry(map, SPAWN_ENTRY(LocPids[i]), hex)) {
                int[] props = {CritterProperty::DialogId,
                               Content::Dialog::purg_executor.hash,
                               CritterProperty::TeamId,
                               Teams::Slaver,
                               CritterProperty::AiId,
                               Fallout2AIPackets::BountyHunter,
                               CritterProperty::BagId,
                               Bags::NavarroEnclavePatrolMale2,
                               CritterProperty::Level,
                               50,
                               CritterProperty::IsNoLoot,
                               1,
                               CritterProperty::IsNoKnock,
                               1,
                               CritterProperty::IsNoLooseLimbs,
                               1,
                               CritterProperty::IsNoEnemyStack,
                               1,
                               CritterProperty::IsNoSteal,
                               1,
                               CritterProperty::IsUnlimitedAmmo,
                               1,
                               CritterProperty::PerkTerminator,
                               1,
                               CritterProperty::PerkLivingAnatomy,
                               1,
                               CritterProperty::PerkBetterCriticals,
                               1,
                               CritterProperty::PerkBonusRateOfFire,
                               1,
                               CritterProperty::ActionPointsBase,
                               30,
                               CritterProperty::SkillEnergyWeapons,
                               300,
                               CritterProperty::StrengthBase,
                               10,
                               CritterProperty::EnduranceBase,
                               10,
                               CritterProperty::PerkSniper,
                               1,
                               CritterProperty::CriticalChanceBase,
                               100,
                               CritterProperty::NormalResistanceBase,
                               200,
                               CritterProperty::LaserResistanceBase,
                               200,
                               CritterProperty::FireResistanceBase,
                               200,
                               CritterProperty::PlasmaResistanceBase,
                               200,
                               CritterProperty::ExplodeResistanceBase,
                               200,
                               CritterProperty::MaxLifeBase,
                               1000,
                               CritterProperty::CurrentHp,
                               1500};
                Critter npc = map.AddCritter(Content::Critter::ElronologistMale, hex, Game.Random(0, 5), Tla::GetCritPropsDict(props));
                npc.SetupScript(_RiperInit);
                DL("Location pid" + LocPids[i] + " executor placed");
            }
        }
    }
    Game.StartTimeEvent(ZERO_TIMESPAN, RadioPurgatory1); //SavedDeferredCall
}

void RadioPurgatory1()
{
    if (valid(bInfo) && bInfo.Stage == STAGE_PREPARE) {
        Radio::SendChannelRadioMessage(0, TextPackName::Text, STR_RADIO_STAGE1);
        Game.StartTimeEvent(TIME_NEXT_RADIO_STAGE1, RadioPurgatory1); //SavedDeferredCall
    }
}

// экзекуторы

void _RiperInit(Critter cr, bool firstTime)
{
    cr.CurrentHp = cr.MaxLife;
    cr.StartTimeEvent(Time::Minutes(5), cte_RipperShout);
    cr.StartTimeEvent(Time::Asap(), Time::Seconds(1), _RiperIdle);
}

void cte_RipperShout(Critter cr)
{
    if (valid(bInfo) && bInfo.Stage == STAGE_PREPARE) {
        Messaging::SayShout(cr, TextPackName::Dialogs, DLGSTR(cr.DialogId, 1));
        timespan delayTicks = Time::Minutes(9);
        if (delayTicks != ZERO_TIMESPAN) {
            Game.RepeatCurrentTimeEvent(delayTicks);
        }
    }
    return;
}

void _RiperIdle(Critter cr)
{
    cr.CurrentHp = cr.MaxLife;
}

// второй этап: перемещение игроков к бою

void RunBeginStage()
{
    Critter[] critters = {};
    Critter cr;
    Location loc;
    Map map;

    // Добавление в участники каждой команды по одному нпц из хранилища
    // Чтобы бой состоялся, даже есть только один игрок
    map = Game.GetMap(Content::Map::purgatory3);
    if (valid(map)) {
        critters.insertLast(map.GetCritters(CritterFindType::NonDeadNpc));
    }
    for (int i = 0; i < 4 && i < critters.length(); i++) {
        bInfo.AddRequest(i, critters[i].Id);
    }

    bInfo.BeginBattle();

    critters.clear();

    // Удаление экзекуторов
    for (int i = 0; i < LocPids.length(); i++) {
        if (LOCATION_IS_CITY(LocPids[i]) || LocPids[i] == Content::Location::replication_hell) {
            loc = Game.GetLocation(LocPids[i]);
            if (valid(loc)) {
                map = loc.GetMapByIndex(0);
                if (valid(map)) {
                    critters.insertLast(map.GetCritters(Content::Critter::ElronologistMale, CritterFindType::Npc));
                }
            }
        }
    }

    for (int i = 0; i < critters.length(); i++) {
        cr = critters[i];
        if (valid(cr) && cr.DialogId == Content::Dialog::purg_executor) {
            Game.DestroyCritter(cr);
        }
    }
}

// третий этап: начало боя
void RunFightStage()
{
    bInfo.Fight();
}

// четвертый этап: завершение боя после того, как истекло время
void RunEndStage()
{
    if (bInfo.Stage == STAGE_FIGHT) {
        bInfo.Finish();
    }
}

// Карты чистилища
void _PurgatoryInit(Map map, bool firstTime)
{
    map.OnCritterIn.Subscribe(_PurgatoryMapIn);
    map.OnCritterOut.Subscribe(_PurgatoryMapOut);
}

void _PurgatoryMapIn(Map map, Critter cr)
{
    cr.IsNoPvp = false;
    if (cr.ControlledByPlayer && Entrance::IsCritterInDeadZone(cr, map, 0, ENTRY_NOPVP_FIRST, ENTRY_NOPVP_LAST)) {
        cr.IsNoPvp = true;
        Messaging::Info(cr, TextPackName::Text, 1);
        if (cr.CountTimeEvent(cte_NoPvpOff) == 0) {
            cr.StartTimeEvent(TIME_CHECK, cte_NoPvpOff);
        }
    }
}

void _PurgatoryMapOut(Map map, Critter cr)
{
    Map mapCr = cr.GetMap();
    if (valid(mapCr) && Entrance::IsCritterInDeadZone(cr, map, 0, ENTRY_NOPVP_FIRST, ENTRY_NOPVP_LAST)) {
        return;
    }
    cr.IsNoPvp = false;
    Messaging::Info(cr, TextPackName::Text, 2);
    _BattleMapCritterIn(map, cr);
}

void cte_NoPvpOff(Critter cr)
{
    if (!cr.IsNoPvp) {
        return;
    }
    Map map = cr.GetMap();
    if (valid(map) && Entrance::IsCritterInDeadZone(cr, map, 0, ENTRY_NOPVP_FIRST, ENTRY_NOPVP_LAST)) {
        timespan delayTicks = TIME_CHECK;
        if (delayTicks != ZERO_TIMESPAN) {
            Game.RepeatCurrentTimeEvent(delayTicks);
        }
    }
    cr.IsNoPvp = false;
    Messaging::Info(cr, TextPackName::Text, 2);
    return;
}

void _GateKeeperInit(Critter cr, bool firstTime)
{
    cr.IsInvulnerable = true;
}

void dlg_WhenBegin(Critter cr, Critter npc, string& lexems)
{
    if (!IS_DIALOG_GENERATED(lexems)) {
        return;
    }
    lexems = "$time" + GameTime::SynchronizedTimeToString(GameEvent::GetEventOccurenceTime(8));
}

void dlg_CountPlayers(Critter player, Critter npc, string& lexems)
{
    if (!IS_DIALOG_GENERATED(lexems)) {
        return;
    }
    int total = 0;
    int alive = 0;
    Critter cr;
    for (int i = 0, l = bInfo.Teams.length(); i < l; i++) {
        alive += bInfo.Teams[i].CountAlive();
        total += bInfo.Stage >= STAGE_BEGIN ? bInfo.Teams[i].Players.length() : bInfo.Teams[i].Requests.length();
    }
    lexems = "$total" + total + "$alive" + alive;
}

void dlg_Team1(Critter player, Critter npc, string& lexems)
{
    if (!IS_DIALOG_GENERATED(lexems)) {
        return;
    }
    lexems = "$players" + GetTeamPlayers(bInfo.Teams[0]);
}

void dlg_Team2(Critter player, Critter npc, string& lexems)
{
    if (!IS_DIALOG_GENERATED(lexems)) {
        return;
    }
    lexems = "$players" + GetTeamPlayers(bInfo.Teams[1]);
}

void dlg_Team3(Critter player, Critter npc, string& lexems)
{
    if (!IS_DIALOG_GENERATED(lexems)) {
        return;
    }
    lexems = "$players" + GetTeamPlayers(bInfo.Teams[2]);
}

void dlg_Team4(Critter player, Critter npc, string& lexems)
{
    if (!IS_DIALOG_GENERATED(lexems)) {
        return;
    }
    lexems = "$players" + GetTeamPlayers(bInfo.Teams[3]);
}

// Генерация итемов в ящиках
// На третьей карте Чистилища стоят ящики с лутом
// периодически совершается попытка переместить из одного из ящиков содержимое на территорию бг
void _PurgatoryLoop(Map map)
{
    if (valid(bInfo) && bInfo.Stage == STAGE_FIGHT) {
        Location loc = map.GetLocation();
        if (valid(loc)) {
            if (Game.SynchronizedTime >= loc.LastLootTransfer + Time::Minutes(1)) {
                loc.LastLootTransfer = Game.SynchronizedTime;
                Map mapFrom = loc.GetMapByIndex(2);
                Item[] containersTo = map.GetItems(ItemProperty::Type, ItemType::Container);
                Item[] containersFrom = mapFrom.GetItems(ItemProperty::Type, ItemType::Container);
                if (containersFrom.length() > 0 && containersTo.length() > 0) {
                    Item contFrom = containersFrom[Game.Random(0, containersFrom.length() - 1)];
                    Item[] items = contFrom.GetItems(ROOT_CONTAINER_STACK);
                    Item contTo = containersTo[Game.Random(0, containersTo.length() - 1)];
                    DL("Moving " + items.length() + " items to container at x:" + contTo.Hex.x + "; y:" + contTo.Hex.y);
                    ItemMovement::MoveItems(items, contTo, ROOT_CONTAINER_STACK);
                }
            }
        }
    }
}

// Удаление локации после того, как время истекло
void DeletePurgatory(any value)
{
    Location loc = Game.GetLocation(ident(value));
    if (valid(loc)) {
        Critter[] critters = {};
        for (int i = 0; i < 3; i++) {
            Map map = loc.GetMapByIndex(i);
            critters.insertLast(map.GetCritters(CritterFindType::Players));
        }
        for (int i = 0; i < critters.length(); i++) {
            Messaging::Info(critters[i], TextPackName::Text, 7128);
        }
        Game.DestroyLocation(loc.Id);
    }
}

#endif

}
