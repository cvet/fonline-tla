// FOS Client Sort 2

///@ RemoteCall Client CombatResult(any[] data)

void ModuleInit()
{
    Game.OnStart.Subscribe(start);
    Game.OnFinish.Subscribe(finish);
    Game.OnLoop.Subscribe(loop);
    Game.OnMouseMove.Subscribe(mouse_move);
    Game.OnGetActiveScreens.Subscribe(get_active_screens);
    Game.OnScreenChange.Subscribe(screen_change);
    Game.OnRenderIface.Subscribe(render_iface);
    // Game.OnRenderMap.Subscribe(render_map);
    Game.OnCritterIn.Subscribe(critter_in);
    Game.OnCritterOut.Subscribe(critter_out);
    Game.OnItemMapIn.Subscribe(item_map_in);
    Game.OnItemMapChanged.Subscribe(item_map_changed);
    Game.OnItemMapOut.Subscribe(item_map_out);
    Game.OnItemInvIn.Subscribe(item_inv_in);
    Game.OnItemInvChanged.Subscribe(item_inv_changed);
    Game.OnItemInvOut.Subscribe(item_inv_out);
    Game.OnContainerChanged.Subscribe(container_changed);
    Game.OnMapMessage.Subscribe(map_message);
    Game.OnInMessage.Subscribe(in_message);
    Game.OnOutMessage.Subscribe(out_message);
    Game.OnMessageBox.Subscribe(message_box);
    Game.OnCritterAction.Subscribe(critter_action);
    Game.OnCritterActionEx.Subscribe(critter_action);
    Game.OnCritterAnimationProcess.Subscribe(critter_animation_process);
    Game.OnItemsCollection.Subscribe(items_collection);
    Game.OnScreenSizeChanged.Subscribe(on_screen_size_changed);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on client loaded or new client_main.fos script received.
void start()
{
    Game.LoadFont(Fonts::Big, "*Big");
    Game.LoadFont(Fonts::BigNum, "*BigNumbers");
    Game.LoadFont(Fonts::Default, "*Default");
    Game.LoadFont(Fonts::Fat, "*Fat");
    Game.LoadFont(Fonts::Num, "*Numbers");
    Game.LoadFont(Fonts::OldFo, "*OldDefault");
    Game.LoadFont(Fonts::SandNum, "*SandNumbers");
    Game.LoadFont(Fonts::Thin, "*Thin");
    Game.LoadFont(Fonts::Special, "*Special");
    Game.SetDefaultFont(Fonts::Default);

    Gui::EngineCallback_Start();

    Gui::AddDragAndDropHandler(ItemsDragAndDropHandler);

    // ClientScreenTest::InitTestScreen();

    Radio::InitRadioScreen();

    ChosenTabs::InitChosenTabs();

    Game.PlayVideo("video/TheLifeAfterIntro.ogv|video/TheLifeAfterIntro.ogg", true, false);
    Game.PlayVideo("video/TheLifeAfterIntroSlide.ogv|video/TheLifeAfterIntroSlide" + (Settings.Language == "russ" ? "RU" : "EN") + ".ogg", true, true);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on client finish.
void finish()
{
    //
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Main loop function. Next call every cycle.
uint MouseStayTick = 0;

void loop() // (uint& wait)
{
    Critter chosen = Game.GetChosen();
    if (chosen != null) {
        chosen.AttackDistanceHint = Parameters::GetActiveItemAttackDistance(chosen);
    }

    // Description under cursor
    if (Settings.Cursor == CursorType::Default && Game.GetTick() - 1200 >= MouseStayTick && MouseStayTick != 0) {
        MouseStayTick = 0;
        Gui::Screen screen = Gui::GetActiveScreen();
        if (screen == null) {
            return;
        }

        Item item;
        Critter cr;

        Gui::Object hoveredObj = screen.FindMouseHit();
        if (hoveredObj != null) {
            if (hoveredObj.Grid != null && cast<Gui::ItemView>(hoveredObj.Grid) != null) {
                item = cast<Gui::ItemView>(hoveredObj.Grid).GetItem(hoveredObj.CellIndex);
            }
        }
        else if (CurMap != null && !screen.IsModal) {
            Entity entity = CurMap.GetEntityAtScreenPos(Settings.MouseX, Settings.MouseY);
            item = cast<Item>(entity);
            cr = cast<Critter>(entity);
        }

        if (item != null) {
            Game.Message(item_description(item, ItemLookTypes::OnlyName));
        }
        else if (cr != null) {
            Game.Message(critter_description(cr, CritterLookTypes::LookShort));
        }
    }

    Gui::EngineCallback_Loop();
}

void mouse_move(int offsetX, int offsetY)
{
    if (Settings.Cursor == CursorType::Default) {
        MouseStayTick = Game.GetTick();
    }
    else {
        MouseStayTick = 0;
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Say to engine what screens is active.
void get_active_screens(int[] & result)
{
    Gui::EngineCallback_GetActiveScreens(result);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Show/hide screen behaviour.
void screen_change(bool show, int screen, dict<string, any> params)
{
    if (show) {
        Gui::EngineCallback_ShowScreen(screen, params);
    }
    else {
        Gui::EngineCallback_HideScreen(screen);
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Render interface function. You can use Draw* functions only there.
// Layer specification:
//    1
// Game map
//    2, 3
// PopUp menu, Cursor
//    4
//
// Extra layers:
// Global map
//    100 (over map), 101 (over all)
void render_iface()
{
    Gui::Screen mainScreen = Gui::GetActiveMainScreen();
    bool needDrawMap = mainScreen != null && mainScreen.Index == CLIENT_MAIN_SCREEN_GAME && CurMap != null;

    if (needDrawMap) {
        CurMap.DrawMap();
    }

    Game.OnPreRenderIface.Fire();

    if (needDrawMap) {
        CurMap.DrawMapTexts();
    }

    ChosenTabs::DrawChosenTabs();
    Gui::EngineCallback_Draw();

    Game.OnPostRenderIface.Fire();

    // Help info
    if (Settings.HelpInfo) {
        // About
        string aboutText = "FOnline " + (Settings.Singleplayer ? "Singleplayer" : "") + "\n" + "by Gamers for Gamers\n" + "version " + Game.GetGameVersion() +
                           "\n" + "\n" + "Traffic, bytes:\n" + "Send: " + Game.CustomCall("BytesSend") + "\n" + "Receive: " + Game.CustomCall("BytesReceive") +
                           "\n" + "Sum: " + (Game.CustomCall("BytesSend").toInt() + Game.CustomCall("BytesReceive").toInt()) + "\n" + "\n" +
                           "FPS: " + Settings.FPS + " (" + (!Settings.VSync ? "" + math::abs(Settings.FixedFPS) : "VSync") +
                           (!Settings.VSync && Settings.FixedFPS < 0 ? ", sleep" : "") + ")\n" + "Ping: " + Settings.Ping + "\n" + "\n" +
                           "Sound: " + Settings.SoundVolume + "\n" + "Music: " + Settings.MusicVolume + "\n";
        if (Settings.DebugInfo) {
            aboutText += "\n" + "Focused object: " + (Gui::GetFocusedObject() !is null ? Gui::GetFocusedObject().Name : "None") + "\n" +
                         "Pressed object: " + (Gui::GetPressedObject() !is null ? Gui::GetPressedObject().Name : "None") + "\n" +
                         "Hovered object: " + (Gui::GetHoveredObject() !is null ? Gui::GetHoveredObject().Name : "None");
        }
        Game.DrawText(aboutText, 30, 30, Settings.ScreenWidth, Settings.ScreenHeight, ucolor(187, 187, 187), Fonts::Big, 0);

        // Help
        Game.DrawText(MSG_GAME(MsgStr::StrGameHelp), 0, 0, Settings.ScreenWidth, Settings.ScreenHeight, COLOR_WHITE, Fonts::Default, FT_CENTERX | FT_CENTERY);
    }

    // Zoom text
    if (Settings.MapZooming && Settings.SpritesZoomMin != Settings.SpritesZoomMax) {
        string zoomText = MSG_GAME(MsgStr::StrZoom);
        zoomText = Game.ReplaceText(zoomText, "%d", "" + int(1.0 / CurMap.SpritesZoom * 100.0));
        zoomText = Game.ReplaceText(zoomText, "%%", "%");
        Game.DrawText(zoomText, 0, 0, Settings.ScreenWidth, Settings.ScreenHeight, COLOR_SAND, Fonts::Big, FT_CENTERX | FT_CENTERY);
    }

    Gui::EngineCallback_DrawCursor();

    /*
       else if( layer == 100 && Settings.GmapActive )
       {
        // Here you can draw on global map

        // bool  Settings.GmapActive - активна ли глобальная карта и все ли следующие нижеприведенные переменные корректны;
        // bool  Settings.GmapWait   - включен режим ожидания ответа о подтверждении энкаунтера;
        // float Settings.GmapZoom   - текущий масштаб, не забывайте учитывать его при рисовании на карте;
        // int   Settings.GmapOffsetX/Y   - смещение карты от нулевой координаты (верхний-левый угол);
        // int   Settings.GmapGroupCurX/Y - координаты группы игрока;
        // int   Settings.GmapGroupToX/Y  - координаты точки назначения;
        // float Settings.GmapGroupSpeed  - текущая скорость передвижения.
        // Для примера, расчет текущего пикселя группы:
        // x = Settings.GmapGroupX / Settings.GmapZoom + Settings.GmapOffsetX, y = Settings.GmapGroupY / Settings.GmapZoom + Settings.GmapOffsetY.
       }
     */
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Render map function. You can use DrawMap* functions only there.
void render_map()
{
    //
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something critter in/out game.
void critter_in(Critter cr)
{
    // Default colors
    cr.NameColor = COLOR_CRITTER_NAME;
    cr.ContourColor = (cr.IsControlledByPlayer ? COLOR_CONTOUR_YELLOW : COLOR_CONTOUR_RED);

    // Karma voting
    int highlight = cr.PlayerKarma / 10;
    cr.NameColor = ucolor(COLOR_CRITTER_NAME.red + highlight, COLOR_CRITTER_NAME.green + highlight, COLOR_CRITTER_NAME.blue + highlight);

    // For correct dialog formatting (male/female)
    cr.IsSexTagFemale = cr.Gender == GenderType::Female;
}

void critter_out(Critter cr)
{
    //
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something item in/changed/out map.
void item_map_in(Item item)
{
    Gui::EngineCallback_ItemChanged(true);
}

void item_map_changed(Item itemNow, Item itemBefore)
{
    Gui::EngineCallback_ItemChanged(true);
}

void item_map_out(Item item)
{
    Gui::EngineCallback_ItemChanged(true);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something critter in/out chosen inventory.
void item_inv_in(Item item)
{
    Gui::EngineCallback_ItemChanged(false);
}

void item_inv_changed(Item itemNow, Item itemBefore)
{
    Gui::EngineCallback_ItemChanged(false);
}

void item_inv_out(Item item)
{
    Gui::EngineCallback_ItemChanged(false);
}

void container_changed()
{
    Gui::EngineCallback_ItemChanged(false);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on receive message on map.
// By default delay == [TextDelay + message length * 100] ms
bool map_message(string& message, uint16& hexX, uint16& hexY, ucolor& color, uint& delay)
{
    // Detect radio
    if (color == 0xFFFFFFFE) {
        message = ".." + message + "..";
    }
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on receive message.
// By default delay == [TextDelay + message length * 100] ms
bool in_message(string message, int& sayType, ident critterId, uint& delay)
{
    if (sayType == SAY_DIALOG) {
        Gui::Screen screen = Gui::GetActiveScreen();
        if (screen != null) {
            if (screen.Index == CLIENT_SCREEN_BARTER) {
                auto barterScreen = cast<GuiScreens::Barter::Barter>(screen);
                barterScreen.SetDialogText(message);
            }
            if (screen.Index == CLIENT_SCREEN_DIALOG) {
                auto dialogScreen = cast<GuiScreens::Dialog::Dialog>(screen);
                dialogScreen.SetDialogText(message);
            }
        }
    }
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on send message.
bool out_message(string& message, int& sayType)
{
    string cmdPrefix = "~";
    if (message[0] == cmdPrefix) // Command
    {
        message[0] = "";

        if (Test::ParseMessage(message)) {
            return false;
        }

        if (message == "globalmap") {
            CurPlayer.ServerCall.Rpc_CritterToGlobal();
            return false;
        }

        string separator = "#";
        string result = Game.CustomCall("Command" + separator + message, separator);
        if (result == "UNKNOWN") {
            Game.Message("Unknown command.");
        }
        else if (result.length() > 0) {
            string[] msg = result.split(separator);
            for (uint i = 0; i < msg.length(); i++) {
                Game.Message(Game.ReplaceText(result, "<", "<" + cmdPrefix));
            }
        }

        return false;
    }

    if (sayType == SAY_NORM) {
        if (message.length() > 2 && (message[0] == "/" || message[0] == ".")) {
            string ch = message[1];
            if (ch == "к" || ch == "К" || ch == "s" || ch == "S") {
                sayType = SAY_SHOUT;
            }
            else if (ch == "э" || ch == "Э" || ch == "e" || ch == "E") {
                sayType = SAY_EMOTE;
            }
            else if (ch == "ш" || ch == "Ш" || ch == "w" || ch == "W") {
                sayType = SAY_WHISP;
            }
            else if (ch == "с" || ch == "С" || ch == "$") {
                sayType = SAY_SOCIAL;
            }
            else if (ch == "р" || ch == "Р" || ch == "r" || ch == "R") {
                sayType = SAY_RADIO;
            }

            if (sayType != SAY_NORM) {
                message[0] = "";
                message[0] = "";
                while (message[0] == " ") {
                    message[0] = "";
                }
            }
        }
        else if ( // RegExp: [*]([^*].*[^*])[*]
            message.length() >= 4 && message[0] == "*" && message[1] != "*" && message[message.length() - 2] != "*" && message[message.length() - 1] == "*") {
            sayType = SAY_EMOTE;
            message = message.substr(1, message.length() - 2);
        }
    }

    bool result = false;
    for (uint i = 0, j = message.length(); i < j; i++) {
        if (message[i] != " ") {
            result = true;
            break;
        }
    }

    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// To-hit chance.
int to_hit(Critter chosen, Critter target, ProtoItem weapon, uint8 weaponMode)
{
    int use = _WeaponModeUse(weaponMode);
    int hitLocation = _WeaponModeAim(weaponMode);
    if (use > 2) {
        return 0;
    }

    if (target.IsDead()) {
        return 0;
    }
    if (!chosen.IsAlive()) {
        return 0;
    }

    ProtoItem ammo = null;

    if (valid(weapon) && _WeaponRound(weapon, use) > 0) {
        ammo = Game.GetProtoItem(weapon.AmmoPid);
    }

    CritterProperty skill = CritterProperty::SkillUnarmed;
    skill = _WeaponSkill(weapon, use);
    int wpnMaxDist = _WeaponMaxDist(weapon, use);
    if (skill == CritterProperty::SkillThrowing) {
        wpnMaxDist = MIN(wpnMaxDist, 3 * MIN(int(10), chosen.Strength + 2 * chosen.PerkHeaveHo));
    }

    int dist = Game.GetDistance(chosen, target);
    if (dist > wpnMaxDist) {
        return 0;
    }

    int toHit = int(chosen.GetAsInt(skill));
    int weaponPerk = weapon.Weapon_Perk;
    int blockers = 0;

    if (skill != CritterProperty::SkillUnarmed && skill != CritterProperty::SkillMeleeWeapons) {
        // Ranged attack modifiers
        int distmod1 = 2; // Used for initial weapon bonus
        int distmod2 = 0; // Minimal distance
        if (weaponPerk == ItemPerks::LongRange) {
            distmod1 = 4;
        }
        else if (weaponPerk == ItemPerks::ScopeRange) {
            distmod1 = 5;
            distmod2 = 8;
        }

        int perception = chosen.Perception;
        int acc = dist;

        if (dist < distmod2) {
            acc += distmod2;
        }
        else {
            if (chosen.IsControlledByPlayer) {
                acc -= (perception - 2) * distmod1; // we want to keep it, because fo2238 might use it to display NPCs chance (via possessing)
            }
            else {
                acc -= perception * distmod1;
            }
        }

        if (-2 * perception > acc) {
            acc = -2 * perception;
        }

        acc -= 2 * chosen.PerkSharpshooter;

        if (acc >= 0) {
            if (chosen.IsDamagedEye) {
                acc *= -12;
            }
            else {
                acc *= -4;
            }
        }
        else {
            acc *= -4;
        }

        toHit += acc;

        blockers = CurMap.GetCrittersInPath(chosen.HexX, chosen.HexY, target.HexX, target.HexY, 0.0f, dist, CritterFindType::Alive).length();
        if (!target.IsKnockout()) {
            blockers--;
        }
        toHit -= 10 * blockers;
    } // End range modifiers

    if (!(weapon.Weapon_IsUnarmed) && chosen.IsTraitOneHander && valid(weapon)) {
        toHit += (weapon.Weapon_IsTwoHanded ? -40 : 20);
    }

    int handlingStrength = chosen.Strength;
    int reqStrength = weapon.Weapon_MinStrength;
    if (chosen.PerkWeaponHandling != 0) {
        handlingStrength += 3;
    }
    if (handlingStrength < reqStrength) {
        toHit -= (reqStrength - handlingStrength) * 20;
    }
    if (weaponPerk == ItemPerks::Accurate) {
        toHit += 20;
    }
    int acmod = target.ArmorClass;
    if (valid(ammo)) {
        acmod += ammo.Ammo_AcMod;
    }
    if (acmod > 0) {
        toHit -= acmod;
    }
    // TODO: tohit += 15 if target is multihex
    // TODO: light penalty

    if (chosen.IsDamagedEye) {
        toHit -= 25;
    }
    if (chosen.PerkVampireAccuracy != 0 && IS_NIGHT(Game.Hour)) {
        toHit += 13;
    }
    if (target.IsKnockout()) {
        toHit += 40;
    }
    toHit += target.Multihex * 15;

    int hitMod = GetHitAim(hitLocation);
    if (skill == CritterProperty::SkillMeleeWeapons || skill == CritterProperty::SkillUnarmed) {
        hitMod /= 2;
    }
    toHit -= hitMod;
    toHit = CLAMP(toHit, 5, 95);

    return toHit;
}

uint GetHitAim(int hitLocation)
{
    switch (hitLocation) {
    case HitLocations::LocationNone:
        break;
    case HitLocations::LocationUncalled:
        break;
    case HitLocations::LocationTorso:
        return Settings.HitAimTorso;
    case HitLocations::LocationEyes:
        return Settings.HitAimEyes;
    case HitLocations::LocationHead:
        return Settings.HitAimHead;
    case HitLocations::LocationLeftArm:
    case HitLocations::LocationRightArm:
        return Settings.HitAimArms;
    case HitLocations::LocationGroin:
        return Settings.HitAimGroin;
    case HitLocations::LocationRightLeg:
    case HitLocations::LocationLeftLeg:
        return Settings.HitAimLegs;
    default:
        break;
    }
    return 0;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Override aim location set by player through targetting screen or simple click on target.
void hit_aim(uint8& aim)
{
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Combat results.
void CombatResult(any[] data)
{
    uint datalen = data.length();
    if (datalen == 0) {
        return;
    }
    if (data[0] != datalen) {
        return;
    }

    uint current = 1;

    while (current < datalen) {
        int damage = -1;
        uint effect = 0;
        uint loc = 0;
        int message = -1;

        uint mode = data[current++];
        ident who = data[current++];
        ident who2;
        Critter originalTarget;

        Critter cr = Game.GetCritter(who);
        Critter chosen = Game.GetChosen();
        Critter trueTarget = null;

        bool self = (who == Game.GetChosen().Id);

        string name = "error0";
        if (valid(cr)) {
            if (!self) {
                name = cr.Name;
            }
            else {
                name = Game.GetText(TextPackName::Combat, chosen.Gender == GenderType::Male ? 506 : 556);
            }
        }

        uint offset;
        if (self) {
            if (cr.Gender == GenderType::Male) {
                offset = 506;
            }
            else {
                offset = 556;
            }
        }
        else {
            if (cr.Gender == GenderType::Male) {
                offset = 606;
            }
            else {
                offset = 706;
            }
        }

        string result;

        // reading and preparing the data:
        switch (mode) {
        case MessageSpecifications::CritMiss:
            effect = data[current++];
            result = Game.GetText(TextPackName::Combat, offset + 8);
            result = Game.ReplaceText(result, "%s", name);
            break;
        case MessageSpecifications::CritMissDamage:
            effect = data[current++];
            damage = data[current++];
            result = Game.GetText(TextPackName::Combat, offset + (damage > 1 ? 28 : 27));
            result = Game.ReplaceText(result, "%s", name);
            if (damage > 1) {
                result = Game.ReplaceText(result, "%d", damage);
            }
            break;
        case MessageSpecifications::Hit:
        case MessageSpecifications::HitDead:
            damage = data[current++];
            result = Game.GetText(TextPackName::Combat, offset + (damage > 1 ? 7 : (damage != 0 ? 17 : 21)));
            result = Game.ReplaceText(result, "%s", name);
            if (damage > 1) {
                result = Game.ReplaceText(result, "%d", damage);
            }
            break;
        case MessageSpecifications::AimedHit:
        case MessageSpecifications::AimedHitDead:
            loc = data[current++];
            damage = data[current++];
            result = Game.GetText(TextPackName::Combat, offset + (damage > 1 ? 6 : (damage != 0 ? 16 : 20)));
            result = Game.ReplaceText(result, "%s", name);
            result = Game.ReplaceText(result, "%s", Game.GetText(TextPackName::Combat, 1000 + cr.CrTypeAlias * 10 + loc - 1));
            if (damage > 1) {
                result = Game.ReplaceText(result, "%d", damage);
            }
            break;
        case MessageSpecifications::CritHit:
            damage = data[current++];
            effect = data[current++];
            message = data[current++];
            result = Game.GetText(TextPackName::Combat, offset + (damage > 1 ? 14 : (damage != 0 ? 18 : 22)));
            result = Game.ReplaceText(result, "%s", name);
            if (damage > 1) {
                result = Game.ReplaceText(result, "%d", damage);
            }
            break;
        case MessageSpecifications::CritAimedHit:
            loc = data[current++];
            damage = data[current++];
            effect = data[current++];
            message = data[current++];
            result = Game.GetText(TextPackName::Combat, offset + (damage > 1 ? 5 : (damage != 0 ? 15 : 19)));
            result = Game.ReplaceText(result, "%s", name);
            result = Game.ReplaceText(result, "%s", Game.GetText(TextPackName::Combat, 1000 + cr.CrTypeAlias * 10 + loc - 1));
            if (damage > 1) {
                result = Game.ReplaceText(result, "%d", damage);
            }
            break;
        case MessageSpecifications::CritHitDead:
            damage = data[current++];
            message = data[current++];
            result = Game.GetText(TextPackName::Combat, offset + (damage > 1 ? 14 : (damage != 0 ? 18 : 22)));
            result = Game.ReplaceText(result, "%s", name);
            if (damage > 1) {
                result = Game.ReplaceText(result, "%d", damage);
            }
            break;
        case MessageSpecifications::CritAimedHitDead:
            loc = data[current++];
            damage = data[current++];
            message = data[current++];
            result = Game.GetText(TextPackName::Combat, offset + (damage > 1 ? 5 : (damage != 0 ? 15 : 19)));
            result = Game.ReplaceText(result, "%s", name);
            result = Game.ReplaceText(result, "%s", Game.GetText(TextPackName::Combat, 1000 + cr.CrTypeAlias * 10 + loc - 1));
            if (damage > 1) {
                result = Game.ReplaceText(result, "%d", damage);
            }
            break;
        case MessageSpecifications::Oops:
            who2 = data[current++]; // who2 was hit instead of who
            // +2 "... was hit instead of you!"
            // +3 "... was hit instead of ...!"
            trueTarget = Game.GetCritter(who2);
            if (self) {
                // It was original target
                result = Game.GetText(TextPackName::Combat, cr.Gender == GenderType::Male ? 608 : 708);
                string nameTrue = "error1";
                if (valid(trueTarget)) {
                    nameTrue = trueTarget.Name;
                }
                result = Game.ReplaceText(result, "%s", nameTrue);
            }
            else {
                // It was not original target
                result = Game.GetText(TextPackName::Combat, offset + 3);
                if (who2 == Game.GetChosen().Id) {
                    result = Game.ReplaceText(result, "%s", Game.GetText(TextPackName::Combat, chosen.Gender == GenderType::Male ? 506 : 556));
                }
                else {
                    string nameTrue = "error1";
                    if (valid(trueTarget)) {
                        nameTrue = trueTarget.Name;
                    }
                    result = Game.ReplaceText(result, "%s", nameTrue);
                }
                result = Game.ReplaceText(result, "%s", name);
            }
            break;
        case MessageSpecifications::Miss:
            result = Game.GetText(TextPackName::Combat, offset + 9);
            result = Game.ReplaceText(result, "%s", name);
            break;
        case MessageSpecifications::HitRandomly:
            result = Game.GetText(TextPackName::Combat, offset + 9);
            result = Game.ReplaceText(result, "%s", name);
            result += Game.GetText(TextPackName::Combat, 108) + Game.GetText(TextPackName::Combat, offset - 306 + 20);
        default:
            break;
        }

        bool isVerbose = (Settings.CombatMessagesType == 0);
        string[] ext = {};

        if (message != -1 && isVerbose) // Must be critical hit
        {
            result += Game.GetText(TextPackName::Combat, message);
        }
        else if (effect != 0) {
            offset -= 306;
            if (mode > MessageSpecifications::CritMissDamage) // Hit flags
            {
                if (FLAG(effect, HF_KNOCKOUT)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 0));
                }
                if (FLAG(effect, HF_KNOCKDOWN)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 1));
                }
                if (FLAG(effect, HF_CRIPPLED_LEFT_LEG)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 2));
                }
                if (FLAG(effect, HF_CRIPPLED_RIGHT_LEG)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 3));
                }
                if (FLAG(effect, HF_CRIPPLED_LEFT_ARM)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 4));
                }
                if (FLAG(effect, HF_CRIPPLED_RIGHT_ARM)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 5));
                }
                if (FLAG(effect, HF_BLINDED)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 6));
                }
                // if(FLAG(effect, HF_DEATH))              ext.insertLast(Game.GetText(TextPackName::Combat, offset     )); // This is handled elsewhere
                // if(FLAG(effect, HF_ON_FIRE))            ext.insertLast(Game.GetText(TextPackName::Combat, offset + 10)); // Not used
                if (FLAG(effect, HF_BYPASS_ARMOR)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 11));
                }
                if (FLAG(effect, HF_DROPPED_WEAPON)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 14));
                }
                if (FLAG(effect, HF_LOST_NEXT_TURN)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 15));
                }
                if (FLAG(effect, HF_RANDOM)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 21));
                }
            }
            else {
                if (FLAG(effect, MF_KNOCKED_DOWN)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 1));
                }
                // if(FLAG(effect, MF_ON_FIRE))              ext.insertLast(Game.GetText(TextPackName::Combat, offset + 10)); // Not used
                if (FLAG(effect, MF_WEAPON_EXPLODED)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 12));
                }
                if (FLAG(effect, MF_WEAPON_DESTROYED)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 13));
                }
                if (FLAG(effect, MF_WEAPON_DROPPED)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 14));
                }
                if (FLAG(effect, MF_LOST_NEXT_TURN)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 15));
                }
                if (FLAG(effect, MF_HIT_SELF)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 16));
                }
                if (FLAG(effect, MF_LOST_REST_OF_AMMO)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 17));
                }
                if (FLAG(effect, MF_FIRED_DUD_SHOT)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 18));
                }
                if (FLAG(effect, MF_HURT_SELF)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 19));
                }
                // if(FLAG(effect, MF_HIT_RANDOMLY))         ext.insertLast(Game.GetText(TextPackName::Combat, offset + 20)); // This is handled elsewhere
                if (FLAG(effect, MF_CRIPPLED_RANDOM_LIMB)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 21));
                }
                if (FLAG(effect, MF_WAS_KILLED)) {
                    ext.insertLast(Game.GetText(TextPackName::Combat, offset + 7));
                }
            }
            offset += 306;
        }

        if (8 <= mode && mode <= 11 && (!isVerbose || message == -1)) {
            ext.insertLast(Game.GetText(TextPackName::Combat, offset + 7 - 306));
        }

        for (uint m = 0, n = ext.length(); m < n; m++) {
            if (m == n - 1) {
                result += Game.GetText(TextPackName::Combat, 108);
            }
            else {
                result += ", ";
            }

            result += ext[m];
        }

        result += ".";

        Game.Message(FOMB_COMBAT_RESULT, result);

        if (8 <= mode && mode <= 11 && isVerbose && message != -1) {
            Game.Message(FOMB_COMBAT_RESULT, name + " " + Game.GetText(TextPackName::Combat, offset + 7 - 306) + ".");
        }

        // On head indication
        if (Settings.DamageHitDelay > 0 && damage > 0) {
            CurMap.Message("-" + damage, cr.HexX, cr.HexY, Settings.DamageHitDelay, 0xFFC80000, true, Game.Random(-5, 5), -20);
        }
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Generic description. Descriptions type look in _client_defines.fos, Generic descriptions types.
// int& offsX, int& offsY - offsets of text, by default is zero.
string generic_description(int descType, int& offsX, int& offsY)
{
    Critter chosen = Game.GetChosen();
    if (not valid(chosen)) {
        return "";
    }
    string result;

    if (descType == GenericDescriptionsTypes::InventoryMain) {
        result += chosen.Name + "\n";
        result += "---------------------\n";
        result += Game.GetText(TextPackName::Game, STR_INV_SHORT_SPECIAL(CritterProperty::Strength)) + "\n";
        result += Game.GetText(TextPackName::Game, STR_INV_SHORT_SPECIAL(CritterProperty::Perception)) + "\n";
        result += Game.GetText(TextPackName::Game, STR_INV_SHORT_SPECIAL(CritterProperty::Endurance)) + "\n";
        result += Game.GetText(TextPackName::Game, STR_INV_SHORT_SPECIAL(CritterProperty::Charisma)) + "\n";
        result += Game.GetText(TextPackName::Game, STR_INV_SHORT_SPECIAL(CritterProperty::Intellect)) + "\n";
        result += Game.GetText(TextPackName::Game, STR_INV_SHORT_SPECIAL(CritterProperty::Agility)) + "\n";
        result += Game.GetText(TextPackName::Game, STR_INV_SHORT_SPECIAL(CritterProperty::Luck)) + "\n";
        result += "---------------------\n";

        AbstractItem weaponMain = CritterItem::GetActive(chosen);
        if (valid(weaponMain)) {
            int use = _WeaponModeUse(weaponMain.Mode);
            if (use > 2) {
                use = 0;
            }

            result += Game.GetText(TextPackName::Items, STR_ITEM_NAME(weaponMain)) + "\n";

            if (weaponMain.Type == ItemType::Weapon) {
                result += Game.GetText(TextPackName::Game, MsgStr::StrInvDmg) + " ";
                result += _WeaponDmgMin(weaponMain, use) + "-";
                int wpnMaxDmg = _WeaponDmgMax(weaponMain, use);
                if (_WeaponIsHtHAttack(weaponMain, use)) {
                    wpnMaxDmg += chosen.MeleeDamage;
                }
                result += wpnMaxDmg;

                if (_WeaponMaxDist(weaponMain, use) > 1) {
                    result += " " + Game.GetText(TextPackName::Game, MsgStr::StrInvDist) + " ";
                    int wpnMaxDist = _WeaponMaxDist(weaponMain, use);
                    if (_WeaponSkill(weaponMain, use) == CritterProperty::SkillThrowing) {
                        wpnMaxDist = MIN(wpnMaxDist, 3 * MIN(int(10), chosen.Strength + 2 * chosen.PerkHeaveHo));
                    }
                    result += wpnMaxDist;
                }
                result += "\n";

                if (weaponMain.Weapon_MaxAmmoCount > 0) {
                    result += Game.GetText(TextPackName::Game, MsgStr::StrInvAmmo) + " ";
                    result += weaponMain.AmmoCount + "/";
                    result += weaponMain.Weapon_MaxAmmoCount + " ";
                    result += Game.GetText(TextPackName::Game, STR_CALIBER(weaponMain.Weapon_Caliber));
                }
                result += "\n";
            }
            else {
                result += "\n\n";
            }
        }
        else {
            // Unarmed
            AbstractItem unarmed = CritterItem::GetActive(chosen);
            result += Game.GetText(TextPackName::Game, MsgStr::StrInvNoItem) + "\n";
            result += Game.GetText(TextPackName::Game, MsgStr::StrInvUnarmedDmg) + " ";
            result += _WeaponDmgMin(unarmed, _WeaponModeUse(unarmed.Mode)) + "-";
            result += (_WeaponDmgMax(unarmed, _WeaponModeUse(unarmed.Mode)) + chosen.MeleeDamage);
            result += "\n\n";
        }
        result += "---------------------\n";

        AbstractItem weaponExt = CritterItem::GetActive(chosen, CritterItemSlot::Secondary);
        if (valid(weaponExt)) {
            int use = _WeaponModeUse(weaponExt.Mode);
            if (use > 2) {
                use = 0;
            }

            result += Game.GetText(TextPackName::Items, STR_ITEM_NAME(weaponExt)) + "\n";

            if (weaponExt.Type == ItemType::Weapon) {
                result += Game.GetText(TextPackName::Game, MsgStr::StrInvDmg) + " ";
                result += _WeaponDmgMin(weaponExt, use) + "-";
                int wpnMaxDmg = _WeaponDmgMax(weaponExt, use);
                if (_WeaponIsHtHAttack(weaponExt, use)) {
                    wpnMaxDmg += chosen.MeleeDamage;
                }
                result += wpnMaxDmg;
                if (_WeaponMaxDist(weaponExt, use) > 1) {
                    result += " " + Game.GetText(TextPackName::Game, MsgStr::StrInvDist) + " ";
                    int wpnMaxDist = _WeaponMaxDist(weaponExt, use);
                    if (_WeaponSkill(weaponExt, use) == CritterProperty::SkillThrowing) {
                        wpnMaxDist = MIN(wpnMaxDist, 3 * MIN(int(10), chosen.Strength + 2 * chosen.PerkHeaveHo));
                    }
                    result += wpnMaxDist;
                }
                result += "\n";

                if (weaponExt.Weapon_MaxAmmoCount > 0) {
                    result += Game.GetText(TextPackName::Game, MsgStr::StrInvAmmo) + " ";
                    result += weaponExt.AmmoCount + "/";
                    result += weaponExt.Weapon_MaxAmmoCount + " ";
                    result += Game.GetText(TextPackName::Game, STR_CALIBER(weaponExt.Weapon_Caliber));
                }
                result += "\n";
            }
            else {
                result += "\n\n";
            }
        }
        else {
            // Unarmed
            AbstractItem unarmed = CritterItem::GetActive(chosen, CritterItemSlot::Secondary);
            result += Game.GetText(TextPackName::Game, MsgStr::StrInvNoItem) + "\n";
            result += Game.GetText(TextPackName::Game, MsgStr::StrInvUnarmedDmg) + " ";
            result += _WeaponDmgMin(unarmed, _WeaponModeUse(unarmed.Mode)) + "-";
            result += (_WeaponDmgMax(unarmed, _WeaponModeUse(unarmed.Mode)) + chosen.MeleeDamage);
            result += "\n\n";
        }

        result += Game.GetText(TextPackName::Game, MsgStr::StrInvTotalWeight) + " ";
        result += (chosen.ItemsWeight / 1000) + "/";
        result += (chosen.CarryWeight / 1000) + ".";
    }
    else if (descType == GenericDescriptionsTypes::InventorySpecial) {
        offsX = 23;
        result += "\n\n";
        result += chosen.Strength + "\n";
        result += chosen.Perception + "\n";
        result += chosen.Endurance + "\n";
        result += chosen.Charisma + "\n";
        result += chosen.Intellect + "\n";
        result += chosen.Agility + "\n";
        result += chosen.Luck;
    }
    else if (descType == GenericDescriptionsTypes::InventoryStats) {
        offsX = 39;
        result += "\n\n";
        result += Game.GetText(TextPackName::Game, MsgStr::StrInvHp) + " ";
        result += chosen.CurrentHp + "/" + chosen.MaxLife + "\n";
        result += Game.GetText(TextPackName::Game, MsgStr::StrInvAc) + " ";
        result += chosen.ArmorClass + "\n";
        result += Game.GetText(TextPackName::Game, MsgStr::StrInvNormal) + "\n";
        result += Game.GetText(TextPackName::Game, MsgStr::StrInvLaser) + "\n";
        result += Game.GetText(TextPackName::Game, MsgStr::StrInvFire) + "\n";
        result += Game.GetText(TextPackName::Game, MsgStr::StrInvPlasma) + "\n";
        result += Game.GetText(TextPackName::Game, MsgStr::StrInvExplode);
    }
    else if (descType == GenericDescriptionsTypes::InventoryResist) {
        offsX = 103;
        result += "\n\n\n\n";
        int[] threshold = array<int>(chosen.DamageThreshold);
        int[] resistance = array<int>(chosen.DamageResistance);
        result += threshold[DamageTypes::Normal] + "/" + resistance[DamageTypes::Normal] + "%\n";
        result += threshold[DamageTypes::Laser] + "/" + resistance[DamageTypes::Laser] + "%\n";
        result += threshold[DamageTypes::Fire] + "/" + resistance[DamageTypes::Fire] + "%\n";
        result += threshold[DamageTypes::Plasma] + "/" + resistance[DamageTypes::Plasma] + "%\n";
        result += threshold[DamageTypes::Explode] + "/" + resistance[DamageTypes::Explode] + "%";
    }

    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Item description. Look types look in _client_defines.fos, Item look types.
string item_description(Item item, ItemLookTypes lookType)
{
    // Default error text
    if (not Game.IsTextPresent(TextPackName::Items, STR_ITEM_NAME(item) + (lookType != ItemLookTypes::OnlyName ? hstring("Desc").uhash : 0))) {
        return Game.GetText(TextPackName::Game, MsgStr::StrItemLookNothing);
    }

    string result;

    // Car on world map
    if (lookType == ItemLookTypes::WmCar) {
        string fuel = Game.GetText(TextPackName::Game, MsgStr::StrInvCarFuel);
        fuel = Game.ReplaceText(fuel, "VALUE", item.Charge / 100);
        fuel = Game.ReplaceText(fuel, "MAX_VALUE", item.Car_TankVolume / 100);
        string deterioration = Game.GetText(TextPackName::Game, MsgStr::StrInvCarDeterioration);
        deterioration = Game.ReplaceText(deterioration, "VALUE", item.Deterioration * 100 / item.Car_MaxDeterioration);
        result = fuel + "\n" + deterioration;
    }
    // Short info
    else if (lookType == ItemLookTypes::OnlyName) {
        result += Game.ReplaceText(Game.GetText(TextPackName::Game, MsgStr::StrItemLook), "NAME", Game.GetText(TextPackName::Items, STR_ITEM_NAME(item)));
    }
    // Full info
    else {
        if (lookType == ItemLookTypes::Inventory) {
            result += Game.GetText(TextPackName::Items, STR_ITEM_NAME(item)) + "\n";
        }

        if (item.ProtoId == Content::Item::holodisk && item.HolodiskNum != 0) {
            result += Game.GetText(TextPackName::Holo, STR_HOLO_INFO_NAME(item.HolodiskNum));
        }
        else {
            result += Game.GetText(TextPackName::Items, STR_ITEM_INFO(item));
        }

        if (lookType != ItemLookTypes::Map) {
            // Weight
            result +=
                "\n" + Game.ReplaceText(Game.GetText(TextPackName::Game, MsgStr::StrItemWeightGramm), "VALUE", item.Weight * (item.Stackable ? item.Count : 1));

            // Ammo load
            if (item.Type == ItemType::Weapon && item.Weapon_MaxAmmoCount > 0) {
                result += "\n";
                string str = Game.GetText(TextPackName::Game, MsgStr::StrInvHasShots);
                str = Game.ReplaceText(str, "VALUE", item.AmmoCount);
                str = Game.ReplaceText(str, "MAX_VALUE", item.Weapon_MaxAmmoCount);
                str = Game.ReplaceText(str, "AMMO", Game.GetText(TextPackName::Game, STR_CALIBER(item.Weapon_Caliber)));
                result += str;
            }

            // Deterioration
            if (item.Deteriorable) {
                uint8 brokenCount = item.BrokenCount;
                uint16 deterioration = item.Deterioration;

                // Broken level, procent
                result += "\n";
                if (item.BrokenNotresc) {
                    result += Game.GetText(TextPackName::Game, MsgStr::StrDeteriorationNoResc);
                }
                else if (item.BrokenLowBroken) {
                    result += Game.GetText(TextPackName::Game, MsgStr::StrDeteriorationBrokenLow);
                }
                else if (item.BrokenNormBroken) {
                    result += Game.GetText(TextPackName::Game, MsgStr::StrDeteriorationBrokenNorm);
                }
                else if (item.BrokenHighBroken) {
                    result += Game.GetText(TextPackName::Game, MsgStr::StrDeteriorationBrokenHigh);
                }
                else {
                    result += Game.ReplaceText(Game.GetText(TextPackName::Game, MsgStr::StrDeteriorationProcent),
                                               "VALUE",
                                               deterioration * 100 / Tla::MaxDeterioration);
                }

                // Service
                if (item.BrokenService) {
                    result += "\n" + Game.GetText(TextPackName::Game, MsgStr::StrDeteriorationService);
                }

                // Service ext
                if (item.BrokenServiceExt) {
                    result += "\n" + Game.GetText(TextPackName::Game, MsgStr::StrDeteriorationServiceExt);
                }

                // Broken count
                Critter chosen = Game.GetChosen();
                if (valid(chosen) && chosen.PerkMrFixit != 0) {
                    result += "\n" + Game.ReplaceText(Game.GetText(TextPackName::Game, MsgStr::StrDeteriorationBrokenCount), "VALUE", brokenCount);
                }
            }

            // Key id
            if (item.Type == ItemType::Key) {
                result += "\n" + Game.ReplaceText(Game.GetText(TextPackName::Game, MsgStr::StrInvKeyNumber), "KEY_ID", item.LockerId);
            }
        }
    }

    // Format tags
    if (item.Lexems != "") {
        return Game.FormatTags(result, item.Lexems);
    }
    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Critter description. Look types look in _client_defines.fos, Critter look types.
string critter_description(Critter& cr, CritterLookTypes lookType)
{
    string result;
    int gender = cr.Gender;

    // Player
    if (cr.IsControlledByPlayer) {
        // Only name
        if (lookType == CritterLookTypes::OnlyName) {
            result = cr.Name; // No change
        }
        // Short info
        else if (lookType == CritterLookTypes::LookShort) {
            result += Game.GetText(TextPackName::Game, STR_CRIT_LOOK1(gender));
            result += cr.Name;
            result += ".";
        }
        // Full info
        else {
            result += Game.GetText(TextPackName::Game, STR_CRIT_LOOK1(gender));

            // Age
            uint ageStr = Game.GetTextNumUpper(TextPackName::Game, STR_CRIT_LOOK_AGE(gender, cr.Age));
            if (ageStr != 0) {
                result += Game.GetText(TextPackName::Game, ageStr);
            }
            else {
                result += cr.Name;
            }
            result += ".";
        }
    }
    // Npc
    else {
        hstring dlgId = cr.DialogId;
        hstring npcPid = cr.ProtoId;
        bool defaultText = false;

        if (lookType == CritterLookTypes::OnlyName) {
            result = Game.GetText(TextPackName::Dialogs, STR_NPC_NAME(dlgId, npcPid));
        }
        // Short info
        else if (lookType == CritterLookTypes::LookShort) {
            if (cr.IsAlive() && Game.IsTextPresent(TextPackName::Dialogs, STR_NPC_INFO_LIFE(dlgId, npcPid))) {
                result += Game.GetText(TextPackName::Dialogs, STR_NPC_INFO_LIFE(dlgId, npcPid));
            }
            else if (cr.IsKnockout() && Game.IsTextPresent(TextPackName::Dialogs, STR_NPC_INFO_KO(dlgId, npcPid))) {
                result += Game.GetText(TextPackName::Dialogs, STR_NPC_INFO_KO(dlgId, npcPid));
            }
            else if (cr.IsDead() && Game.IsTextPresent(TextPackName::Dialogs, STR_NPC_INFO_DEAD(dlgId, npcPid))) {
                result += Game.GetText(TextPackName::Dialogs, STR_NPC_INFO_DEAD(dlgId, npcPid));
            }
            else {
                defaultText = true;
            }
        }
        // Full info
        else {
            if (cr.IsAlive() && Game.IsTextPresent(TextPackName::Dialogs, STR_NPC_FULL_INFO_LIFE(dlgId, npcPid))) {
                result += Game.GetText(TextPackName::Dialogs, STR_NPC_FULL_INFO_LIFE(dlgId, npcPid));
            }
            else if (cr.IsKnockout() && Game.IsTextPresent(TextPackName::Dialogs, STR_NPC_FULL_INFO_KO(dlgId, npcPid))) {
                result += Game.GetText(TextPackName::Dialogs, STR_NPC_FULL_INFO_KO(dlgId, npcPid));
            }
            else if (cr.IsDead() && Game.IsTextPresent(TextPackName::Dialogs, STR_NPC_FULL_INFO_DEAD(dlgId, npcPid))) {
                result += Game.GetText(TextPackName::Dialogs, STR_NPC_FULL_INFO_DEAD(dlgId, npcPid));
            }
            else {
                defaultText = true;
            }
        }

        if (defaultText) {
            // Check standart text
            if (Game.IsTextPresent(TextPackName::Dialogs, STR_NPC_NAME(dlgId, npcPid))) {
                if (cr.IsAlive()) {
                    result += Game.ReplaceText(Game.GetText(TextPackName::Game, MsgStr::StrCritLookLife),
                                               "NAME",
                                               Game.GetText(TextPackName::Dialogs, STR_NPC_NAME(dlgId, npcPid)));
                }
                else if (cr.IsKnockout()) {
                    result += Game.ReplaceText(Game.GetText(TextPackName::Game, MsgStr::StrCritLookKo),
                                               "NAME",
                                               Game.GetText(TextPackName::Dialogs, STR_NPC_NAME(dlgId, npcPid)));
                }
                else if (cr.IsDead()) {
                    result += Game.ReplaceText(Game.GetText(TextPackName::Game, MsgStr::StrCritLookDead),
                                               "NAME",
                                               Game.GetText(TextPackName::Dialogs, STR_NPC_NAME(dlgId, npcPid)));
                }
            }
            // Set default text
            else {
                result += Game.GetText(TextPackName::Game, MsgStr::StrCritLookNothing);
            }
        }
    }

    // Additional description
    if (lookType == CritterLookTypes::LookFull) {
        if (result.length() > 0 && result[result.length() - 1] != ".") {
            result += ".";
        }
        result += " ";

        Critter chosen = Game.GetChosen();
        if (valid(chosen) && chosen.PerkAwareness != 0) // Awareness
        {
            result += Game.GetText(TextPackName::Game, STR_CRIT_LOOK_HP(gender));
            result = Game.ReplaceText(result, "CUR", cr.CurrentHp);
            result = Game.ReplaceText(result, "MAX", cr.MaxLife);

            AbstractItem item = CritterItem::GetActive(cr);
            if (_CritIsInjured(cr)) {
                if (valid(item)) {
                    result += ", ";
                }
                else {
                    result += Game.GetText(TextPackName::Game, MsgStr::StrAnd);
                }

                result += Game.GetText(TextPackName::Game, STR_CRIT_LOOK_LIMBS(gender, false));
            }

            if (valid(item)) {
                if (item.Type == ItemType::Weapon) {
                    if (item.Weapon_MaxAmmoCount == 0) {
                        result += Game.GetText(TextPackName::Game, MsgStr::StrCritLookWeap);
                        result = Game.ReplaceText(result, "WEAPON", Game.GetText(TextPackName::Items, STR_ITEM_NAME(item)));
                    }
                    else {
                        result += Game.GetText(TextPackName::Game, MsgStr::StrCritLookWeapAmmo);
                        result = Game.ReplaceText(result, "WEAPON", Game.GetText(TextPackName::Items, STR_ITEM_NAME(item)));
                        result = Game.ReplaceText(result, "CUR", item.AmmoCount);
                        result = Game.ReplaceText(result, "MAX", item.Weapon_MaxAmmoCount);
                        result = Game.ReplaceText(result, "AMMO", Game.GetText(TextPackName::Game, STR_CALIBER(item.Weapon_Caliber)));
                    }
                }
                else {
                    result += Game.GetText(TextPackName::Game, MsgStr::StrCritLookMisc);
                    result = Game.ReplaceText(result, "MISC", Game.GetText(TextPackName::Items, STR_ITEM_NAME(item)));
                }
            }
        }
        else // Simple
        {
            result += Game.GetText(TextPackName::Game, STR_CRIT_LOOK_WHO(gender));

            int hp_proc = cr.CurrentHp * 100 / cr.MaxLife;
            if (cr.IsDead()) {
                result += Game.GetText(TextPackName::Game, STR_CRIT_LOOK_STATE(0));
            }
            else if (hp_proc < 34) {
                result += Game.GetText(TextPackName::Game, STR_CRIT_LOOK_STATE(1));
            }
            else if (hp_proc < 67) {
                result += Game.GetText(TextPackName::Game, STR_CRIT_LOOK_STATE(2));
            }
            else if (hp_proc < 100) {
                result += Game.GetText(TextPackName::Game, STR_CRIT_LOOK_STATE(3));
            }
            else {
                result += Game.GetText(TextPackName::Game, STR_CRIT_LOOK_STATE(4));
            }

            if (_CritIsInjured(cr)) {
                if (hp_proc < 90) {
                    result += Game.GetText(TextPackName::Game, MsgStr::StrAnd);
                }
                result += Game.GetText(TextPackName::Game, STR_CRIT_LOOK_LIMBS(gender, hp_proc >= 90));
            }
        }
        result += ".";
    }

    // Format tags
    if (cr.Lexems != "") {
        return Game.FormatTags(result, cr.Lexems);
    }
    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine cost of single item.
// To allow function set Settings.CustomItemCost to true.
// Don't forgot specify this function in client script.
uint item_cost(Item item, Critter& chosen, Critter& npc, bool sell)
{
    return sell ? 1 : 2;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine available timeouts.
void get_available_timeouts(CritterProperty[] & timeouts)
{
    for (uint i = 0; i < CritterPropertyGroup::Timeouts.length(); i++) {
        timeouts.insertLast(CritterPropertyGroup::Timeouts[i]);
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on some critter action.
void critter_action(bool localCall, Critter cr, CritterAction action, int actionExt, AbstractItem item)
{
    // Not process locally called actions
    if (cr.IsChosen && not localCall) {
        switch (action) {
        case CritterAction::MoveItem:
        case CritterAction::SwapItems:
        case CritterAction::UseItem:
        case CritterAction::DropItem:
        case CritterAction::UseWeapon:
        case CritterAction::ReloadWeapon:
        case CritterAction::UseSkill:
        // case CritterAction::PickItem:
        case CritterAction::PickCritter:
        case CritterAction::OperateContainer:
            return; // Skip processing
        default:
            break; // Processing
        }
    }

    AbstractItem proto = (valid(item) ? item : CritterItem::GetActive(cr));
    if ((action >= CritterAction::MoveItem && action <= CritterAction::OperateContainer) || action == CritterAction::StandUp) {
        CurPlayer.ServerCall.Rpc_Wait(Settings.Breaktime);
    }

    switch (action) {
    case CritterAction::MoveItem:
        if (cr.IsAlive()) {
            CritterItemSlot fromSlot = CritterItemSlot(actionExt);
            CritterItemSlot toSlot = item.CritterSlot;

            cr.StopAnim();

            if (toSlot == CritterItemSlot::Main) {
                if (proto.Type == ItemType::Weapon) {
                    cr.Animate(proto.Weapon_StateAnim, CritterActionAnim::ShowWeapon, item);
                }
                else {
                    cr.Animate(CritterStateAnim::None, CritterActionAnim::ShowWeapon, item);
                }
            }
            else if (fromSlot == CritterItemSlot::Main) {
                cr.Animate(CritterStateAnim::None, CritterActionAnim::HideWeapon, item);
            }
            else {
                cr.Animate(CritterStateAnim::None, CritterActionAnim::SwitchItems);
            }
        }
        break;
    case CritterAction::SwapItems:
        break;
    case CritterAction::UseItem:
        if (cr.IsAlive() && valid(proto)) {
            cr.StopAnim();

            if (proto.Type == ItemType::Weapon && cr.IsAnimAvailable(proto.Weapon_StateAnim, proto.Weapon_ActionAnim_0)) {
                cr.Animate(proto.Weapon_StateAnim, proto.Weapon_ActionAnim_0, item);
            }
            else {
                cr.Animate(CritterStateAnim::None, CritterActionAnim::Use, item);
            }
        }
        break;
    case CritterAction::DropItem:
        if (cr.IsAlive()) {
            cr.StopAnim();
            cr.Animate(CritterStateAnim::None, CritterActionAnim::PickUp);
        }
        break;
    case CritterAction::UseWeapon:
        if (cr.IsAlive() && valid(proto)) {
            int use = (actionExt & 0xF);
            int aim = ((actionExt >> 4) & 0xF);
            bool fail = (((actionExt >> 8) & 1) != 0);

            cr.StopAnim();

            cr.Animate(CritterStateAnim::None, CritterActionAnim::PrepareWeapon);

            // Game.PlaySound( 'W', SOUND_WEAPON_USE, _WeaponSoundId( proto, use ), use != 1 ? '1' : '2' );
            cr.Animate(CritterStateAnim::None, _WeaponActionAnim(proto, use), item);

            if (fail) {
                cr.Animate(CritterStateAnim::None, CritterActionAnim::DamageFront, item);
            }
            else {
                cr.Animate(CritterStateAnim::None, CritterActionAnim::TurnOffWeapon);
            }
        }
        break;
    case CritterAction::ReloadWeapon:
        if (cr.IsAlive() && valid(proto)) {
            cr.StopAnim();
            // Game.PlaySound( 'W', SOUND_WEAPON_RELOAD, proto.Weapon_SoundId_0, '1' );
            cr.Animate(item.Weapon_StateAnim, CritterActionAnim::Reload, item);
        }
        break;
    case CritterAction::UseSkill:
        if (cr.IsAlive() && actionExt != CritterProperty::SkillSneak) {
            cr.StopAnim();
            cr.Animate(CritterStateAnim::None, CritterActionAnim::Use);
        }
        break;
    case CritterAction::PickItem:
        if (cr.IsAlive() && valid(proto)) {
            cr.StopAnim();
            cr.Animate(CritterStateAnim::None, proto.GroundLevel ? CritterActionAnim::PickUp : CritterActionAnim::Use);
        }
        break;
    case CritterAction::PickCritter:
        if (cr.IsAlive()) {
            cr.StopAnim();

            switch (actionExt) // 0 - loot, 1 - steal, 2 - push
            {
            case 0:
                cr.Animate(CritterStateAnim::None, CritterActionAnim::Loot);
                break;
            case 1:
                cr.Animate(CritterStateAnim::None, CritterActionAnim::Steal);
                break;
            case 2:
                cr.Animate(CritterStateAnim::None, CritterActionAnim::Push);
                break;
            default:
                break;
            }
        }
        break;
    case CritterAction::OperateContainer:
        if (cr.IsAlive()) {
            cr.StopAnim();
            int transferType = actionExt / 10;
            int directionType = actionExt % 10;

            if (transferType == TransferTypes::HexContDown || transferType == TransferTypes::CritLoot) {
                cr.Animate(CritterStateAnim::None, CritterActionAnim::PickUp);
            }
            else {
                cr.Animate(CritterStateAnim::None, CritterActionAnim::Use);
            }
        }
        break;
    case CritterAction::Dodge:
        if (not cr.IsAnimPlaying() && cr.IsAlive()) {
            cr.Animate(CritterStateAnim::None, actionExt == 0 ? CritterActionAnim::DodgeFront : CritterActionAnim::DodgeBack);
        }
        break;
    case CritterAction::Damage:
        if (not cr.IsAnimPlaying()) {
            if (cr.IsAlive()) {
                cr.Animate(CritterStateAnim::None, actionExt == 0 ? CritterActionAnim::DamageFront : CritterActionAnim::DamageBack);
            }
            else if (cr.IsKnockout()) {
                cr.Animate(CritterStateAnim::None, actionExt == 0 ? CritterActionAnim::DamageProneFront : CritterActionAnim::DamageProneBack);
            }
        }
        else {
            // Todo:
            // CritterActionAnim::Walk_DAMAGE_FRONT
            // CritterActionAnim::Walk_DAMAGE_BACK
            // CritterActionAnim::Limp_DAMAGE_FRONT
            // CritterActionAnim::Limp_DAMAGE_BACK
            // CritterActionAnim::Run_DAMAGE_FRONT
            // CritterActionAnim::Run_DAMAGE_BACK
        }
        break;
    case CritterAction::DamageForce:
        if (cr.IsAlive()) {
            cr.StopAnim();
            cr.Animate(CritterStateAnim::None, actionExt == 0 ? CritterActionAnim::DamageFront : CritterActionAnim::DamageBack);
        }
        else if (cr.IsKnockout()) {
            cr.StopAnim();
            cr.Animate(CritterStateAnim::None, actionExt == 0 ? CritterActionAnim::DamageProneFront : CritterActionAnim::DamageProneBack);
        }
        break;
    case CritterAction::Knockout:
        if (not cr.IsKnockout()) {
            cr.StopAnim();
            cr.Animate(CritterStateAnim::None, CritterActionAnim(actionExt));
        }
        break;
    case CritterAction::StandUp:
        if (cr.IsKnockout()) {
            cr.StopAnim();
            cr.Animate(CritterStateAnim::None, CritterActionAnim(actionExt));
        }
        break;
    case CritterAction::Fidget:
        if (cr.IsAlive() && not cr.IsAnimPlaying()) {
            cr.Animate(CritterStateAnim::None, CritterActionAnim::Fidget);
        }
        break;
    case CritterAction::Dead:
        if (not cr.IsDead()) {
            cr.StopAnim();
            cr.Animate(CritterStateAnim::None, CritterActionAnim(actionExt));
        }
        break;
    case CritterAction::Connect:
        break;
    case CritterAction::Disconnect:
        break;
    case CritterAction::Respawn:
        break;
    case CritterAction::Refresh:
        break;
    default:
        break;
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call before critter animation playing.
void critter_animation_process(bool animateStay, Critter cr, CritterStateAnim stateAnim, CritterActionAnim actionAnim, AbstractItem item)
{
    if (!animateStay) {
        Animation::PlayAnimSound(cr.ModelName, cr.Gender, stateAnim, actionAnim);
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on some items collection generating.
// To force function call use RefreshItemsCollection(int collection)
// Collection constants see in Items collections _client_defines.fos
// If you want disable showing than just null pointer in collection
void items_collection(int collection, Item[] items)
{
    // Example
    // Disable showing of all weapons in USE mode:
    /*if(collection == ITEMS_USE)
       {
            for(uint i = 0, j = items.length(); i < j; i++)
                    if(items[i].Type == ItemType::Weapon)
                            items[i] = null;
       }*/
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on message added to message box.
// Parameters messageText and messageType can be changed for engine handler.
void message_box(int messageType, string messageText)
{
    Gui::MessageBox[] messageBoxes = Gui::CollectMessageBoxes();
    for (uint i = 0; i < messageBoxes.length(); i++) {
        messageBoxes[i].AddMessage(messageText, messageType);
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called to check interface hit.
bool check_interface_hit(int x, int y)
{
    return Gui::CheckHit(x, y);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called to check current container item under mouse.
bool get_cont_item(ident& itemId, bool& isEnemy)
{
    Gui::Screen screen = Gui::GetActiveScreen();
    if (screen is null || screen.Index != CLIENT_SCREEN_INVENTORY) { // screen.IsHardcoded ||
        return false;
    }

    if (Settings.Cursor == CursorType::Default) {
        Gui::Object hitObj = screen.FindMouseHit();
        if (hitObj !is null && hitObj.Grid !is null) {
            Gui::ItemView itemView = cast<Gui::ItemView>(hitObj.Grid);
            if (itemView !is null) {
                Item item = itemView.GetItem(hitObj.CellIndex);
                if (item !is null) {
                    itemId = item.Id;
                    isEnemy = (itemView.UserDataExt == ITEMS_BARTER_OPPONENT || itemView.UserDataExt == ITEMS_BARTER_OPPONENT_OFFER ||
                               itemView.UserDataExt == ITEMS_PICKUP_FROM);
                }
            }
        }
    }

    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Items and drop handler.
bool ItemsDragAndDropHandler(Gui::Object obj, Gui::Object target)
{
    if (obj.Grid is null) {
        return false;
    }

    // Destination
    Gui::ItemView targetItemView;
    Item targetItem;
    if (target !is null) {
        if (target.Grid !is null) {
            targetItemView = cast<Gui::ItemView>(target.Grid);
            if (targetItemView is null) {
                return false;
            }
            targetItem = targetItemView.GetItem(target.CellIndex);
        }
        else {
            targetItemView = cast<Gui::ItemView>(target);
            if (targetItemView is null) {
                return false;
            }
        }
    }

    // Source
    Gui::ItemView objItemView = cast<Gui::ItemView>(obj.Grid);
    if (objItemView is null) {
        return false;
    }
    Item objItem = objItemView.GetItem(obj.CellIndex);
    if (objItem is null) {
        return false;
    }

    // Drop item
    if (targetItemView is null) {
        if (objItem.Stackable && objItem.Count > 1) {
            Game.ShowScreen(CLIENT_SCREEN_SPLIT, dict<string, any> = {{"TargetItemId", objItem.Id}, {"ItemsCollection", ITEMS_CHOSEN_ALL}});
        }
        else {
            ChosenActions::SetChosenActions(array<any> = {Tla::ChosenMoveItem, objItem.Id, objItem.Count, CritterItemSlot::Outside, 0, 0, 0});
        }
        return true;
    }

    // Barter
    if ((objItemView.UserDataExt == ITEMS_BARTER && targetItemView.UserDataExt == ITEMS_BARTER_OFFER) ||
        (objItemView.UserDataExt == ITEMS_BARTER_OPPONENT && targetItemView.UserDataExt == ITEMS_BARTER_OPPONENT_OFFER) ||
        (objItemView.UserDataExt == ITEMS_BARTER_OFFER && targetItemView.UserDataExt == ITEMS_BARTER) ||
        (objItemView.UserDataExt == ITEMS_BARTER_OPPONENT_OFFER && targetItemView.UserDataExt == ITEMS_BARTER_OPPONENT)) {
        if (objItem.Stackable && objItem.Count > 1) {
            Game.ShowScreen(CLIENT_SCREEN_SPLIT, dict<string, any> = {{"TargetItemId", objItem.Id}, {"ItemsCollection", objItemView.UserDataExt}});
        }
        else {
            ClientItems::BarterTransfer(objItem.Id, objItemView.UserDataExt, objItem.Count);
            //Game.CustomCall("BarterMoveItem " + objItem.Id + " " + objItemView.UserDataExt + " " + objItem.Count);
        }
        return true;
    }

    // Loot
    if ((objItemView.UserDataExt == ITEMS_PICKUP && targetItemView.UserDataExt == ITEMS_PICKUP_FROM) ||
        (objItemView.UserDataExt == ITEMS_PICKUP_FROM && targetItemView.UserDataExt == ITEMS_PICKUP)) {
        if (objItem.Stackable && objItem.Count > 1) {
            // Game.CustomCall( "SplitItem " + objItem.Id + " " + objItemView.UserDataExt );
            Game.ShowScreen(CLIENT_SCREEN_SPLIT, dict<string, any> = {{"TargetItemId", objItem.Id}, {"ItemsCollection", objItemView.UserDataExt}});
        }
        else {
            any[] actions = {};
            ChosenActions::GetChosenActions(actions);
            any[] useItemAction = {Tla::ChosenMoveItemCont, objItem.Id, objItemView.UserDataExt, objItem.Count, 0, 0, 0};
            for (uint i = 0; i < useItemAction.length(); i++) {
                actions.insertLast(useItemAction[i]);
            }
            ChosenActions::SetChosenActions(actions);
        }
        return true;
    }

    // Load ammo
    if ((objItemView.UserDataExt == ITEMS_INVENTORY || objItemView.UserDataExt == ITEMS_CHOSEN_ALL) && targetItem !is null && objItem.Type == ItemType::Ammo &&
        targetItem.Type == ItemType::Weapon) {
        if (objItem.Ammo_Caliber == targetItem.Weapon_Caliber &&
            (targetItem.AmmoCount < targetItem.Weapon_MaxAmmoCount || targetItem.AmmoPid != objItem.ProtoId)) {
            any[] actions = {};
            ChosenActions::GetChosenActions(actions);
            any[] useItemAction = {Tla::ChosenUseItem, targetItem.Id, 0, TARGET_SELF_ITEM, objItem.Id, USE_RELOAD, 0};
            for (uint i = 0; i < useItemAction.length(); i++) {
                actions.insertLast(useItemAction[i]);
            }
            ChosenActions::SetChosenActions(actions);
            return true;
        }
    }
    // Transfer between slots
    int objSlot = objItemView.UserData;
    int targetSlot = targetItemView.UserData;
    if (objSlot != targetSlot) {
        any[] actions = {};
        ChosenActions::GetChosenActions(actions);
        any[] useItemAction = {Tla::ChosenMoveItem, objItem.Id, objItem.Count, targetSlot, 0, 0, 0};
        for (uint i = 0; i < useItemAction.length(); i++) {
            actions.insertLast(useItemAction[i]);
        }
        ChosenActions::SetChosenActions(actions);
        return true;
    }
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Event on create lmenu node collection.
// In nodes located collected nodes by engine.
void lmenu_collect_nodes(Critter cr, Item item, int[] & nodes)
{
    //
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Event on lmenu node selection.
bool lmenu_node_select(int nodeType, Critter cr, Item item)
{
    // Pass to engine handler
    return false;
}

void on_screen_size_changed()
{
    Gui::Callback_OnResolutionChanged();
}
