namespace Location
{

#if SERVER

///@ Property Location PrivateServer int32 MaxPlayers
///@ Property Location PrivateServer bool AutoGarbage
///@ Property Location PrivateServer bool GeckVisible // Todo: improve GeckVisible mechanics
///@ Property Location PrivateServer hstring[] Automaps
///@ Property Critter PrivateServer bool IsGeck
///@ Property Item PrivateServer bool IsGeck

void ModuleInit()
{
    Game.OnLocationInit.Subscribe(OnLocationInit);
}

void OnLocationInit(Location loc, bool firstTime)
{
    Game.StartTimeEvent(Time::Seconds(1), LocationGarbager, loc.Id);
}

Location CreateLocation(hstring protoId, ipos wpos, Critter[] critters = null, dict<LocationProperty, any> props = null)
{
    props = props != null ? props.clone() : dict<LocationProperty, any>();
    props[LocationProperty::WorldPos] = wpos;

    Location loc = Game.CreateLocation(protoId, props);

    if (critters != null) {
        for (int i = 0; i < critters.length(); i++) {
            Location::SetKnownLoc(critters[i], loc.Id);
        }
    }

    return loc;
}

void LocationGarbager(any locId)
{
    Location loc = Game.GetLocation(ident(locId));
    if (loc == null) {
        return;
    }

    if (loc.AutoGarbage && CheckLocationForGarbage(loc)) {
        Game.DestroyLocation(loc);
    }
    else {
        Game.StartTimeEvent(Time::Seconds(1), LocationGarbager, loc.Id);
    }
}

bool CheckLocationForGarbage(Location loc)
{
    for (int i = 0; i < loc.GetMapCount(); i++) {
        Map map = loc.GetMapByIndex(i);

        if (!CheckMapForGarbage(map)) {
            return false;
        }

        // Todo: improve Item::IsGeck for map
        //if (map.GetItem(ItemProperty::IsGeck, 1) != null) {
        //    return false;
        //}
    }

    return true;
}

bool CheckMapForGarbage(Map map)
{
    Critter[] playerCritters = map.GetCritters(CritterFindType::Players);

    if (!playerCritters.isEmpty()) {
        return false;
    }

    Critter[] nonPlayerCritters = map.GetCritters(CritterFindType::Npc);

    for (int i = 0; i < nonPlayerCritters.length(); i++) {
        Critter npc = nonPlayerCritters[i];

        if (npc.IsGeck) {
            return false;
        }

        if (!npc.IsNoHome && npc.HomeMapId != map.Id) {
            return false;
        }

        if (npc.GetItem(ItemProperty::IsGeck, 1) != null) {
            return false;
        }
    }

    return true;
}

// Позволяет определить, знает ли игрок об указанной локации или нет.
bool IsKnownLoc(Critter cr, ident locId)
{
    return cr.KnownLocations.find(locId) != -1;
}

bool IsKnownLoc(Critter cr, Location loc)
{
    if (loc == null) {
        return false;
    }

    return IsKnownLoc(cr, loc.Id);
}

bool IsKnownLoc(Critter cr, hstring locPid)
{
    return IsKnownLoc(cr, Game.GetLocation(locPid));
}

// Делает локацию видимой для криттера.
void SetKnownLoc(Critter cr, ident locId)
{
    if (locId == ZERO_IDENT) {
        return;
    }

    auto knownLocations = cr.KnownLocations.clone();
    knownLocations.insertLast(locId);
    cr.KnownLocations = knownLocations;
}

void SetKnownLoc(Critter cr, Location loc)
{
    if (loc == null) {
        return;
    }

    SetKnownLoc(cr, loc.Id);
}

void SetKnownLoc(Critter cr, hstring locPid)
{
    SetKnownLoc(cr, Game.GetLocation(locPid));
}

// Делает локацию невидимой для криттера.
void UnsetKnownLoc(Critter cr, ident locId)
{
    auto knownLocations = cr.KnownLocations.clone();
    knownLocations.remove(locId);
    cr.KnownLocations = knownLocations;
}

void UnsetKnownLoc(Critter cr, Location loc)
{
    if (loc == null) {
        return;
    }

    UnsetKnownLoc(cr, loc.Id);
}

void UnsetKnownLoc(Critter cr, hstring locPid)
{
    UnsetKnownLoc(cr, Game.GetLocation(locPid));
}

// Локация, которая автоматически удаляется через определенное время.
// Установка даты удаления локации в переменную. Внимание, одной установки переменной недостаточно для удаления локации.
// Location - локация, для которой назначается переменная
// time - игровое время в секундах,
void SetLocationDeleteTime(Location loc, timespan time)
{
    Game.StartTimeEvent(time, DeferredDestroyLocation, loc.Id); //SavedDeferredCall
}

void DeferredDestroyLocation(any value)
{
    Location loc = Game.GetLocation(ident(value));
    if (loc !is null) {
        loc.AutoGarbage = true;
    }
}

// Создание видимой для игрока локации и запоминание ее Id  в переменную, если номер переменной > 0.
// player - персонаж, для которого будет сохранена локация
// locPid - код прототипа локации
// worldX, worldY - координаты локации на глобальной карте
// delta - максимальное смещение локации относительно указанных координат
// varNum - номер переменной игрока в которую сохраняется код Id локации
Location CreateLocationForCritter(Critter player, hstring locPid, int worldX, int worldY, int delta, int varNum)
{
    Location loc = Location::CreateLocation(locPid, ipos(worldX + Game.Random(-1 * delta, delta), worldY + Game.Random(-1 * delta, delta)), null);
    if (!valid(loc)) {
        return null;
    }

    loc.AutoGarbage = false;
    SetKnownLoc(player, loc.Id);
    if (varNum > 0) {
        player.SetAsAny(CritterProperty(varNum), loc.Id);
    }
    return loc;
}

bool IsCanEnter(Location loc, int playersCount)
{
    if (loc.MaxPlayers != 0) {
        for (int i = 0; i < loc.GetMapCount(); i++) {
            playersCount += loc.GetMapByIndex(i).GetCritters(CritterFindType::Players).length();
            if (playersCount >= loc.MaxPlayers) {
                return false;
            }
        }
    }
    return true;
}

void _DeadInit(Critter cr, bool firstTime)
{
    CritterState::ToDead(cr, CritterActionAnim::DeadFront, null);
    cr.ReplicationTime = -1;
}

void ValidateKnownLocations(Critter cr)
{
    ident[] knownLocs = cr.KnownLocations.clone();
    for (int i = knownLocs.length() - 1; i >= 0; i--) {
        if (Game.GetLocation(knownLocs[i]) == null) {
            knownLocs.removeAt(i);
        }
    }
    cr.KnownLocations = knownLocs;
}

Location[] GetLocationsInRadius(ipos wpos, int radius)
{
    Location[] result = {};
    Location[] locations = Game.GetLocations();

    for (int i = 0; i < locations.length(); i++) {
        Location loc = locations[i];

        if (Math::Distance(wpos, loc.WorldPos) <= loc.Radius + radius) {
            result.insertLast(loc);
        }
    }

    return result;
}

Location[] GetVisibleLocations(ipos wpos, int radius, Critter cr)
{
    Location[] result = {};
    Location[] locations = Game.GetLocations();
    auto knownLocations = cr.KnownLocations;

    for (int i = 0; i < locations.length(); i++) {
        Location loc = locations[i];

        if (Math::Distance(wpos, loc.WorldPos) <= loc.Radius + radius && !loc.Hidden) {
            if (knownLocations.find(loc.Id) != -1) {
                result.insertLast(loc);
            }
        }
    }

    return result;
}

Location[] GetZoneLocations(int zx, int zy, int zoneRadius)
{
    Location[] result = {};
    int wx = zx * Settings.GlobalMapZoneLength;
    int wy = zy * Settings.GlobalMapZoneLength;
    Location[] locations = Game.GetLocations();

    for (int i = 0; i < locations.length(); i++) {
        Location loc = locations[i];

        if (!loc.Hidden && IsIntersectZone(wx, wy, 0, loc.WorldPos.x, loc.WorldPos.y, loc.Radius, zoneRadius)) {
            result.insertLast(loc);
        }
    }

    return result;
}

bool IsIntersectZone(int wx1, int wy1, int w1Radius, int wx2, int wy2, int w2Radius, int zones)
{
    int z = Settings.GlobalMapZoneLength;
    int r1L = (wx1 - w1Radius) / z - zones;
    int r1T = (wy1 - w1Radius) / z - zones;
    int r1R = (wx1 + w1Radius) / z + zones;
    int r1B = (wy1 + w1Radius) / z + zones;
    int r2L = (wx1 - w1Radius) / z - zones;
    int r2T = (wy1 - w1Radius) / z - zones;
    int r2R = (wx1 + w1Radius) / z + zones;
    int r2B = (wy1 + w1Radius) / z + zones;
    return r1L <= r2R && r2L <= r1R && r1T <= r2B && r2T <= r1B;
}

#endif

}
