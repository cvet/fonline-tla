namespace Roulette
{

#if SERVER

// Author: Tab10id
//
// American roulette
// Using in roulette
//

#define DID                         (Content::Dialog::all_roulette)

#define STR_INVALID_COORD           (DLGSTR(DID, 7))
#define STR_BET_OPERATION_SUCCESS   (DLGSTR(DID, 10))
#define STR_COORD_OPERATION_SUCCESS (DLGSTR(DID, 9))
#define STR_INVALID_MONEY           (DLGSTR(DID, 8))
#define STR_NUMBER                  (5)
#define STR_ZERO                    (1)
#define STR_DOUBLE_ZERO             (2)
#define STR_COLOR_RED               (3)
#define STR_COLOR_BLACK             (4)
#define STR_WINMONEY                (6)
#define STR_CURENT_BET_SIZE         (DLGSTR(DID, 11))
#define STR_BETS_COORDS_INTRO       (DLGSTR(DID, 12))
#define STR_BETS_COORDS             (DLGSTR(DID, 13))
#define STR_SET_BET_TYPE            (DLGSTR(DID, 14))

// В этом файле хранятся настройки игры для различных НПЦ (минимальные/максимальные ставки и тп)
// Для того чтобы заставить нпц играть с теми или иными настойкам, необходимо указать ему соответствующее значение NpcRole
#define INSIDE_BETS            (1)
#define OUTSIDE_BETS           (2)
#define SINGLE_NUMBER_BET      (0)
#define SPLIT_BET              (1)
#define STREET_BET             (2)
#define CORNER_BET             (3)
#define SIX_LINE_BET           (4)
#define COLUMN_BET             (5)
#define DOZEN_BET              (6)
#define EO_BET                 (7)
#define RB_BET                 (8)
#define LH_BET                 (9)

#define BET_SIZE_IS_NULL       (0)
#define BET_SIZE_IS_NOT_NULL   (1)

#define NUMBER_ZERO            (37)
#define NUMBER_DOUBLE_ZERO     (38)

#define SINGLE_NUMBER_PAYOUT   (36)
#define SPLIT_PAYOUT           (18)
#define STREET_PAYOUT          (12)
#define CORNER_PAYOUT          (9)
#define SIX_LINE_PAYOUT        (6)
#define COLUMN_DOZEN_PAYOUT    (3)
#define EORBLH_PAYOUT          (2)

#define RED_COLOR              (0)

#define STANDART_BET_ONE       (1)
#define STANDART_BET_TWO       (2)
#define STANDART_BET_THREE     (3)
#define STANDART_BET_FOUR      (4)
#define STANDART_BET_ALL_MONEY (5)
#define STANDART_BET_MAX       (6)

#define NPC_ROLE_START_VALUE   (72600)

class RouletteTable
{
    int MinBet;           // Минимальная ставка
    int MaxBet;           // Максимальная ставка
    int Bet1;             // Первый вариант ставки в диалоге
    int Bet2;             // Второй вариант ставки в диалоге
    int Bet3;             // Третий вариант ставки в диалоге
    int Bet4;             // Четвертый вариант ставки в диалоге
    int OnCheat1;         // Реакция на обнаружение жульничества типа 1
    int OnCheat2;         // Реакция на обнаружение жульничества типа 2
    int OnCheat3;         // Дополнительное поле
    int CLevel;           // Способность покермана заметить жульничество (от 1 до 10)
    int StopGameMoney;    // Сумма, проигрывая которую крупье перестает играть с Дудом. Если 0, то ограничений нет.
    int WaitForGame;      // Количество игровых дней, которые необходимо подождать, чтобы крупье снова начал играть с Дудом, после того как он его обыграл на
                          // сумму StopGameMoney
    hstring GameCurrency; // Валюта игры (фишки, монеты, тп)

    RouletteTable(int minBet, int maxBet, int bet1, int bet2, int bet3, int bet4, int onCheat1, int onCheat2, int onCheat3, int cLevel, int stopGameMoney,
                  int waitForGame, hstring gameCurrency)
    {
        MinBet = minBet;
        MaxBet = maxBet;
        Bet1 = bet1;
        Bet2 = bet2;
        Bet3 = bet3;
        Bet4 = bet4;
        OnCheat1 = onCheat1;
        OnCheat2 = onCheat2;
        OnCheat3 = onCheat3;
        CLevel = cLevel;
        StopGameMoney = stopGameMoney;
        WaitForGame = waitForGame;
        GameCurrency = gameCurrency;
    }
};
RouletteTable[] RTables = {};

class Starter
{
    Starter()
    {
        InitRTables();
    }
};
Starter aStarter = Starter();

void InitRTables()
{
    RTables.insertLast(RouletteTable(20, 750, 20, 100, 300, 500, 1, 0, 0, 1, 3000, 2, Content::Item::bottle_caps));
    RTables.insertLast(RouletteTable(30, 850, 30, 200, 500, 650, 0, 0, 0, 3, 6000, 3, Content::Item::bottle_caps));
}

void RunCheatScript(int funcNum, Critter player, Critter croupier)
{
    switch (funcNum) {
    case 1:
        _OnCheat1_npc1(player, croupier);
        break;
    default:
        _OnCheatDefault(player, croupier);
        break;
    }
}

void _OnCheat1_npc1(Critter player, Critter croupier)
{
}

void _OnCheatDefault(Critter player, Critter croupier)
{
}

class CBet
{
    int BetType;          // Тип ставки (необходим для расчета выигрыша)
    int BetSize;          // Размер ставки
    int[] BetCoords = {}; // Выигрышные числа данной ставки
    CBet()
    {
        BetType = 0;
        BetSize = 0;
        BetCoords.clear();
    }
    CBet(int betType, int bet, int[] coords)
    {
        BetType = betType;
        BetSize = bet;
        BetCoords = coords;
    }
};

void LoadSettings(int npcRole, Critter croupier) // Загрузка настроек для конкретного нпц
{
    int SettNum = npcRole - NPC_ROLE_START_VALUE; // Получаем номер настройки нпц, для этого отнимаем у роли нпц значение NPC_ROLE_START_VALUE
    if (SettNum >= RTables.length())              // Если номер настроеки игрока больше количества настроек (настройки указаны в файле roulette_game_list_h.fos)
    {
        SettNum = 0; // Устанавливаем нпц стандартные настройки
    }
    if (RTables.length() > 0) // Если в файле roulette_game_list_h.fos есть хотя бы одна группа значений
    {
        MinBet[croupier.RouletteCroupierNum] = RTables[SettNum].MinBet;
        MaxBet[croupier.RouletteCroupierNum] = RTables[SettNum].MaxBet;
        Bet1[croupier.RouletteCroupierNum] = RTables[SettNum].Bet1;
        Bet2[croupier.RouletteCroupierNum] = RTables[SettNum].Bet2;
        Bet3[croupier.RouletteCroupierNum] = RTables[SettNum].Bet3;
        Bet4[croupier.RouletteCroupierNum] = RTables[SettNum].Bet4;
        OnCheat1[croupier.RouletteCroupierNum] = RTables[SettNum].OnCheat1;
        OnCheat2[croupier.RouletteCroupierNum] = RTables[SettNum].OnCheat2;
        OnCheat3[croupier.RouletteCroupierNum] = RTables[SettNum].OnCheat3;
        CLevel[croupier.RouletteCroupierNum] = RTables[SettNum].CLevel;
        StopGameMoney[croupier.RouletteCroupierNum] = RTables[SettNum].StopGameMoney;
        WaitForGame[croupier.RouletteCroupierNum] = RTables[SettNum].WaitForGame;
        GameCurrency[croupier.RouletteCroupierNum] = RTables[SettNum].GameCurrency;
    }
    else // В противном случае
    {
        Game.Log("\n\n<Roulette> Error: Settings not found!"); // выдаем в лог сообщение об ошибке
    }
}

int GetNumber() // Получаем случайное число
{
    int i;
    i = Game.Random(0, 37);
    return i;
}

string GetNumberStr(int number) // Получаем строковое обозначение числа
{
    string res = "";
    number++;
    if (number > 36) {
        if (number == NUMBER_ZERO) // Если число - зеро
        {
            res += "@text Dialogs " + DLGSTR(DID, STR_ZERO) + "@"; // Вытаскиваем из диалога номер для формирования лексемы означающей зеро
        }
        else // Если число - двойное зеро
        {
            res += "@text Dialogs " + DLGSTR(DID, STR_DOUBLE_ZERO) + "@"; // Вытаскиваем из диалога номер для формирования лексемы означающей двойное зеро
        }
    }
    else {
        res += "@text Dialogs " + DLGSTR(DID, STR_NUMBER) + "@" + number + GetColor(number); // Если шарик попал на обычное число выводим это число и его цвет
    }
    res += "\n@text Dialogs " + DLGSTR(DID, STR_WINMONEY) + "@"; // Сохраняем результат
    return res;
}

string GetColor(int i) // Определение цвета числа
{
    string res = "";
    switch (i) {
    case 1:
    case 3:
    case 5:
    case 7:
    case 9:
    case 12:
    case 14:
    case 16:
    case 18:
    case 19:
    case 21:
    case 23:
    case 25:
    case 27:
    case 30:
    case 32:
    case 34:
    case 36:
        res += " @text Dialogs " + DLGSTR(DID, STR_COLOR_RED) +
               "@"; // Для числе 1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36 вытаскиваем сообщение о том что число красное
        break;
    default:                                                           // Для остальных чисел
        res += " @text Dialogs " + DLGSTR(DID, STR_COLOR_BLACK) + "@"; // Формируем лексему обозначающую черный цвет
        break;
    }
    return res;
}

void SaveBetCoords(Critter croupier, int coord)
{
}

void EndGame(Critter croupier) // Завершение игры, обнуляем все служебные переменные
{
    Bets[croupier.RouletteCroupierNum].clear();
    CurBetType[croupier.RouletteCroupierNum] = 0;
    DialogAnswerPageIndex[croupier.RouletteCroupierNum] = 0;
    DialogAnswerNum[croupier.RouletteCroupierNum] = 0;
    croupier.RouletteBetCoord1 = 0;
    croupier.RouletteBetCoord2 = 0;
    croupier.RouletteBetCoord3 = 0;
    AllBetSize[croupier.RouletteCroupierNum] = 0;
}

int CheckWinCash(Critter croupier, int num) // Проходим по всем ставкам игрока для высчитывания его выигрыша
{
    int cash = 0;                                                         // Сумма выигрыша
    for (int i = 0; i < Bets[croupier.RouletteCroupierNum].length(); i++) // Проход по всем ставкам
    {
        for (int m = 0; m < Bets[croupier.RouletteCroupierNum][i].BetCoords.length(); m++) // Проход по всем выигрышным числам в указанной ставке
        {
            if (Bets[croupier.RouletteCroupierNum][i].BetCoords[m] == (num + 1)) // Если число выиграло
            {
                cash +=
                    Bets[croupier.RouletteCroupierNum][i].BetSize * GetMultipier(Bets[croupier.RouletteCroupierNum][i].BetType); // Увеличиваем сумму выигрыша
                break;
            }
        }
    }
    return cash; // Возвращаем сумму выигрыша
}

int GetMultipier(int betType) // Получаем множитель выигрыша
{
    int multipl;
    switch (betType) {
    case SINGLE_NUMBER_BET:
        multipl = SINGLE_NUMBER_PAYOUT;
        break;
    case SPLIT_BET:
        multipl = SPLIT_PAYOUT;
        break;
    case STREET_BET:
        multipl = STREET_PAYOUT;
        break;
    case CORNER_BET:
        multipl = CORNER_PAYOUT;
        break;
    case SIX_LINE_BET:
        multipl = SIX_LINE_PAYOUT;
        break;
    case COLUMN_BET:
    case DOZEN_BET:
        multipl = COLUMN_DOZEN_PAYOUT;
        break;
    case EO_BET:
    case RB_BET:
    case LH_BET:
        multipl = EORBLH_PAYOUT;
        break;
    }
    return multipl;
}

int GetCornerCoord(int index, int coordNum) // Получаем 2 координаты ставки на квадрат
{
    int res = ((index * 3) - 1) / 2;
    if (coordNum == 1) {
        return res;
    }
    else {
        return res + 4;
    }
}

void SetCoords(Critter croupier, int betType, int[] coords) // Высчитываем выигрышные числа по координатам или номеравм ставок
{
    int len = Bets[croupier.RouletteCroupierNum].length(); // Получаем количество ставок
    len--;                                                 // Номер последней в массиве ставки
    switch (betType)                                       // Высчитываем выигрышные числа в зависимости от координат и типа ставки
    {
    case SINGLE_NUMBER_BET:
        Bets[croupier.RouletteCroupierNum][len].BetCoords.resize(1);
        Bets[croupier.RouletteCroupierNum][len].BetCoords[0] = coords[0];
        break;
    case SPLIT_BET:
        Bets[croupier.RouletteCroupierNum][len].BetCoords.resize(2);
        Bets[croupier.RouletteCroupierNum][len].BetCoords[0] = coords[0];
        Bets[croupier.RouletteCroupierNum][len].BetCoords[1] = coords[1];
        break;
    case STREET_BET:
        Bets[croupier.RouletteCroupierNum][len].BetCoords.resize(3);
        SetStreetCoords(croupier, coords[0], len);
        break;
    case CORNER_BET:
        Bets[croupier.RouletteCroupierNum][len].BetCoords.resize(4);
        SetCornerCoords(croupier, coords[0], coords[1], len);
        break;
    case SIX_LINE_BET:
        Bets[croupier.RouletteCroupierNum][len].BetCoords.resize(6);
        SetSixCoords(croupier, coords[0], len);
        break;
    case COLUMN_BET:
        Bets[croupier.RouletteCroupierNum][len].BetCoords.resize(12);
        SetColumnCoords(croupier, coords[0], len);
        break;
    case DOZEN_BET:
        Bets[croupier.RouletteCroupierNum][len].BetCoords.resize(12);
        SetDozenCoords(croupier, coords[0], len);
        break;
    case EO_BET:
        Bets[croupier.RouletteCroupierNum][len].BetCoords.resize(18);
        SetEOCoords(croupier, coords[0], len);
        break;
    case RB_BET:
        Bets[croupier.RouletteCroupierNum][len].BetCoords.resize(18);
        SetRBCoords(croupier, coords[0], len);
        break;
    case LH_BET:
        Bets[croupier.RouletteCroupierNum][len].BetCoords.resize(18);
        SetLHCoords(croupier, coords[0], len);
        break;
    }
}

void SetStreetCoords(Critter croupier, int coord, int len) // Высчитываем выигрышные числа ставки на стрит
{
    Bets[croupier.RouletteCroupierNum][len].BetCoords[0] = coord * 3;
    Bets[croupier.RouletteCroupierNum][len].BetCoords[1] = coord * 3 - 1;
    Bets[croupier.RouletteCroupierNum][len].BetCoords[2] = coord * 3 - 2;
}

void SetCornerCoords(Critter croupier, int coord1, int coord2, int len) // Высчитывем выигрышные числа ставки на квадрат
{
    int x1 = 0, x2 = 0;
    x1 = GetXByNum(coord1);
    x2 = GetXByNum(coord2);
    Bets[croupier.RouletteCroupierNum][len].BetCoords[0] = coord1;
    Bets[croupier.RouletteCroupierNum][len].BetCoords[3] = coord2;
    if (x2 > x1) {
        Bets[croupier.RouletteCroupierNum][len].BetCoords[1] = coord1 + 1;
        Bets[croupier.RouletteCroupierNum][len].BetCoords[2] = coord2 - 1;
    }
    if (x2 < x1) {
        Bets[croupier.RouletteCroupierNum][len].BetCoords[1] = coord1 - 1;
        Bets[croupier.RouletteCroupierNum][len].BetCoords[2] = coord2 + 1;
    }
}

void SetSixCoords(Critter croupier, int coord, int len) // Высчитываем выигрышные числа ставки на 6
{
    coord--;
    for (int i = 0; i < 6; i++) {
        Bets[croupier.RouletteCroupierNum][len].BetCoords[i] = 3 * coord + i + 1;
    }
}

void SetColumnCoords(Critter croupier, int coord, int len) // Высчитываем выигрышные числа ставки на колонку
{
    for (int i = 0; i < 12; i++) {
        Bets[croupier.RouletteCroupierNum][len].BetCoords[i] = i * 3 + coord;
    }
}

void SetDozenCoords(Critter croupier, int coord, int len) // Высчитываем выигрышные числа ставки на дюжину
{
    for (int i = 0; i < 12; i++) {
        Bets[croupier.RouletteCroupierNum][len].BetCoords[i] = coord * 12 - i;
    }
}

void SetEOCoords(Critter croupier, int coord, int len) // Высчитываем выигрышные числа ставки на чет/нечет
{
    if (coord == 0) {
        coord = 2;
    }
    for (int i = 0; i < 18; i++) {
        Bets[croupier.RouletteCroupierNum][len].BetCoords[i] = i * 2 + coord;
    }
}

void SetRBCoords(Critter croupier, int coord, int len) // Высчитываем выигрышные числа ставки на красное/черное
{
    int[] red = {1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36};
    int[] black = {2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35};
    for (int i = 0; i < 18; i++) {
        if (coord == RED_COLOR) {
            Bets[croupier.RouletteCroupierNum][len].BetCoords[i] = red[i];
        }
        else {
            Bets[croupier.RouletteCroupierNum][len].BetCoords[i] = black[i];
        }
    }
}

void SetLHCoords(Critter croupier, int coord, int len) // Высчитываем выигрышные числа ставки на большое/малое
{
    for (int i = 0; i < 18; i++) {
        Bets[croupier.RouletteCroupierNum][len].BetCoords[i] = coord * 18 + i + 1;
    }
}

int GetXByNum(int num) // Получаем номер линии по числу
{
    return num / 3;
}

int GetMaxBetForBetType(Critter croupier, int betType) // Высчитываем максимальный размер ставки для данного типа ставки
{
    int mBet;
    switch (betType) {
    case SINGLE_NUMBER_BET:
        mBet = MaxBet[croupier.RouletteCroupierNum] / 18;
        break;
    case SPLIT_BET:
        mBet = MaxBet[croupier.RouletteCroupierNum] / 9;
        break;
    case STREET_BET:
        mBet = MaxBet[croupier.RouletteCroupierNum] / 6;
        break;
    case CORNER_BET:
        mBet = MaxBet[croupier.RouletteCroupierNum] * 2 / 9;
        break;
    case SIX_LINE_BET:
        mBet = MaxBet[croupier.RouletteCroupierNum] / 3;
        break;
    case COLUMN_BET:
    case DOZEN_BET:
        mBet = MaxBet[croupier.RouletteCroupierNum] * 2 / 3;
        break;
    case EO_BET:
    case RB_BET:
    case LH_BET:
        mBet = MaxBet[croupier.RouletteCroupierNum];
        break;
    }
    return mBet;
}

///@ Property Critter Server int32 RouletteCroupierNum Mutable Persistent
///@ Property Critter Server int32 RouletteBetCoord1 Mutable Persistent
///@ Property Critter Server int32 RouletteBetCoord2 Mutable Persistent
///@ Property Critter Server int32 RouletteBetCoord3 Mutable Persistent
///@ Property Critter Server int32 RouletteBetSize Mutable Persistent
///@ Property Critter Server int32 RouletteBetType Mutable Persistent
///@ Property Critter Server int32[] RouletteData Mutable Persistent

// ToDo
// 1. Использование функции Say About для ввода координат ставок.
// 2. Ставки на 2 поля.
// 3. Использование SayAbout для ввода размера ставки.
// 4. Отображение в диалоге количества игровой валюты, если эта валюта не является монетами.
// 5. Восклицания игрока в случае крупного выигрыша и низком навыке игры.
// 6. Реализация жульничества связанного с подкупом крупье.
// 7. Сохранение данный в массиве по аналогии со скриптом покера.
// 8. Запрет на повторение ставки на то же поле.
// 9. Всплывающие фразы над крупье во время игры.

#define GAMEVAR_COUNT         (1) // ToDo
#define ANSWER_COUNT_PER_PAGE (5)
#define NAV_BACK              (0)
#define NAV_NEXT              (1)

int NumOfNpc = 0;        // При инициализации нового криттера с установленным скриптом рулетки эта переменная будет инкриментированна
int[][] GameData = {{}}; // Массив хранящий статус игры (текущие ставки, номера страниц в диалоге и прочее), создается на случай остановки сервера, или
// необходимости игрока отойти от компьютера во время игры (закрытие диалога не приведет к потере денег)
int[][] GameDataTemp = {{}}; // Временный массив
int[] CurBetType = {};       // Текущий тип ставки (на число, на 2, на 3, на 4, на 6, на 12 (линии, дюжины), черное/красное, четное/нечетное, большое/малое)
// bool[] InGame = {}; // true если игра идет
int[] DialogAnswerPageIndex = {}; // номер страницы во время выбора координад для ставки
int[] DialogAnswerNum = {};       // Количество реплик определенного типа, прошедших проверку. Создано для реализации навигации в диалоге ([назад] и [далее])

CBet[][] Bets = {{}}; // Массив ставок (включая размер)

// Следующие переменные расчитывается для каждого нпц с прикрепленным скриптом рулетки на основе значения NpcRole
int[] MinBet = {};           // Значения минимальной ставки
int[] MaxBet = {};           // Значения максимальной ставки
int[] Bet1 = {};             // Первый вариант ставки для диалога
int[] Bet2 = {};             // Второй вариант ставки для диалога
int[] Bet3 = {};             // Третий вариант ставки для диалога
int[] Bet4 = {};             // Четвертый вариант ставки для диалога
int[] AllBetSize = {};       // Общая сумма ставок игрока
int[] OnCheat1 = {};         // Реакция на жульничество типа 1
int[] OnCheat2 = {};         // Реакция на жульничество типа 2
int[] OnCheat3 = {};         // Реакция на жульничество типа 3
int[] CLevel = {};           // уровень наблюдательности крупье (от 1 до 10)
int[] StopGameMoney = {};    // Сумма после которой крупье перестает играть с игроком
int[] WaitForGame = {};      // Время, которое крупье не будет играть с игроком
hstring[] GameCurrency = {}; // Валюта игры (PID итема)

void _RouletteInit(Critter croupier, bool firstTime)
{
    AddElements();
    croupier.RouletteCroupierNum = NumOfNpc++;         // Приписываем крупье уникальный идентификатор
    DialogAnswerNum[croupier.RouletteCroupierNum] = 0; // обнуляем старые данные
    auto rouletteData = croupier.RouletteData.clone();
    if (rouletteData.length() > 0) // Проверяем наличие данных о текущей игре в сэйве сервера
    {
        GameDataTemp[croupier.RouletteCroupierNum] = rouletteData;
        for (int i = 0; i < GAMEVAR_COUNT; i++) {
            GameData[croupier.RouletteCroupierNum][i] = GameDataTemp[croupier.RouletteCroupierNum][i];
        }
    }
    LoadSettings(croupier.NpcRole, croupier); // Загружаем в переменные данные, соответствующие данному нпц
}

void AddElements()
{
    Bets.grow(1);
    Bets.last() = array<CBet>();
    CurBetType.grow(1);
    DialogAnswerPageIndex.grow(1);
    DialogAnswerNum.grow(1);
    GameDataTemp.grow(1);
    GameDataTemp.last() = array<int>();
    GameData.grow(1);
    GameData.last() = array<int>();
    // InGame.grow(1);
    MinBet.grow(1);
    MaxBet.grow(1);
    Bet1.grow(1);
    Bet2.grow(1);
    Bet3.grow(1);
    Bet4.grow(1);
    AllBetSize.grow(1);
    OnCheat1.grow(1);
    OnCheat2.grow(1);
    OnCheat3.grow(1);
    CLevel.grow(1);
    StopGameMoney.grow(1);
    WaitForGame.grow(1);
    GameCurrency.grow(1);
}

void dlg_MakeBet(Critter master, Critter croupier, string& str) // Ветка выбора координат ставки
{
    int coord = 0;
    if (IS_DIALOG_SAY_MODE(str)) { // Если игрок воспользовался функцией Say About
        // Todo: master.Say(SAY_APPEND, "\n");
        if (!str.tryToInt(coord) and str != "00") { // Проверяем данные на соответствие игровым полям
            // Todo: master.SayMsg(SAY_APPEND, TextPackName::Dialogs, STR_INVALID_COORD); // Если не соответствуют, то выдаем сообщение об ошибке
        }
        else {
            if (str == "00") {
                // Todo: master.SayMsg(SAY_DIALOG,
                //               TextPackName::Dialogs,
                //               STR_COORD_OPERATION_SUCCESS); // Есди игрок ввел "00", то выводим сообщение об успешной операции
            }
            else {
                if ((coord < 0) or (coord > 36)) {
                    // Todo: master.SayMsg(SAY_APPEND,
                    //               TextPackName::Dialogs,
                    //               STR_INVALID_COORD); // Есди число лежит не в промежутке, от нуля, до 36, значит игрок ввел неверное значение координаты
                }
                else {
                    // Todo: master.SayMsg(SAY_DIALOG,
                    //               TextPackName::Dialogs,
                    //               STR_COORD_OPERATION_SUCCESS); // Есди число лежит в промежутке, от нуля, до 36, значит игрок ввел верное значение координаты
                }
            }
        }
    }
    else {
        // if( valid( str ) )                                           // Вызыв функции произошел в момент формирования диалога
        // {
        str = "$makebet" + "@text Dialogs " + STR_SET_BET_TYPE + "@"; // ToDo спрашиваем на что будем ставить (в дальнейшем будет доработка)
        // }
    }
}

void dlg_CheckWinNumber(Critter master, Critter croupier, string& str) // Формирование диалога с выпадение шарика.
{
    int num;     // число на который вападет шарик
    int winCash; // Сумма выигрыша
    if (not IS_DIALOG_GENERATED(str)) {
        return;
    }
    num = GetNumber();                     // Получаем выигрышный номер
    winCash = CheckWinCash(croupier, num); // получаем сумму выигрыша
    if (winCash > 0)                       // Если выигрыш больше 0
    {
        master.AddItem(GameCurrency[croupier.RouletteCroupierNum], winCash); // Выдаем игроку его выигрыш (в игровой валюте)
    }
    str += "$winnumber" + GetNumberStr(num) + winCash; // Выдаем в диалог информацию о сумме выигрыша
    EndGame(croupier);                                 // Завершаем текущую игру
}

void dlg_SetBetSize(Critter master, Critter croupier, string& str) // Установка размера ставки
{
    int mBet; // Максимальный размер ставки, возможный у данного нпц, на данный момент, при этом типе ставки
    if (!IS_DIALOG_SAY_MODE(str)) {
        mBet = GetMaxBetForBetType(croupier, croupier.RouletteBetType);
        // ToDo необходимо сделать проверку на непривышение максимального размера общей суммы ставок

        // Формируем реплики
        str += "$minbet" + MinBet[croupier.RouletteCroupierNum];
        str += "$betone" + Bet1[croupier.RouletteCroupierNum];
        str += "$bettwo" + Bet2[croupier.RouletteCroupierNum];
        str += "$betthree" + Bet3[croupier.RouletteCroupierNum];
        str += "$betfour" + Bet4[croupier.RouletteCroupierNum];
        str += "$maxbet" + mBet;
        str += "$allmoney" + master.CountItem(GameCurrency[croupier.RouletteCroupierNum]);
    }
}

bool d_MaxBet(Critter master, Critter croupier) // Проверка достаточно ли у игрока денег, чтобы сделать максимальную ставку.
{
    int maxBet = GetMaxBetForBetType(croupier, croupier.RouletteBetType);

    // ToDo необходимо сделать проверку на непривышение максимального размера общей суммы ставок

    if (master.CountItem(GameCurrency[croupier.RouletteCroupierNum]) > maxBet) {
        return true;
    }
    else {
        return false;
    }
}

bool d_IsSpecBet(Critter master, Critter croupier, int betType, int betNum) // Показывать ли варианты координат для ставки
{
    if (int(CurBetType[croupier.RouletteCroupierNum]) == betType) // Если текущий тип ставки совпадает с типом реплики
    {
        DialogAnswerNum[croupier.RouletteCroupierNum]++; // Считаем количество ответов, прошедших проверку
        if ((DialogAnswerNum[croupier.RouletteCroupierNum] < (DialogAnswerPageIndex[croupier.RouletteCroupierNum] * ANSWER_COUNT_PER_PAGE + 1)) or
            (DialogAnswerNum[croupier.RouletteCroupierNum] - (DialogAnswerPageIndex[croupier.RouletteCroupierNum] * ANSWER_COUNT_PER_PAGE) >
             ANSWER_COUNT_PER_PAGE)) // если реплика находится на выбранной в диалоге странице.
        {
            return false;
        }
        else {
            return true;
        }
    }
    else {
        return false;
    }
}

bool d_IsNavigationNeeded(Critter master, Critter croupier, int nav) // Нужна ли навигация
{
    if (nav == NAV_BACK) // Есди проверка на навигационную панель для возвращения
    {
        if (DialogAnswerPageIndex[croupier.RouletteCroupierNum] > 0) // если текущая страница не первая
        {
            return true; // показывает навигационную реплику [назад]
        }
        else // страница первая
        {
            return false; // не показывает навигационную реплику [назад]
        }
    }
    else // Есди проверка на навигационную панель для перехода на следующую страницу
    {
        if (DialogAnswerNum[croupier.RouletteCroupierNum] >
            (DialogAnswerPageIndex[croupier.RouletteCroupierNum] + 1) * ANSWER_COUNT_PER_PAGE) // если находимся не на последней странице
        {
            return true; // показывает навигационную реплику [далее]
        }
        else // страница последняя
        {
            return false; // не показывает навигационную реплику [далее]
        }
    }
}

bool d_NoBets(Critter master, Critter croupier, int val) // Делал ли игрок ставки
{
    bool res;
    if (Bets[croupier.RouletteCroupierNum].length() == 0) // Есди игрок не делал ставки
    {
        res = true;
    }
    else {
        res = false;
    }
    if (val == BET_SIZE_IS_NULL) // Есди проверяем, что игрок не делал ставки
    {
        return res; // выводим res
    }
    else // в противном случае
    {
        return !res; // возвращаем обратное значение res
    }
}

bool d_IsMoneyEnough(Critter master, Critter croupier, int val) // Хватает ли денег
{
    int betType;             // Тип ставки
    int outSidebetsSize = 0; // Размер внешних ставок (на черное/красное, четное/нечетное, большое/малое, дюжина, колонка)
    int inSidebetsSize = 0;  // Размер внутренних ставок (число, сплит, стрит, квадрат, 6 чисел)
    int playerMoney = master.CountItem(GameCurrency[croupier.RouletteCroupierNum]); // Количество денег игрока
    int len = Bets[croupier.RouletteCroupierNum].length();                          // Количество ставок
    if (len == 0)                                                                   // Если игрок еще не ставил
    {
        if (playerMoney >= MinBet[croupier.RouletteCroupierNum]) // Проверяем хватает ли у игрока денег на минимальную ставку
        {
            return true; // Денег хватает
        }
        else {
            return false; // Денег не хватает
        }
    }
    else // Если игрок уже сделал одну или несколько ставок, нужно проверить, есть ли какая-нибудь сумма на внутренних ставках, если сумма внутренних ставок +
    // количество денег игрока будет превышать миниимальную ставку, то игрок может играть
    {
        for (int i = 0; i < len; i++) // Проходим по всем совершенным ставкам
        {
            betType = Bets[croupier.RouletteCroupierNum][i].BetType;
            switch (betType) {
            case SINGLE_NUMBER_BET:
            case SPLIT_BET:
            case STREET_BET:
            case CORNER_BET:
            case SIX_LINE_BET:
                inSidebetsSize += Bets[croupier.RouletteCroupierNum][i].BetSize; // Считаем сумму внутренних ставок
                break;
            default:
                outSidebetsSize += Bets[croupier.RouletteCroupierNum][i].BetSize; // Считаем сумму внешних ставок
                break;
            }
        }
        if (val == INSIDE_BETS) // Если проверяем внутренние ставки
        {
            if ((playerMoney + inSidebetsSize) >= MinBet[croupier.RouletteCroupierNum]) {
                return true;
            }
            else {
                return false;
            }
        }
        else // Если проверяем внешние ставки (в дальнейшем, эта часть кода будет изменена)
        {
            if ((playerMoney + outSidebetsSize) >= MinBet[croupier.RouletteCroupierNum]) {
                return true;
            }
            else {
                return false;
            }
        }
    }
}

bool d_IsMoneyEnoughForBet(Critter master, Critter croupier, int betNum) // Хватает ли денего на стандартную ставку (betNum хранит номер стандартной ставки)
{
    int bet;    // Размер стандартной ставки
    int maxBet; // Максимальная ставка
    switch (betNum) {
    case 1:
        bet = Bet1[croupier.RouletteCroupierNum];
        break;
    case 2:
        bet = Bet2[croupier.RouletteCroupierNum];
        break;
    case 3:
        bet = Bet3[croupier.RouletteCroupierNum];
        break;
    case 4:
        bet = Bet4[croupier.RouletteCroupierNum];
    }
    maxBet = GetMaxBetForBetType(croupier, croupier.RouletteBetType); // Получаем максимум для ставки указанного типа
    if (bet > maxBet)                                                 // Если стандартная ставка превышает максимальную для данного типа ставки
    {
        return false; // Не показываем данный вариант ставки
    }
    if (master.CountItem(GameCurrency[croupier.RouletteCroupierNum]) >= bet) // Если денег хватает, то показываем строку
    {
        return true;
    }
    else {
        return false;
    }
}

bool d_AllMoneyBet(Critter master, Critter croupier) // Показывать ли вариант "Поставить все деньги"
{
    int money = master.CountItem(GameCurrency[croupier.RouletteCroupierNum]); // Получаем количество денег игрока
    if ((money <= MaxBet[croupier.RouletteCroupierNum]) and (money != 0))     // Если количество денег у игрока меньше максимальной ставки, то показываем строку
    {
        return true;
    }
    else {
        return false;
    }
}

void r_NavUse(Critter master, Critter croupier, int nav) // Использование навигационной реплики ([назад] или [далее])
{
    DialogAnswerNum[croupier.RouletteCroupierNum] = 0; // Сбрасываем счетчик ответов прошедших проверку на показ
    if (nav == NAV_BACK)                               // Если использована строка [назад]
    {
        DialogAnswerPageIndex[croupier.RouletteCroupierNum]--; // Переключаемся на страницу назад
    }
    else // Если игрок нажал [далее]
    {
        DialogAnswerPageIndex[croupier.RouletteCroupierNum]++; // Переходим на страницу вперед
    }
}

void r_SetBet(Critter master, Critter croupier, int betType, int coord) // Установка типа ставки и ее координат
{
    croupier.RouletteBetType = betType; // Сохраняем тип ставки
    if (betType == SINGLE_NUMBER_BET) { // В случае ставки на число координатой является номер числа
        croupier.RouletteBetCoord1 = coord;
    }
    else { // Для остальных ставок координата - номер ставки (в дальнейшем функция будет доработана для использования кнопки SayAbout)
        croupier.RouletteBetCoord1 = coord;
    }
}

void r_SetBetSize(Critter master, Critter croupier, int betSizeNum) // Установка размера ставки
{
    int len = Bets[croupier.RouletteCroupierNum].length();          // Получаем количество сделаных игроком ставок
    int len2;                                                       // Количество выигрышных чисел
    int coord2 = 0, coord3 = 0;                                     // Массив координат ставки
    int bCoord;                                                     // вспомогательная переменная, хранит число приводящее к выигрышу
    int cbTemp;                                                     // Вспомогательная переменная, хранит номер ставки на квадрат
    string sCoords = "";                                            // Строка с указанием чисел на которые была сделана ставка
    int[] coords = {};                                              // Массив с координатами ставки
    int mBet;                                                       // Максимальная ставка для данного типа ставок
    mBet = GetMaxBetForBetType(croupier, croupier.RouletteBetType); // Получаем максимальную ставку для данного типа ставок
    Bets[croupier.RouletteCroupierNum].resize(len + 1);             // Увеличиваем на 1 массив ставок игрока
    switch (betSizeNum)                                             // Проверяем номер размера ставки
    {
    case STANDART_BET_ONE: // Если выбрана стандартная ставка 1
        croupier.RouletteBetSize = Bet1[croupier.RouletteCroupierNum];
        break;
    case STANDART_BET_TWO: // Если выбрана стандартная ставка 2
        croupier.RouletteBetSize = Bet2[croupier.RouletteCroupierNum];
        break;
    case STANDART_BET_THREE: // Если выбрана стандартная ставка 3
        croupier.RouletteBetSize = Bet3[croupier.RouletteCroupierNum];
        break;
    case STANDART_BET_FOUR: // Если выбрана стандартная ставка 4
        croupier.RouletteBetSize = Bet4[croupier.RouletteCroupierNum];
        break;
    case STANDART_BET_ALL_MONEY: // Если выбрана игра на все деньги
        croupier.RouletteBetSize = master.CountItem(GameCurrency[croupier.RouletteCroupierNum]);
    case STANDART_BET_MAX: // Если выбрана максимальная ставка
        croupier.RouletteBetSize = mBet;
        break;
    default:
        break;
    }
    master.DestroyItem(GameCurrency[croupier.RouletteCroupierNum], croupier.RouletteBetSize);                   // Забираем у игрока деньги
    AllBetSize[croupier.RouletteCroupierNum] += croupier.RouletteBetSize;                                       // Увеличиваем общую сумму ставок
    Bets[croupier.RouletteCroupierNum][len] = CBet(croupier.RouletteBetType, croupier.RouletteBetSize, coords); // Сохраняем ставку в массиве
    coords.resize(3);                                                                                           // Увеличиваем массив координат с null до 3
    if (croupier.RouletteBetType == CORNER_BET) // Высчитываем 2 координаты для ставки на квадрат
    {
        cbTemp = croupier.RouletteBetCoord1;
        croupier.RouletteBetCoord1 = GetCornerCoord(cbTemp, 1); // Получаем первую координату
        coord2 = GetCornerCoord(cbTemp, 2);                     // Получаем вторую координату
    }
    coords[0] = croupier.RouletteBetCoord1; // Сохраняем данные в массиве координат
    coords[1] = coord2;
    coords[2] = coord3;
    SetCoords(croupier, croupier.RouletteBetType, coords);             // Сохраняем координаты ставки
    len2 = Bets[croupier.RouletteCroupierNum][len].BetCoords.length(); // Получаем количество выигрышных чисел для ставки
    for (int i = 0; i < len2; i++)                                     // Проходим по всем выигрышным числам
    {
        bCoord = Bets[croupier.RouletteCroupierNum][len].BetCoords[i]; // Получаем выигрышное число
        if (bCoord < 37) {
            sCoords += "" + bCoord; // Формируем строку выигрышных чисел
        }
        else // Если число больше 36, значит игрок поставил на зеро или на двойное зеро
        {
            if (bCoord == NUMBER_ZERO) {
                sCoords += "@text Dialogs " + DLGSTR(DID, STR_ZERO) + "@"; // подставляем в строку лексему формирующую слово зеро
            }
            else // NUMBER_DOUBLE_ZERO
            {
                sCoords += "@text Dialogs " + DLGSTR(DID, STR_DOUBLE_ZERO) + "@"; // подставляем в строку лексему формирующую слова "двойное зеро"
            }
        }
        if (i != len2 - 1) // Если мы не дошли до последнего числа
        {
            sCoords += ", "; // Ставим запятую между числами
        }
    }
    Messaging::Info(master, TextPackName::Dialogs, STR_BETS_COORDS_INTRO); // Выдаем в статусное окно сообщение "Выигрышные числа" на нужном языке
    Messaging::Info(master, TextPackName::Dialogs, STR_BETS_COORDS, "$result" + sCoords); // Выдаем в статусное окно выигрышные числа
    Messaging::Info(master,
                    TextPackName::Dialogs,
                    STR_CURENT_BET_SIZE,
                    "$betsize" + AllBetSize[croupier.RouletteCroupierNum]); // Выдаем в статусное окно сумму всех поставленных денег
}

void r_SetCurBetType(Critter master, Critter croupier, int betType) // Сохраняем в памяти текущий тип ставки
{
    CurBetType[croupier.RouletteCroupierNum] = betType;      // Сохраняем тип ставки
    DialogAnswerPageIndex[croupier.RouletteCroupierNum] = 0; // Обнуляем номер страницы координат
    DialogAnswerNum[croupier.RouletteCroupierNum] = 0;       // Обнуляем счетчик прошедших проверку реплик ответов игрока
}

void r_StartGame(Critter master, Critter croupier) // Начинаем новую игру
{
    EndGame(croupier); // Для начала игры обнулим все важные переменные, а для этого завершим все предыдущие игры.
}

#endif

}
