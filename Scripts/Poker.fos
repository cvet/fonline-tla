// FOS Server

// Author: Tab10id

//
// Dro-Poker
// Using in poker
//

// Функции
// int8 GetBit(int64 dig,uint8 bnum) получаем значение заданного бита в числе.
// int64 SetBit(int64 digit, uint8 bit_num, bool value) устанавливаем бит числа в заданное значение.
// uint8 GetSuit(uint8 CNum) получаем масть карты
// uint8 GetRank(uint8 CNum) получаем ранг карты
// string GetStrCard(uint8 num) возвращает строковое наименование карты
// uint8 GetCombo(uint8 plNum) возвращает комбинацию и ранг высшей карты

#define DL #(str)
// #define DL #(str) Game.Log(str)

#define PLAYERS_COUNT (4)
#define CARD_COUNT    (5)                                       // В некоторых видах покера раздается по 7 карт
#define GAMEVAR_COUNT (16 + (PLAYERS_COUNT * (CARD_COUNT + 3))) // 48 для PLAYERS_COUNT = 4
// Масти
#define CARD_SPADES             (0)    // пики
#define CARD_HEARTS             (1)    // чирвы
#define CARD_DIAMONDS           (2)    // бубны
#define CARD_CLUBS              (3)    // крести
#define NPC_ROLE_START_VALUE    (1600) // Минимальное значение NpcRole (указывает на номер настроек покера)
#define STR_INVALID_MONEY_COUNT (DLGSTR(Content::Dialog::all_poker, 43))
#define STR_OPERATION_SUCCESS   (DLGSTR(Content::Dialog::all_poker, 44))
#define STR_CHEAT_DEFAULT       (DLGSTR(Content::Dialog::all_poker, 47))
#define STR_CHEAT_1             (DLGSTR(Content::Dialog::all_poker, 48))

// Ранги
#define CARD_2    (0)
#define CARD_3    (1)
#define CARD_4    (2)
#define CARD_5    (3)
#define CARD_6    (4)
#define CARD_7    (5)
#define CARD_8    (6)
#define CARD_9    (7)
#define CARD_10   (8)
#define CARD_JACK (9)  // Валет
#define CARD_LADY (10) // Дама
#define CARD_KING (11) // Король
#define CARD_ACE  (12) // Туз

// ////////////////////////////КОМБИНАЦИИ:///////////////////////////////////////////////////////////////////////////
// 0 - Старшая карта /High Card/ (5-12) старшая карта от 7 до туза (7) - низшая категория					//
// 1 - Пара /One Pair/ (0-12) пары существуют для каждого ранга (12) - пара карт одинакового ранга			//
// 2 - Две пары /Two Pair/ (1-12) высшая пара как минимум - тройки (11)	- 2 разные пары карт				//
// 3 - Сет или тройка /Three of a kind/ (0-12) сеты существуют  для каждого ранга (12) - три карты одного ранга	//
// 4 - Стрейт /Straight/ (4-12) минимальная высшая карта стрейта - 6 (8) - карты идущие по порядку			//
// 5 - Флаш /Flush/ (5-12) старшая карта от 7 до туза (7) - карты одной масти							//
// 6 - Фул Хаус /Full House/ (1-12) старшая карта может быть от 3ки (11) - три карты одного ранга + пара		//
// 7 - Каре /Four of a Kind/ (0-12) (12) - четыре карты одного ранга								//
// 8 - Стрейт Флаш /Straight Flush/ (4-12) (8) - карты одной масти идущие по порядку					//
// 9 - Королевский Флаш /Royal Flush/ (12) (0) - туз, король, дама, валет, десять одной масти				//
// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define CARD_COMBO_HIGHCARD   (0)
#define CARD_COMBO_ONEPAIR    (1)
#define CARD_COMBO_TWOPAIR    (2)
#define CARD_COMBO_SET        (3)
#define CARD_COMBO_STRAIGHT   (4)
#define CARD_COMBO_FLUSH      (5)
#define CARD_COMBO_FULLHOUSE  (6)
#define CARD_COMBO_FOAK       (7)
#define CARD_COMBO_STRFLUSH   (8)
#define CARD_COMBO_ROYALFLUSH (9)

#define D_VA_BANK             (1)
#define D_PRIN                (2)

// Этап игры
#define GAME_E_BETROUND1   (0)
#define GAME_E_REPLACECARD (1)
#define GAME_E_BETROUND2   (2)
#define GAME_E_END         (3)

// Состояние игроков
#define PLST_WAIT            (0)
#define PLST_RAISE           (1)
#define PLST_PASS            (2)
#define PLST_CALL            (3)

#define PL_START_GAME        (1)
#define PL_RESUME_GAME       (0)

#define DID                  (Content::Dialog::all_poker)
#define STR_DLGREPLY         (41)
#define STR_CARDS            (0)
#define STR_COMBO            (1)
#define STR_BANK             (2)
#define STR_BET              (3)
#define STR_MBET             (4)
#define STR_FOLD             (5)
#define STR_RAISE            (6)
#define STR_WAIT             (7)
#define STR_CALL             (8)
#define STR_PL               (9)
#define STR_WINCOMBO         (10)
#define STR_WINERS           (11)
#define STR_YOUWIN           (12)
#define STR_WINPLNUM         (13)
#define STR_CARD_SPADES      (14)
#define STR_CARD_HEARTS      (15)
#define STR_CARD_DIAMONDS    (16)
#define STR_CARD_CLUBS       (17)
#define STR_CARD_2           (18)
#define STR_CARD_3           (19)
#define STR_CARD_4           (20)
#define STR_CARD_5           (21)
#define STR_CARD_6           (22)
#define STR_CARD_7           (23)
#define STR_CARD_8           (24)
#define STR_CARD_9           (25)
#define STR_CARD_10          (26)
#define STR_CARD_JACK        (27)
#define STR_CARD_LADY        (28)
#define STR_CARD_KING        (29)
#define STR_CARD_ACE         (30)
#define STR_COMBO_HIGHCARD   (31)
#define STR_COMBO_ONEPAIR    (32)
#define STR_COMBO_TWOPAIR    (33)
#define STR_COMBO_SET        (34)
#define STR_COMBO_STRAIGHT   (35)
#define STR_COMBO_FLUSH      (36)
#define STR_COMBO_FULLHOUSE  (37)
#define STR_COMBO_FOAK       (38)
#define STR_COMBO_STRFLUSH   (39)
#define STR_COMBO_ROYALFLUSH (40)
#define STR_ACCEPT           (42)
#define STR_CARDS_PL         (45)
#define STR_COMBO_PL         (46)
#define STR_FRAUD_ON         (49)
#define STR_FRAUD_OFF        (50)
#define STR_CARD_IN_SLEEVE   (51)
#define STR_SELECT           (52)
#define STR_UNSELECT         (53)
#define STR_MANYWINS_ON      (54)
#define STR_MANYWINS_OFF     (55)

#define D_MANYWINS           (19)

int8 GetBit(int64 digit, uint8 bnum)
{
    return (digit >> (bnum - 1)) & 1;
}

uint64 SetBit(uint64 digit, uint8 bnum, bool value)
{
    if (value) {
        digit |= (1 << (bnum - 1));
    }
    else {
        digit &= ~(1 << (bnum - 1));
    }
    return digit;
}

uint8 SetBit5(uint8 digit, uint8 bnum, bool value)
{
    if (value) {
        digit |= (1 << (bnum - 1));
    }
    else {
        digit &= ~(1 << (bnum - 1));
    }
    return digit;
}

uint8 GetSuit(uint8 CNum)
{
    // 0 - пики (Spades)
    // 1 - чирвы  (Hearts)
    // 2 - бубны  (Diamonds)
    // 3 - крести  (Clubs)
    if (CNum <= 13) {
        return CARD_SPADES;
    }
    else {
        if (CNum <= 26) {
            return CARD_HEARTS;
        }
        else {
            if (CNum <= 39) {
                return CARD_DIAMONDS;
            }
            else {
                return CARD_CLUBS;
            }
        }
    }
}

uint8 GetRank(uint8 CNum)
{
    // 0-8 - 2-10
    // 9 - валет
    // 10 - дама
    // 11 - король
    // 12 - туз
    return (CNum - 1) % 13;
}

string GetStrCard(uint8 num)
{
    uint8 i, m;
    string Suit, Rank;
    i = GetSuit(num);
    m = GetRank(num);
    switch (i) {
    case CARD_SPADES:
        Suit = "@msg dlg " + DLGSTR(DID, STR_CARD_SPADES) + "@";
        break;
    case CARD_HEARTS:
        Suit = "@msg dlg " + DLGSTR(DID, STR_CARD_HEARTS) + "@";
        break;
    case CARD_DIAMONDS:
        Suit = "@msg dlg " + DLGSTR(DID, STR_CARD_DIAMONDS) + "@";
        break;
    case CARD_CLUBS:
        Suit = "@msg dlg " + DLGSTR(DID, STR_CARD_CLUBS) + "@";
        break;
    default:
        Suit = "error";
        break;
    }
    switch (m) {
    case CARD_2:
        Rank = "@msg dlg " + DLGSTR(DID, STR_CARD_2) + "@";
        break;
    case CARD_3:
        Rank = "@msg dlg " + DLGSTR(DID, STR_CARD_3) + "@";
        break;
    case CARD_4:
        Rank = "@msg dlg " + DLGSTR(DID, STR_CARD_4) + "@";
        break;
    case CARD_5:
        Rank = "@msg dlg " + DLGSTR(DID, STR_CARD_5) + "@";
        break;
    case CARD_6:
        Rank = "@msg dlg " + DLGSTR(DID, STR_CARD_6) + "@";
        break;
    case CARD_7:
        Rank = "@msg dlg " + DLGSTR(DID, STR_CARD_7) + "@";
        break;
    case CARD_8:
        Rank = "@msg dlg " + DLGSTR(DID, STR_CARD_8) + "@";
        break;
    case CARD_9:
        Rank = "@msg dlg " + DLGSTR(DID, STR_CARD_9) + "@";
        break;
    case CARD_10:
        Rank = "@msg dlg " + DLGSTR(DID, STR_CARD_10) + "@";
        break;
    case CARD_JACK:
        Rank = "@msg dlg " + DLGSTR(DID, STR_CARD_JACK) + "@";
        break;
    case CARD_LADY:
        Rank = "@msg dlg " + DLGSTR(DID, STR_CARD_LADY) + "@";
        break;
    case CARD_KING:
        Rank = "@msg dlg " + DLGSTR(DID, STR_CARD_KING) + "@";
        break;
    case CARD_ACE:
        Rank = "@msg dlg " + DLGSTR(DID, STR_CARD_ACE) + "@";
        break;
    default:
        Rank = "error" + m;
        break;
    }
    return Rank + " " + Suit;
}

uint8 GetCombo(uint8 plNum, uint8[] GC)
{
    // PlNum - номер игрока (0 - живой игрок)
    // uint8 plNum=1;
    // uint8[] GC={0,0,0,0,0,9,10,11,12,13};// ДЛЯ ОТЛАДКИ СКРИПТА	| флаш рояль
    // uint8[] GC={0,0,0,0,0,8,9,10,11,12};// ДЛЯ ОТЛАДКИ СКРИПТА	| стрейт флаш
    // uint8[] GC={1,14,27,40,5,1,14,27,40,5};// ДЛЯ ОТЛАДКИ СКРИПТА	| каре
    // uint8[] GC={0,0,0,0,0,1,14,27,2,15};// ДЛЯ ОТЛАДКИ СКРИПТА	| фул хаус
    // uint8[] GC={0,0,0,0,0,1,2,3,4,6};// ДЛЯ ОТЛАДКИ СКРИПТА		| флаш
    // uint8[] GC={0,0,0,0,0,1,15,3,4,5};// ДЛЯ ОТЛАДКИ СКРИПТА	| стрейт
    // uint8[] GC={0,0,0,0,0,1,14,27,4,5};// ДЛЯ ОТЛАДКИ СКРИПТА	| сет
    // uint8[] GC={0,0,0,0,0,1,14,3,16,5};// ДЛЯ ОТЛАДКИ СКРИПТА	| 2 пары
    // uint8[] GC={0,0,0,0,0,1,14,3,4,5};// ДЛЯ ОТЛАДКИ СКРИПТА	| пара
    // uint8[] GC={0,0,0,0,0,1,15,3,4,6};// ДЛЯ ОТЛАДКИ СКРИПТА	| ничего
    uint8 HC = 0;
    uint8 res = 0;
    bool comboStreight = true; // Считаем что у нас стрейт, пока не подтваердится обратное.
    bool comboFlush = true;    // Аналогично для флаша
    bool comboFoak = false;    // каре
    for (uint8 i = plNum * CARD_COUNT; i < plNum * CARD_COUNT + CARD_COUNT; i++) {
        if (GetRank(GC[i]) > HC) {
            HC = GetRank(GC[i]);
        }
    }
    // /////ПРОВЕРКА НА СТРЕЙТ///////////////
    if (HC >= CARD_6) // Если ранг высшей карты меньше 6ти, значит стрейта нет
    {
        uint8 cardStr = 0;
        for (uint8 i = 0; i < CARD_COUNT; i++) {
            for (uint8 m = plNum * CARD_COUNT; m < plNum * CARD_COUNT + CARD_COUNT; m++) {
                if (GetRank(GC[m]) == HC - i) {
                    cardStr++;
                    break;
                }
            }
        }
        if (cardStr != 5) {
            comboStreight = false;
        }
    }
    else {
        comboStreight = false;
    }
    // ///////////*ПРОВЕРКА НА СТРЕЙТ////////////
    // ////////////ПРОВЕРКА НА ФЛАШ//////////////
    for (uint8 i = plNum * CARD_COUNT; i < plNum * CARD_COUNT + CARD_COUNT - 1; i++) {
        if (GetSuit(GC[i]) != GetSuit(GC[i + 1])) {
            comboFlush = false;
            break;
        }
    }
    // ///////////*ПРОВЕРКА НА ФЛАШ//////////////
    // ВЫВОД РЕЗУЛЬТАТОВ В СЛУЧАЕ КОРОЛЕВСКОГО ФЛАША, СТРЕЙТ ФЛАША, ПРОСТО ФЛАША И ПРОСТО СТРЕЙТА
    if (comboStreight) {
        if (comboFlush) {
            if (HC == CARD_ACE) {
                return CARD_COMBO_ROYALFLUSH;
            }
            else {
                return HC * 10 + CARD_COMBO_STRFLUSH;
            }
        }
        else {
            return HC * 10 + CARD_COMBO_STRAIGHT;
        }
    }
    else {
        if (comboFlush) {
            return HC * 10 + CARD_COMBO_FLUSH;
        }
    }
    // *ВЫВОД РЕЗУЛЬТАТОВ В СЛУЧАЕ КОРОЛЕВСКОГО ФЛАША, СТРЕЙТ ФЛАША, ПРОСТО ФЛАША И ПРОСТО СТРЕЙТА
    // ////////////ПРОВЕРКА НА ПАРУ,2 ПАРЫ, СЕТ, КАРЕ, ФУЛ///
    uint8[] cardCount = {1, 1};
    int8[] cardRank = {-1, -1};
    for (uint8 i = plNum * CARD_COUNT; i < plNum * CARD_COUNT + CARD_COUNT - 1; i++) {
        if ((cardRank[0] == int(GetRank(GC[i]))) or (cardRank[1] == int(GetRank(GC[i])))) {
            continue;
        }
        for (uint8 m = i + 1; m < plNum * CARD_COUNT + CARD_COUNT; m++) {
            if (GetRank(GC[i]) == GetRank(GC[m])) {
                if (cardRank[0] == -1) {
                    cardRank[0] = GetRank(GC[i]);
                }
                if (cardRank[0] == int(GetRank(GC[i]))) {
                    if (cardCount[0] < 3) {
                        cardCount[0] = cardCount[0] + 1;
                    }
                    else {
                        comboFoak = true;
                        break;
                    }
                }
                else {
                    if (cardRank[1] == -1) {
                        cardRank[1] = GetRank(GC[i]);
                    }
                    cardCount[1] = cardCount[1] + 1;
                }
            }
        }
    }
    if (comboFoak) {
        return cardRank[0] * 10 + CARD_COMBO_FOAK;
    }
    else {
        if (((cardCount[0] == 3) and (cardCount[1] == 2)) or ((cardCount[0] == 2) and (cardCount[1] == 3))) {
            if (cardCount[0] == 3) {
                return cardRank[0] * 10 + CARD_COMBO_FULLHOUSE;
            }
            else {
                return cardRank[1] * 10 + CARD_COMBO_FULLHOUSE;
            }
        }
        else {
            if (cardCount[0] == 3) {
                return cardRank[0] * 10 + CARD_COMBO_SET;
            }
            else {
                if ((cardCount[0] == 2) and (cardCount[1] == 2)) {
                    if (cardRank[0] > cardRank[1]) {
                        return cardRank[0] * 10 + CARD_COMBO_TWOPAIR;
                    }
                    else {
                        return cardRank[1] * 10 + CARD_COMBO_TWOPAIR;
                    }
                }
                else {
                    if (cardCount[0] == 2) {
                        return cardRank[0] * 10 + CARD_COMBO_ONEPAIR;
                    }
                    else {
                        return HC * 10; // Комбинаций нет, возвращаем только старшую карту
                    }
                }
            }
        }
    }
    // ///////////*ПРОВЕРКА НА ПАРУ,2 ПАРЫ, СЕТ, КАРЕ, ФУЛ///
}

uint8 GetHighCard(uint8 plNum, uint8[] GC)
{
    uint8 HC = 0;
    for (uint8 i = plNum * CARD_COUNT; i < plNum * CARD_COUNT + CARD_COUNT; i++) {
        if (GetRank(GC[i]) > HC) {
            HC = GetRank(GC[i]);
        }
    }
    return HC;
}

string GetStrCombo(uint8 combo)
{
    // GetCombo выдает комбинацию и ее ранг, надо получить номер комбинации:
    int num = combo % 10;
    string res;
    switch (num) {
    case CARD_COMBO_HIGHCARD:
        res = "@msg dlg " + DLGSTR(DID, STR_COMBO_HIGHCARD) + "@";
        break;
    case CARD_COMBO_ONEPAIR:
        res = "@msg dlg " + DLGSTR(DID, STR_COMBO_ONEPAIR) + "@";
        break;
    case CARD_COMBO_TWOPAIR:
        res = "@msg dlg " + DLGSTR(DID, STR_COMBO_TWOPAIR) + "@";
        break;
    case CARD_COMBO_SET:
        res = "@msg dlg " + DLGSTR(DID, STR_COMBO_SET) + "@";
        break;
    case CARD_COMBO_STRAIGHT:
        res = "@msg dlg " + DLGSTR(DID, STR_COMBO_STRAIGHT) + "@";
        break;
    case CARD_COMBO_FLUSH:
        res = "@msg dlg " + DLGSTR(DID, STR_COMBO_FLUSH) + "@";
        break;
    case CARD_COMBO_FULLHOUSE:
        res = "@msg dlg " + DLGSTR(DID, STR_COMBO_FULLHOUSE) + "@";
        break;
    case CARD_COMBO_FOAK:
        res = "@msg dlg " + DLGSTR(DID, STR_COMBO_FOAK) + "@";
        break;
    case CARD_COMBO_STRFLUSH:
        res = "@msg dlg " + DLGSTR(DID, STR_COMBO_STRFLUSH) + "@";
        break;
    case CARD_COMBO_ROYALFLUSH:
        res = "@msg dlg " + DLGSTR(DID, STR_COMBO_ROYALFLUSH) + "@";
        break;
    default:
        res = "error";
        break;
    }
    return res;
}

void PrintCards(Critter master, Critter pokerMan, uint8 pl) // Вывод на экран игровой информации (карты игрока, комбинация игрока, ставки)
{
    if (valid(master)) {
        // GetNpcBet(master);
        InGamePl[pokerMan.PokerNumOfNpc] = master.Id;
    }
    // _SaveAD(slave,false);
    if (GameStage[pokerMan.PokerNumOfNpc] != GAME_E_END) {
        // Map map=master.GetMap();
        DlgTxt[pokerMan.PokerNumOfNpc] = "";
        DlgTxtNet[pokerMan.PokerNumOfNpc] = "";
        DlgTxt2[pokerMan.PokerNumOfNpc] = "";
        if (pl == 0) {
            DialStrCards = "@msg dlg " + DLGSTR(DID, STR_CARDS) + "@\n";
            DialStrCardsNet = "@msg dlg " + DLGSTR(DID, STR_CARDS) + "@\n";
            DialStrCombo = "@msg dlg " + DLGSTR(DID, STR_COMBO) + "@ ";
        }
        else {
            DialStrCards = "@msg dlg " + DLGSTR(DID, STR_CARDS_PL) + "@\n";
            DialStrCardsNet = "@msg dlg " + DLGSTR(DID, STR_CARDS_PL) + "@\n";
            DialStrCombo = "@msg dlg " + DLGSTR(DID, STR_COMBO_PL) + "@ ";
        }

        for (uint8 i = 0; i < CARD_COUNT; i++) {
            // map.SetText(master.HexX+(i),master.HexY+(i),COLOR_RED,GetStrCard(GameCards[pokerMan.ParamBase[ST_PokerNumOfNpc]][i]));
            DialStrCards += "\t" + (i + 1) + ". " + GetStrCard(GameCards[pokerMan.PokerNumOfNpc][(pl * CARD_COUNT) + i]);
            DialStrCardsNet += GetStrCard(GameCards[pokerMan.PokerNumOfNpc][(pl * CARD_COUNT) + i]);
            if (i != CARD_COUNT - 1) {
                DialStrCardsNet += " ";
            }
            if ((i % 2 == 1) or (i == CARD_COUNT - 1)) {
                DialStrCards += "\n";
            }
        }
        DialStrCombo += GetStrCombo(GetCombo(pl, GameCards[pokerMan.PokerNumOfNpc]));
        // master.Say(SAY_DIALOG,DialStrCards+DialStrCombo);
        // map.SetText(master.HexX,master.HexY,COLOR_GREEN,dialStr);
        DlgTxt[pokerMan.PokerNumOfNpc] += DialStrCards + " " + DialStrCombo + "\n" + DialStrBank + Bank[pokerMan.PokerNumOfNpc] + " " + DialStrBet +
                                          Bet[pokerMan.PokerNumOfNpc] + " " + DialStrMineBet + PlBet[pokerMan.PokerNumOfNpc][0];
        PlayerCardsInDial[pokerMan.PokerNumOfNpc] = true;
        DlgTxtNet[pokerMan.PokerNumOfNpc] += DialStrCardsNet + " " + DialStrCombo + " " + DialStrBank + Bank[pokerMan.PokerNumOfNpc] + " " + DialStrBet +
                                             Bet[pokerMan.PokerNumOfNpc] + " " + DialStrMineBet + PlBet[pokerMan.PokerNumOfNpc][0];
        if (valid(master)) {
            master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + DialStrCardsNet);
            master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + DialStrCombo);
            /*		for(uint8 m=1;m<PLAYERS_COUNT;m++)
                            {
                                    switch(PlState[pokerMan.ParamBase[ST_PokerNumOfNpc]][m])
                                    {
                                            case PLST_WAIT:
                                                    master.SayMsg(SAY_NETMSG,TextPackName::Dialogs,DLGSTR(DID,STR_DLGREPLY),"$gametext"+DialStrPl+m+" "+DialStrWait);
                                                    break;
                                            case PLST_REISE:
                                                    master.SayMsg(SAY_NETMSG,TextPackName::Dialogs,DLGSTR(DID,STR_DLGREPLY),"$gametext"+DialStrPl+m+" "+DialStrRaise);
                                                    break;
                                            case PLST_PASS:
                                                    master.SayMsg(SAY_NETMSG,TextPackName::Dialogs,DLGSTR(DID,STR_DLGREPLY),"$gametext"+DialStrPl+m+" "+DialStrFold);
                                                    break;
                                            case PLST_CALL:
                                                    master.SayMsg(SAY_NETMSG,TextPackName::Dialogs,DLGSTR(DID,STR_DLGREPLY),"$gametext"+DialStrPl+m+" "+DialStrCall);
                                                    break;
                                    }
                            }*/
            master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + DialStrBank + Bank[pokerMan.PokerNumOfNpc]);
            master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + DialStrBet + Bet[pokerMan.PokerNumOfNpc]);
            master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + DialStrMineBet + PlBet[pokerMan.PokerNumOfNpc][0]);
        }
    }
}

void PrintFraud2Text(Critter master, Critter pokerMan)
{
    if (CardInSleeve[pokerMan.PokerNumOfNpc] == 0) {
        do {
            CardInSleeve[pokerMan.PokerNumOfNpc] = Game.Random(1, 52);
        } while (GetBit(Koloda[pokerMan.PokerNumOfNpc], CardInSleeve[pokerMan.PokerNumOfNpc]) != 1);
    }
    Koloda[pokerMan.PokerNumOfNpc] = SetBit(Koloda[pokerMan.PokerNumOfNpc], CardInSleeve[pokerMan.PokerNumOfNpc], false);

    PrintCards(master, pokerMan, 0);
    DlgTxt[pokerMan.PokerNumOfNpc] =
        "@msg dlg " + DLGSTR(DID, STR_CARD_IN_SLEEVE) + "@ " + GetStrCard(CardInSleeve[pokerMan.PokerNumOfNpc]) + "\n" + DlgTxt[pokerMan.PokerNumOfNpc];
    DL("\n<Poker> PrintFraud2Text: " + DlgTxt[pokerMan.PokerNumOfNpc]);
}

bool ChWinFold(Critter pokerMan)
{
    bool winFold = true;

    for (uint8 i = 1; i < PLAYERS_COUNT; i++) {
        if (PlState[pokerMan.PokerNumOfNpc][i] != PLST_PASS) {
            winFold = false;
        }
    }
    if (winFold) // Все противники спасовали
    {
        return true;
    }
    else {
        return false;
    }
}

void NpcReplaceCards(Critter pokerMan) // Замена карт у противников игрока
{
    // royal flush - ничего не менять
    // straight flush - ничего не менять
    // four of a kind - ничего не менять
    // full house - 90% ничего не менять 10% менять пару
    // flush - если до straight flush не хватает одной карты, то с 20% вероятностью меняем карту.
    // straight - если 4 карты одной масти, то 5% обмена последней
    // three of a kind - обмен оставшихся 2ух карт
    // two pairs - 90% обмен последней карты, 10% обмен трех карт
    // one pair - если номинал пары ниже 6, то 90% обмен оставшихся карт, 10% обмен всех карт, кроме высшей
    // high card - 70% обмен карт кроме наивысшего ранга, 30% обмен случайных карт
    // int8[] tpCard={4,-1,-1};
    // int8 tpPair=-1;
    // uint8[] cSuits={0,0,0,0};
    // uint8[] sortedStreight={0,0,0,0,0};
    // int8 strfl1Card=-1;
    // uint8 min1Straight=13;
    // int8 min2Straight=-1;
    // uint8 iStraight=0;
    // bool chStraight=false;
    for (uint8 i = 1; i < PLAYERS_COUNT; i++) {
        uint8 p = GetCombo(i, GameCards[pokerMan.PokerNumOfNpc]);
        uint8 hc = p / 10;
        p = p % 10;
        switch (p) {
        case CARD_COMBO_HIGHCARD: // 70% обмен карт кроме наивысшего ранга, 30% обмен случайных карт (перед этим, проверка на "почти флаш" и "почти стрейт")
            HighCardReplace(hc, i, pokerMan);
            break;
        case CARD_COMBO_ONEPAIR: // если номинал пары ниже 6, то 90% обмен оставшихся карт, 10% обмен всех карт, кроме высшей
            OnePairReplace(hc, i, pokerMan);
            break;
        case CARD_COMBO_TWOPAIR: // 90% обмен последней карты, 10% обмен трех карт
            TwoPairReplace(i, pokerMan);
            break;
        case CARD_COMBO_SET: // обмен оставшихся 2ух карт
            SetReplace(hc, i, pokerMan);
            break;
        case CARD_COMBO_STRAIGHT: // если 4 карты одной масти, то 5% обмена последней
            StraightReplace(i, pokerMan);
            break;
        case CARD_COMBO_FLUSH: // если до straight flush не хватает одной карты, то с 5% вероятностью меняем карту.
            FlushReplace(i, pokerMan);
            break;

        case CARD_COMBO_FULLHOUSE:
            break;
        case CARD_COMBO_FOAK:
            break;
        case CARD_COMBO_STRFLUSH:
            break;
        case CARD_COMBO_ROYALFLUSH:
            break;
        default:
            Game.Log("Error");
            break;
        }
    }
}

void HighCardReplace(uint8 hc, uint8 i, Critter pokerMan)
{
    uint8[] cSuits = {0, 0, 0, 0};
    int8 strfl1Card = -1;
    uint8 min1Straight = 13;
    int8 min2Straight = -1;
    uint8[] sortedStreight = {0, 0, 0, 0, 0};
    uint8 iStraight = 0;
    bool chStraight = false;
    for (uint8 c = 0; c < CARD_COUNT; c++) // Проверка на "почти флаш"
    {
        cSuits[GetSuit(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c])]++;
    }
    for (uint8 c = 0; c < 4; c++) {
        if (cSuits[c] == 4) {
            strfl1Card = c;
            break;
        }
    }
    if (strfl1Card != -1) {
        for (uint8 c = 1; c <= CARD_COUNT; c++) {
            if (not(int(GetSuit(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c - 1])) == strfl1Card)) {
                ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], c, true);
            }
        }
    }
    else // Проверка на "почти стрейт"
    {
        for (uint8 c = 0; c < CARD_COUNT; c++) {
            for (uint8 t = 0; t < CARD_COUNT; t++) {
                if ((GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + t]) < min1Straight) and
                    (int(GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + t])) > min2Straight)) {
                    min1Straight = GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c]);
                }
            }
            sortedStreight[c] = min1Straight;
            min2Straight = sortedStreight[c];
            min1Straight = 13;
        }
        for (uint8 c = 0; c < CARD_COUNT - 1; c++) {
            if (GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c]) == GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c + 1]) - 1) {
                iStraight++;
            }
        }
        if (iStraight == 3) // Если 4 карты идут по порядку, значит, это почти стрейт
        {
            if (GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT]) != GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 1]) - 1) {
                ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], 1, true);
            }
            else {
                ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], 5, true);
            }
            chStraight = true;
        }
        else // В противном случае требуются дополнительные проверки
        {
            if (iStraight > 1) // До стрейта далеко, если подряд идут только 2 карты (или таковых вообще нет).
            {
                if ((GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT]) == GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 1]) - 1) and
                    (GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 1]) == GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 2]) - 1)) {
                    if (GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 2]) == GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 4]) - 2) {
                        ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], 4, true);
                        chStraight = true;
                    }
                }
                else {
                    if ((GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 2]) ==
                         GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 3]) - 1) and
                        (GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 3]) ==
                         GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 4]) - 1)) {
                        if (GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT]) == GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 2]) - 2) {
                            ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], 2, true);
                            chStraight = true;
                        }
                    }
                    else {
                        if ((GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT]) ==
                             GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 1]) - 1) and
                            (GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 3]) ==
                             GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 4]) - 1)) {
                            if (GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 1]) ==
                                GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 3]) - 2) {
                                ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], 3, true);
                                chStraight = true;
                            }
                        }
                    }
                }
            }
        }
        if (not(chStraight)) // Проверка на "почти стрейт"
        {
            if (Game.Random(1, 10) <= 7) // обмен карт кроме наивысшего ранга
            {
                for (uint8 c = 1; c <= CARD_COUNT; c++) {
                    if (not(GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c - 1]) == hc)) {
                        ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], c, true);
                    }
                }
            }
            else // обмен случайных карт
            {
                for (uint8 c = 1; c <= CARD_COUNT; c++) {
                    if (Game.Random(0, 1) == 1) {
                        ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], c, true);
                    }
                }
            }
        }
    }
}

void OnePairReplace(uint8 hc, uint8 i, Critter pokerMan)
{
    if (hc < CARD_6) // если номинал пары ниже 6
    {
        if (Game.Random(1, 10) <= 9) // обмен оставшихся карт
        {
            for (uint8 c = 1; c <= CARD_COUNT; c++) {
                if (GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c - 1]) != hc) {
                    ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], c, true);
                }
            }
        }
        else // обмен всех карт, кроме высшей
        {
            uint8 highC = GetHighCard(i, GameCards[pokerMan.PokerNumOfNpc]);
            for (uint8 c = 1; c <= CARD_COUNT; c++) {
                if (not(GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c - 1]) == highC)) {
                    ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], c, true);
                }
            }
        }
    }
}

void TwoPairReplace(uint8 i, Critter pokerMan)
{
    int8[] tpCard = {4, -1, -1};
    int8 tpPair = -1;
    for (uint8 c = 0; c < CARD_COUNT - 1; c++) {
        bool notPair = true;
        for (uint8 t = c + 1; t < CARD_COUNT; t++) {
            if (GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c]) == GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + t])) {
                notPair = false;
                break;
            }
            if (notPair) {
                tpCard[0] = c;
            }
        }
    }
    for (uint8 c = 0; c < CARD_COUNT; c++) {
        if (GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c]) != GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + tpCard[0]])) {
            if (tpPair == -1) {
                tpPair = GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c]);
            }
            else {
                if (int(GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c])) < tpPair) {
                    tpPair = GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c]);
                }
            }
        }
    }
    for (uint8 c = 0; c < CARD_COUNT; c++) {
        if (int(GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c])) == tpPair) {
            if (tpCard[1] == -1) {
                tpCard[1] = c;
            }
            else {
                tpCard[2] = c;
            }
        }
    }
    if (Game.Random(1, 10) <= 9) // обмен последней карты
    {
        ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], tpCard[0], true);
    }
    else // обмен трех карт
    {
        ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], tpCard[0], true);
        ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], tpCard[1], true);
        ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], tpCard[2], true);
    }
}

void SetReplace(uint8 hc, uint8 i, Critter pokerMan)
{
    for (uint8 c = 1; c <= CARD_COUNT; c++) {
        if (not(GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c - 1]) == hc)) {
            ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], c, true);
        }
    }
}

void StraightReplace(uint8 i, Critter pokerMan)
{
    uint8[] cSuits = {0, 0, 0, 0};
    int8 strfl1Card = -1;
    for (uint8 c = 0; c < CARD_COUNT; c++) {
        cSuits[GetSuit(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c])]++;
    }
    for (uint8 c = 0; c < 4; c++) {
        if (cSuits[c] == 4) {
            strfl1Card = c;
            break;
        }
    }
    if (strfl1Card != -1) {
        if (Game.Random(1, 20) == 1) {
            for (uint8 c = 1; c <= CARD_COUNT; c++) {
                if (not(int(GetSuit(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c - 1])) == strfl1Card)) {
                    ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], c, true);
                }
            }
        }
    }
}

void FlushReplace(uint8 i, Critter pokerMan)
{
    uint8 min1Straight = 13;
    int8 min2Straight = -1;
    uint8[] sortedStreight = {0, 0, 0, 0, 0};
    uint8 iStraight = 0;
    for (uint8 c = 0; c < CARD_COUNT; c++) {
        for (uint8 t = 0; t < CARD_COUNT; t++) {
            if ((GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + t]) < min1Straight) and
                (int(GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + t])) > min2Straight)) {
                min1Straight = GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c]);
            }
        }
        sortedStreight[c] = min1Straight;
        min2Straight = sortedStreight[c];
        min1Straight = 13;
    }
    for (uint8 c = 0; c < CARD_COUNT - 1; c++) {
        if (GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c]) == GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + c + 1]) - 1) {
            iStraight++;
        }
    }
    if (iStraight == 3) // Если 4 карты идут по порядку, значит, это почти стрейт
    {
        if (GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT]) != GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 1]) - 1) {
            ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], 1, true);
        }
        else {
            ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], 5, true);
        }
    }
    else // В противном случае требуются дополнительные проверки
    {
        if (iStraight > 1) // До стрейта далеко, если подряд идут только 2 карты (или таковых вообще нет).
        {
            if ((GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT]) == GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 1]) - 1) and
                (GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 1]) == GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 2]) - 1)) {
                if (GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 2]) == GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 4]) - 2) {
                    ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], 4, true);
                }
            }
            else {
                if ((GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 2]) == GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 3]) - 1) and
                    (GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 3]) == GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 4]) - 1)) {
                    if (GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT]) == GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 2]) - 2) {
                        ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], 2, true);
                    }
                }
                else {
                    if ((GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT]) == GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 1]) - 1) and
                        (GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 3]) ==
                         GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 4]) - 1)) {
                        if (GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 1]) ==
                            GetRank(GameCards[pokerMan.PokerNumOfNpc][i * CARD_COUNT + 3]) - 2) {
                            ReplCards[pokerMan.PokerNumOfNpc][i] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][i], 3, true);
                        }
                    }
                }
            }
        }
    }
}

void LoadSettings(uint npcRole, Critter pokerMan)
{
    uint SettNum = npcRole - NPC_ROLE_START_VALUE;
    if (SettNum >= PGamers.length()) {
        SettNum = 0;
    }
    if (PGamers.length() > 0) {
        MoneyForStartGame[pokerMan.PokerNumOfNpc] = PGamers[SettNum].MoneyForStartGame;
        MinBet[pokerMan.PokerNumOfNpc] = PGamers[SettNum].MinBet;
        Raise_1[pokerMan.PokerNumOfNpc] = PGamers[SettNum].Raise1;
        Raise_2[pokerMan.PokerNumOfNpc] = PGamers[SettNum].Raise2;
        Raise_3[pokerMan.PokerNumOfNpc] = PGamers[SettNum].Raise3;
        MaxBet[pokerMan.PokerNumOfNpc] = PGamers[SettNum].MaxBet;
        OnCheat1[pokerMan.PokerNumOfNpc] = PGamers[SettNum].OnCheat1;
        OnCheat2[pokerMan.PokerNumOfNpc] = PGamers[SettNum].OnCheat2;
        OnCheat3[pokerMan.PokerNumOfNpc] = PGamers[SettNum].OnCheat3;
        PMLevel[pokerMan.PokerNumOfNpc] = PGamers[SettNum].PMLevel;
        StopGameMoney[pokerMan.PokerNumOfNpc] = PGamers[SettNum].StopGameMoney;
        WaitForGame[pokerMan.PokerNumOfNpc] = PGamers[SettNum].WaitForGame;
    }
    else {
        Game.Log("\n\n<Poker> Error: Settings not found!");
    }

    DL("\n\n<Poker> Number of game settings: " + PGamers.length() + "\nSelected setting - " + SettNum + "\nNpcRole - " + npcRole + "\nMoneyForStartGame - " +
       MoneyForStartGame[pokerMan.PokerNumOfNpc] + "\nMinBet - " + MinBet[pokerMan.PokerNumOfNpc] + "\nMaxBet - " + MaxBet[pokerMan.PokerNumOfNpc] + "\n\n");
}
// //// FOS Server
// //Old script name: PokerGameList.fosh. Patched 01.10 21:52:48
// Author: Tab10id

//
// Dro-Poker
// Using in poker
//

// В этом файле хранятся настройки игры для различных НПЦ (минимальные/максимальные ставки и тп)
// Для того чтобы заставить нпц играть с теми или иными настойкам, необходимо указать ему соответствующее значение NpcRole
#define NPC_ROLE_START_VALUE (71600)

class PokerGamer
{
    uint MoneyForStartGame; // Деньги которые необходимо поставить для начала игры
    uint MinBet;            // Минимальная ставка
    uint MaxBet;            // Максимальная ставка
    uint Raise1;            // Стандартное повышение 1
    uint Raise2;            // Стандартное повышение 2
    uint Raise3;            // Стандартное повышение 3
    uint16 OnCheat1;        // Реакция на обнаружение жульничества типа 1
    uint16 OnCheat2;        // Реакция на обнаружение жульничества типа 2
    uint16 OnCheat3;        // Дополнительное поле
    uint8 PMLevel;          // Способность покермана заметить жульничество (от 1 до 10)
    uint StopGameMoney;     // Сумма, проигрывая которую покерман перестает играть с Дудом. Если 0, то ограничений нет.
    uint16 WaitForGame; // Количество игровых дней, которые необходимо подождать, чтобы покерман снова начал играть с Дудом, после того как он его обыграл на
                        // сумму StopGameMoney

    PokerGamer(uint moneyForStartGame, uint minBet, uint maxBet, uint raise1, uint raise2, uint raise3, uint16 onCheat1, uint16 onCheat2, uint16 onCheat3,
               uint8 pMLevel, uint stopGameMoney, uint16 waitForGame)
    {
        MoneyForStartGame = moneyForStartGame;
        MinBet = minBet;
        MaxBet = maxBet;
        Raise1 = raise1;
        Raise2 = raise2;
        Raise3 = raise3;
        OnCheat1 = onCheat1;
        OnCheat2 = onCheat2;
        OnCheat3 = onCheat3;
        PMLevel = pMLevel;
        StopGameMoney = stopGameMoney;
        WaitForGame = waitForGame;
    }
};
PokerGamer[] PGamers = {};

class Starter
{
    Starter()
    {
        InitPGemers();
    }
};
Starter aStarter = Starter();

void InitPGemers()
{
    PGamers.insertLast(PokerGamer(120, 20, 750, 20, 50, 100, 1, 0, 0, 1, 3000, 2));
    PGamers.insertLast(PokerGamer(130, 30, 850, 30, 60, 200, 1, 0, 0, 3, 6000, 3));
}

void RunCheatScript(uint16 funcNum, Critter player, Critter pokerMan)
{
    switch (funcNum) {
    case 1:
        _OnCheat1_npc1(player, pokerMan);
        break;
    default:
        _OnCheatDefault(player, pokerMan);
        break;
    }
}

void _OnCheat1_npc1(Critter player, Critter pokerMan)
{
    pokerMan.SayMsg(SAY_NORM_ON_HEAD, TextPackName::Dialogs, STR_CHEAT_1);
    NpcPlanes::AddAttackPlane(pokerMan, 0, player);
    InGame[pokerMan.PokerNumOfNpc] = false;
    auto pokerFraud = pokerMan.PokerFraud.clone();
    pokerFraud[player.Id] = Game.GetFullSecond() + (60 * 60 * 24 * 3);
    pokerMan.PokerFraud = pokerFraud;
}

void _OnCheatDefault(Critter player, Critter pokerMan)
{
    pokerMan.SayMsg(SAY_NORM_ON_HEAD, TextPackName::Dialogs, STR_CHEAT_DEFAULT);
    InGame[pokerMan.PokerNumOfNpc] = false;
    auto pokerFraud = pokerMan.PokerFraud.clone();
    pokerFraud[player.Id] = Game.GetFullSecond() + (60 * 60 * 24 * 1);
    pokerMan.PokerFraud = pokerFraud;
}

///@ Property Critter PrivateServer int  PokerWins
///@ Property Critter PrivateServer uint PokerNumOfNpc
///@ Property Critter PrivateServer ident=>uint PokerWincash
///@ Property Critter PrivateServer ident=>uint PokerFraud
///@ Property Critter PrivateServer ident=>uint PokerManywins
///@ Property Critter PrivateServer any[] PokerData

uint NumOfNpc = 0;

uint64[] Koloda = {};       // Колода, биты в числе указывают на наличие карты в калоде, всего используется 52 бита
uint8[][] GameCards = {{}}; // Карты непосредственно учавствующие в игре: 0-4 - карты игрока, 5-19 - карты противников
uint8[][] ReplCards = {{}}; // Карты для замены (5 бит указывают, заменять карту или нет), нулевой элемент в массиве - игрок
uint8[] Stroy = {};         // Порядок игроков во время ставок меняется от 0 до PLAYERS_COUNT-1
uint8[] BetEnd = {};        // Определяет окончание круга ставок.
uint[] Bank = {};           // Величина банка
uint[] Bet = {};            // Величина текущей ставки
uint8[] GameStage = {};     // Часть игры (раздача карт, ставки, обмен карт, второй круг ставок, вскрытие карт)
bool[] FirstGame = {};      // определяет первая ли игра идет
uint8[] MHod = {};          // Определяет очереднойсь ходов игроков (если MHod==0, значит очередь игрока.)
uint8[][] PlState = {{}};
uint[][] PlBet = {{}};
bool[] InGame = {};
bool[] PlayerCardsInDial = {};
ident[] InGamePl = {};
uint8[] WinKoef = {};
string[] DlgTxt = {};
string[] DlgTxtNet = {};
string[] DlgTxt2 = {};
any[][] GameData = {{}};
any[][] GameDataTemp = {{}};
uint[] MoneyForStartGame = {};
uint[] MinBet = {};
uint[] Raise_1 = {};
uint[] Raise_2 = {};
uint[] Raise_3 = {};
uint[] MaxBet = {};
uint8[] FraudMode = {};
uint16[] OnCheat1 = {};
uint16[] OnCheat2 = {};
uint16[] OnCheat3 = {};
uint8[] PMLevel = {};
uint8[] CardInSleeve = {};
uint8[] Fraud2Succ = {};
uint8[] VarRiseSucc = {};
uint16[] GameNum = {};
uint16[] ModChFr = {};
uint[] StartGameMoney = {};
uint[] StopGameMoney = {};
uint16[] WaitForGame = {};

bool[] App = {};

string DialStrCards = "@msg dlg " + DLGSTR(DID, STR_CARDS) + "@\n";    // Ваши карты:
string DialStrCardsNet = "@msg dlg " + DLGSTR(DID, STR_CARDS) + "@\n"; // Ваши карты:
string DialStrCombo = "@msg dlg " + DLGSTR(DID, STR_COMBO) + "@ ";     // у вас
string DialStrBank = "@msg dlg " + DLGSTR(DID, STR_BANK) + "@ ";       // В банке:
string DialStrBet = "@msg dlg " + DLGSTR(DID, STR_BET) + "@ ";         // Текущая ставка:
string DialStrMineBet = "@msg dlg " + DLGSTR(DID, STR_MBET) + "@ ";    // Ваша последняя ставка:
string DialStrFold = "@msg dlg " + DLGSTR(DID, STR_FOLD) + "@";        // спасовал
string DialStrRaise = "@msg dlg " + DLGSTR(DID, STR_RAISE) + "@";      // поднял ставку
string DialStrWait = "@msg dlg " + DLGSTR(DID, STR_WAIT) + "@";        // еще не делал ставку
string DialStrCall = "@msg dlg " + DLGSTR(DID, STR_CALL) + "@";        // ответил на ставку
string DialStrAccept = "@msg dlg " + DLGSTR(DID, STR_ACCEPT) + "@";    // принял ставку
string DialStrPl = "@msg dlg " + DLGSTR(DID, STR_PL) + "@ ";           // Игрок

void _PokermanInit(Critter pokerMan, bool firstTime)
{
    Koloda.grow(1);
    GameCards.grow(1);
    GameCards.last() = array<uint8>();
    GameCards[GameCards.length() - 1].grow(PLAYERS_COUNT * CARD_COUNT);
    ReplCards.grow(1);
    ReplCards.last() = array<uint8>();
    ReplCards[ReplCards.length() - 1].grow(PLAYERS_COUNT);
    PlState.grow(1);
    PlState.last() = array<uint8>();
    PlState[PlState.length() - 1].grow(PLAYERS_COUNT);
    PlBet.grow(1);
    PlBet.last() = array<uint>();
    PlBet[PlBet.length() - 1].grow(PLAYERS_COUNT);
    InGamePl.grow(1);
    GameData.grow(1);
    GameData.last() = array<any>();
    GameData[GameData.length() - 1].grow(GAMEVAR_COUNT);
    GameDataTemp.grow(1);
    GameDataTemp.last() = array<any>();
    GameDataTemp[GameDataTemp.length() - 1].grow(GAMEVAR_COUNT);
    MoneyForStartGame.grow(1);
    MinBet.grow(1);
    Raise_1.grow(1);
    Raise_2.grow(1);
    Raise_3.grow(1);
    MaxBet.grow(1);
    App.grow(1);
    PMLevel.grow(1);
    StartGameMoney.grow(1);
    StopGameMoney.grow(1);
    WaitForGame.grow(1);

    Stroy.insertLast(0);
    BetEnd.insertLast(0);
    Bank.insertLast(0);
    Bet.insertLast(0);
    GameStage.insertLast(0);
    FirstGame.insertLast(false);
    MHod.insertLast(0);
    InGame.insertLast(false);
    PlayerCardsInDial.insertLast(false);
    WinKoef.insertLast(100);
    DlgTxt.insertLast("");
    DlgTxtNet.insertLast("");
    DlgTxt2.insertLast("");
    FraudMode.insertLast(0);
    OnCheat1.insertLast(0);
    OnCheat2.insertLast(0);
    OnCheat3.insertLast(0);
    CardInSleeve.insertLast(0);
    Fraud2Succ.insertLast(0);
    VarRiseSucc.insertLast(0);
    GameNum.insertLast(0);
    ModChFr.insertLast(0);

    pokerMan.PokerNumOfNpc = NumOfNpc++;
    if (pokerMan.PokerData.length() > 0) {
        GameDataTemp[pokerMan.PokerNumOfNpc] = pokerMan.PokerData.clone();
        for (uint8 i = 0; i < GAMEVAR_COUNT; i++) {
            GameData[pokerMan.PokerNumOfNpc][i] = GameDataTemp[pokerMan.PokerNumOfNpc][i];
        }
        GetAData(pokerMan);
        InGame[pokerMan.PokerNumOfNpc] = true;
        PrintCards(null, pokerMan, 0);
    }
    LoadSettings(pokerMan.NpcRole, pokerMan);
    pokerMan.OnFinish.Subscribe(_SaveAD);

    DL("\n<Poker> npcId - " + pokerMan.Id + ", npcPokerNumOfNpc - " + pokerMan.PokerNumOfNpc + "\n");
}

void InitGame(Critter pokerMan, Critter master) // запуск игры
{
    auto pokerManywins = pokerMan.PokerManywins.clone();
    pokerManywins[master.Id] = Game.GetFullSecond();
    pokerMan.PokerManywins = pokerManywins;

    StartGameMoney[pokerMan.PokerNumOfNpc] = master.CountItem(Content::Item::bottle_caps);
    InGame[pokerMan.PokerNumOfNpc] = true;
    BetEnd[pokerMan.PokerNumOfNpc] = 0;
    WinKoef[pokerMan.PokerNumOfNpc] = 100;
    for (uint8 i = 0; i < (PLAYERS_COUNT * CARD_COUNT); i++) {
        GameCards[pokerMan.PokerNumOfNpc][i] = 0;
    }
    Bank[pokerMan.PokerNumOfNpc] = PLAYERS_COUNT * MinBet[pokerMan.PokerNumOfNpc]; // Кладем в банк минимальную ставку
    Bet[pokerMan.PokerNumOfNpc] = MinBet[pokerMan.PokerNumOfNpc];
    for (uint8 l = 0; l < PLAYERS_COUNT; l++) {
        ReplCards[pokerMan.PokerNumOfNpc][l] = 0;
        PlBet[pokerMan.PokerNumOfNpc][l] = MinBet[pokerMan.PokerNumOfNpc];
        PlState[pokerMan.PokerNumOfNpc][l] = PLST_WAIT;
    }
    GameStage[pokerMan.PokerNumOfNpc] = GAME_E_BETROUND1;
    Koloda[pokerMan.PokerNumOfNpc] = uint64(-1); // Все биты = 1
    uint8 m;
    for (uint8 i = 0; i < (PLAYERS_COUNT * CARD_COUNT); i++) // Раздача карт
    {
        do {
            m = Game.Random(1, 52);
        } while (GetBit(Koloda[pokerMan.PokerNumOfNpc], m) != 1);
        Koloda[pokerMan.PokerNumOfNpc] = SetBit(Koloda[pokerMan.PokerNumOfNpc], m, false);
        GameCards[pokerMan.PokerNumOfNpc][i] = m;
    }

    DL("\n<Poker>\nPlayer Cards:I " + GameCards[pokerMan.PokerNumOfNpc][0] + ";" + GameCards[pokerMan.PokerNumOfNpc][1] + ";" +
       GameCards[pokerMan.PokerNumOfNpc][2] + ";" + GameCards[pokerMan.PokerNumOfNpc][3] + ";" + GameCards[pokerMan.PokerNumOfNpc][4] + "\n" +
       GetStrCombo(GetCombo(0, GameCards[pokerMan.PokerNumOfNpc])) + "\n1:I " + GameCards[pokerMan.PokerNumOfNpc][5] + ";" +
       GameCards[pokerMan.PokerNumOfNpc][6] + ";" + GameCards[pokerMan.PokerNumOfNpc][7] + ";" + GameCards[pokerMan.PokerNumOfNpc][8] + ";" +
       GameCards[pokerMan.PokerNumOfNpc][9] + "\n" + GetStrCombo(GetCombo(1, GameCards[pokerMan.PokerNumOfNpc])) + "\n2:I " +
       GameCards[pokerMan.PokerNumOfNpc][10] + ";" + GameCards[pokerMan.PokerNumOfNpc][11] + ";" + GameCards[pokerMan.PokerNumOfNpc][12] + ";" +
       GameCards[pokerMan.PokerNumOfNpc][13] + ";" + GameCards[pokerMan.PokerNumOfNpc][14] + "\n" +
       GetStrCombo(GetCombo(2, GameCards[pokerMan.PokerNumOfNpc])) + "\n3:I " + GameCards[pokerMan.PokerNumOfNpc][15] + ";" +
       GameCards[pokerMan.PokerNumOfNpc][16] + ";" + GameCards[pokerMan.PokerNumOfNpc][17] + ";" + GameCards[pokerMan.PokerNumOfNpc][18] + ";" +
       GameCards[pokerMan.PokerNumOfNpc][19] + "\n" + GetStrCombo(GetCombo(3, GameCards[pokerMan.PokerNumOfNpc])));

    if (!FirstGame[pokerMan.PokerNumOfNpc]) // Порядок игроков (определяет порядок ставок)
    {
        Stroy[pokerMan.PokerNumOfNpc] = (Stroy[pokerMan.PokerNumOfNpc] + 1) % (PLAYERS_COUNT); // Если игра не первая, то порядок смещается на 1
        GameNum[pokerMan.PokerNumOfNpc]++;
    }
    else // если игра первая, то первый игрок выбирается случайно
    {
        Stroy[pokerMan.PokerNumOfNpc] = Game.Random(0, (PLAYERS_COUNT - 1));
        FirstGame[pokerMan.PokerNumOfNpc] = false;
        GameNum[pokerMan.PokerNumOfNpc] = 1;
        ModChFr[pokerMan.PokerNumOfNpc] = 0;
    }
    MHod[pokerMan.PokerNumOfNpc] = Stroy[pokerMan.PokerNumOfNpc];
    FraudMode[pokerMan.PokerNumOfNpc] = 0;
    CardInSleeve[pokerMan.PokerNumOfNpc] = 0;
    Fraud2Succ[pokerMan.PokerNumOfNpc] = 0;
    VarRiseSucc[pokerMan.PokerNumOfNpc] = 0;
}

void _SaveAD(Critter pokerMan)
{
    if (InGame[pokerMan.PokerNumOfNpc]) {
        SaveData(pokerMan);
        pokerMan.PokerData = GameData[pokerMan.PokerNumOfNpc];
    }
}

void SaveData(Critter pokerMan)
{
    uint k = 0;
    // Разделяем переменную uint64 на две переменные uint32 чтобы сохранить их в базе
    GameData[pokerMan.PokerNumOfNpc][k++] = Koloda[pokerMan.PokerNumOfNpc] >> 32;         // Первые 20 карт колоды
    GameData[pokerMan.PokerNumOfNpc][k++] = (Koloda[pokerMan.PokerNumOfNpc] << 32) >> 32; // Последние 32 карты колоды
    for (uint8 i = 0; i < PLAYERS_COUNT * CARD_COUNT; i++) {
        GameData[pokerMan.PokerNumOfNpc][k++] = GameCards[pokerMan.PokerNumOfNpc][i];
    }
    for (uint8 i = 0; i < PLAYERS_COUNT; i++) {
        GameData[pokerMan.PokerNumOfNpc][k++] = ReplCards[pokerMan.PokerNumOfNpc][i];
    }
    GameData[pokerMan.PokerNumOfNpc][k++] = Stroy[pokerMan.PokerNumOfNpc];
    GameData[pokerMan.PokerNumOfNpc][k++] = BetEnd[pokerMan.PokerNumOfNpc];
    GameData[pokerMan.PokerNumOfNpc][k++] = Bank[pokerMan.PokerNumOfNpc];
    GameData[pokerMan.PokerNumOfNpc][k++] = Bet[pokerMan.PokerNumOfNpc];
    GameData[pokerMan.PokerNumOfNpc][k++] = GameStage[pokerMan.PokerNumOfNpc];
    GameData[pokerMan.PokerNumOfNpc][k++] = MHod[pokerMan.PokerNumOfNpc];
    for (uint8 i = 0; i < PLAYERS_COUNT; i++) {
        GameData[pokerMan.PokerNumOfNpc][k++] = PlState[pokerMan.PokerNumOfNpc][i];
    }
    for (uint8 i = 0; i < PLAYERS_COUNT; i++) {
        GameData[pokerMan.PokerNumOfNpc][k++] = PlBet[pokerMan.PokerNumOfNpc][i];
    }
    GameData[pokerMan.PokerNumOfNpc][k++] = InGamePl[pokerMan.PokerNumOfNpc];
    GameData[pokerMan.PokerNumOfNpc][k++] = WinKoef[pokerMan.PokerNumOfNpc];
    GameData[pokerMan.PokerNumOfNpc][k++] = FraudMode[pokerMan.PokerNumOfNpc];
    GameData[pokerMan.PokerNumOfNpc][k++] = CardInSleeve[pokerMan.PokerNumOfNpc];
    GameData[pokerMan.PokerNumOfNpc][k++] = Fraud2Succ[pokerMan.PokerNumOfNpc];
    GameData[pokerMan.PokerNumOfNpc][k++] = GameNum[pokerMan.PokerNumOfNpc];
    GameData[pokerMan.PokerNumOfNpc][k++] = ModChFr[pokerMan.PokerNumOfNpc];
    GameData[pokerMan.PokerNumOfNpc][k] = StartGameMoney[pokerMan.PokerNumOfNpc];
}

void GetAData(Critter pokerMan)
{
    uint k = 0;
    uint64 temp;
    // "Склеиваем" 2 uint32 в один uint64
    Koloda[pokerMan.PokerNumOfNpc] = GameData[pokerMan.PokerNumOfNpc][k++]; // Последние 32 карты колоды
    temp = GameData[pokerMan.PokerNumOfNpc][k++];                           // чтобы не потерять информацию при сдвиге
    Koloda[pokerMan.PokerNumOfNpc] += temp << 32;                           // первые 20 карт колоды
    for (uint8 i = 0; i < PLAYERS_COUNT * CARD_COUNT; i++) {
        GameCards[pokerMan.PokerNumOfNpc][i] = GameData[pokerMan.PokerNumOfNpc][k++];
    }
    for (uint8 i = 0; i < PLAYERS_COUNT; i++) {
        ReplCards[pokerMan.PokerNumOfNpc][i] = GameData[pokerMan.PokerNumOfNpc][k++];
    }
    Stroy[pokerMan.PokerNumOfNpc] = GameData[pokerMan.PokerNumOfNpc][k++];
    BetEnd[pokerMan.PokerNumOfNpc] = GameData[pokerMan.PokerNumOfNpc][k++];
    Bank[pokerMan.PokerNumOfNpc] = GameData[pokerMan.PokerNumOfNpc][k++];
    Bet[pokerMan.PokerNumOfNpc] = GameData[pokerMan.PokerNumOfNpc][k++];
    GameStage[pokerMan.PokerNumOfNpc] = GameData[pokerMan.PokerNumOfNpc][k++];
    MHod[pokerMan.PokerNumOfNpc] = GameData[pokerMan.PokerNumOfNpc][k++];
    for (uint8 i = 0; i < PLAYERS_COUNT; i++) {
        PlState[pokerMan.PokerNumOfNpc][i] = GameData[pokerMan.PokerNumOfNpc][k++];
    }
    for (uint8 i = 0; i < PLAYERS_COUNT; i++) {
        PlBet[pokerMan.PokerNumOfNpc][i] = GameData[pokerMan.PokerNumOfNpc][k++];
    }
    InGamePl[pokerMan.PokerNumOfNpc] = GameData[pokerMan.PokerNumOfNpc][k++];
    WinKoef[pokerMan.PokerNumOfNpc] = GameData[pokerMan.PokerNumOfNpc][k++];
    FraudMode[pokerMan.PokerNumOfNpc] = GameData[pokerMan.PokerNumOfNpc][k++];
    CardInSleeve[pokerMan.PokerNumOfNpc] = GameData[pokerMan.PokerNumOfNpc][k++];
    Fraud2Succ[pokerMan.PokerNumOfNpc] = GameData[pokerMan.PokerNumOfNpc][k++];
    GameNum[pokerMan.PokerNumOfNpc] = GameData[pokerMan.PokerNumOfNpc][k++];
    ModChFr[pokerMan.PokerNumOfNpc] = GameData[pokerMan.PokerNumOfNpc][k++];
    StartGameMoney[pokerMan.PokerNumOfNpc] = GameData[pokerMan.PokerNumOfNpc][k];
}

void EraseData(Critter npc)
{
    npc.PokerData = array<any>();
}

void NpcAction(uint8 m, Critter master, Critter pokerMan)
{
    if (ChWinFold(pokerMan)) {
        EndGame(master, pokerMan);
        return;
    }

    while (PlState[pokerMan.PokerNumOfNpc][m] == PLST_PASS) {
        m++;
        BetEnd[pokerMan.PokerNumOfNpc]++;
        if (m == PLAYERS_COUNT) {
            return;
        }
    }
    int8[] modCh = {-20, 0, 10, 20, 35, 50, 60, 70, 80, 90};
    uint mB = Bet[pokerMan.PokerNumOfNpc] * (1000 / MaxBet[pokerMan.PokerNumOfNpc]);
    int8 chance;
    if (mB >= 100) {
        chance = 100 - ((mB) / 10 - 5);
    }
    else {
        chance = 95;
    }
    chance += modCh[GetCombo(m, GameCards[pokerMan.PokerNumOfNpc]) % 10];

    if ((ModChFr[pokerMan.PokerNumOfNpc] / GameNum[pokerMan.PokerNumOfNpc]) > 2) {
        chance += ModChFr[pokerMan.PokerNumOfNpc];
    }
    bool doBet = false;
    if (chance < 5) {
        chance = 5;
    }
    else {
        if (chance > 95) {
            chance = 95;
        }
    }

    if ((100 - Game.Random(0, 99)) <= chance) {
        doBet = true;
    }

    DlgTxt[pokerMan.PokerNumOfNpc] = DialStrPl + " №" + m + " ";
    PlayerCardsInDial[pokerMan.PokerNumOfNpc] = false;
    if (doBet) {
        if (Game.Random(0, 1) == 1) {
            Bank[pokerMan.PokerNumOfNpc] += Bet[pokerMan.PokerNumOfNpc] - PlBet[pokerMan.PokerNumOfNpc][m];
            PlState[pokerMan.PokerNumOfNpc][m] = PLST_CALL;
            if (Bet[pokerMan.PokerNumOfNpc] == PlBet[pokerMan.PokerNumOfNpc][m]) {
                master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + DlgTxt[pokerMan.PokerNumOfNpc] + DialStrCall);
                DlgTxt[pokerMan.PokerNumOfNpc] +=
                    DialStrAccept + "\n" + DialStrBank + Bank[pokerMan.PokerNumOfNpc] + "\n" + DialStrBet + Bet[pokerMan.PokerNumOfNpc];
            }
            else {
                master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + DlgTxt[pokerMan.PokerNumOfNpc] + DialStrCall);
                DlgTxt[pokerMan.PokerNumOfNpc] +=
                    DialStrCall + "\n" + DialStrBank + Bank[pokerMan.PokerNumOfNpc] + "\n" + DialStrBet + Bet[pokerMan.PokerNumOfNpc];
            }
            PlBet[pokerMan.PokerNumOfNpc][m] = Bet[pokerMan.PokerNumOfNpc];
        }
        else {
            if (((PlBet[pokerMan.PokerNumOfNpc][m] + Raise_1[pokerMan.PokerNumOfNpc]) > Bet[pokerMan.PokerNumOfNpc]) and
                ((PlBet[pokerMan.PokerNumOfNpc][m] + Raise_1[pokerMan.PokerNumOfNpc]) <= MaxBet[pokerMan.PokerNumOfNpc])) {
                Bank[pokerMan.PokerNumOfNpc] += Raise_1[pokerMan.PokerNumOfNpc];
                PlState[pokerMan.PokerNumOfNpc][m] = PLST_RAISE;
                Bet[pokerMan.PokerNumOfNpc] += (Bet[pokerMan.PokerNumOfNpc] - PlBet[pokerMan.PokerNumOfNpc][m]) + Raise_1[pokerMan.PokerNumOfNpc];
                PlBet[pokerMan.PokerNumOfNpc][m] = Bet[pokerMan.PokerNumOfNpc];
                master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + DlgTxt[pokerMan.PokerNumOfNpc] + DialStrRaise);
                DlgTxt[pokerMan.PokerNumOfNpc] +=
                    DialStrRaise + "\n" + DialStrBank + Bank[pokerMan.PokerNumOfNpc] + "\n" + DialStrBet + Bet[pokerMan.PokerNumOfNpc];
                BetEnd[pokerMan.PokerNumOfNpc] = 0;
            }
            else {
                if (((PlBet[pokerMan.PokerNumOfNpc][m] + Raise_2[pokerMan.PokerNumOfNpc]) > Bet[pokerMan.PokerNumOfNpc]) and
                    ((PlBet[pokerMan.PokerNumOfNpc][m] + Raise_2[pokerMan.PokerNumOfNpc]) <= MaxBet[pokerMan.PokerNumOfNpc])) {
                    Bank[pokerMan.PokerNumOfNpc] += Raise_2[pokerMan.PokerNumOfNpc];
                    PlState[pokerMan.PokerNumOfNpc][m] = PLST_RAISE;
                    Bet[pokerMan.PokerNumOfNpc] += (Bet[pokerMan.PokerNumOfNpc] - PlBet[pokerMan.PokerNumOfNpc][m]) + Raise_2[pokerMan.PokerNumOfNpc];
                    PlBet[pokerMan.PokerNumOfNpc][m] = Bet[pokerMan.PokerNumOfNpc];
                    master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + DlgTxt[pokerMan.PokerNumOfNpc] + DialStrRaise);
                    DlgTxt[pokerMan.PokerNumOfNpc] +=
                        DialStrRaise + "\n" + DialStrBank + Bank[pokerMan.PokerNumOfNpc] + "\n" + DialStrBet + Bet[pokerMan.PokerNumOfNpc];
                    BetEnd[pokerMan.PokerNumOfNpc] = 0;
                }
                else {
                    if (((PlBet[pokerMan.PokerNumOfNpc][m] + Raise_3[pokerMan.PokerNumOfNpc]) > Bet[pokerMan.PokerNumOfNpc]) and
                        ((PlBet[pokerMan.PokerNumOfNpc][m] + Raise_3[pokerMan.PokerNumOfNpc]) <= MaxBet[pokerMan.PokerNumOfNpc])) {
                        Bank[pokerMan.PokerNumOfNpc] += Raise_3[pokerMan.PokerNumOfNpc];
                        PlState[pokerMan.PokerNumOfNpc][m] = PLST_RAISE;
                        Bet[pokerMan.PokerNumOfNpc] += (Bet[pokerMan.PokerNumOfNpc] - PlBet[pokerMan.PokerNumOfNpc][m]) + Raise_3[pokerMan.PokerNumOfNpc];
                        PlBet[pokerMan.PokerNumOfNpc][m] = Bet[pokerMan.PokerNumOfNpc];
                        master.SayMsg(SAY_NETMSG,
                                      TextPackName::Dialogs,
                                      DLGSTR(DID, STR_DLGREPLY),
                                      "$gametext" + DlgTxt[pokerMan.PokerNumOfNpc] + DialStrRaise);
                        DlgTxt[pokerMan.PokerNumOfNpc] +=
                            DialStrRaise + "\n" + DialStrBank + Bank[pokerMan.PokerNumOfNpc] + "\n" + DialStrBet + Bet[pokerMan.PokerNumOfNpc];
                        BetEnd[pokerMan.PokerNumOfNpc] = 0;
                    }
                    else {
                        Bank[pokerMan.PokerNumOfNpc] += Bet[pokerMan.PokerNumOfNpc] - PlBet[pokerMan.PokerNumOfNpc][m];
                        PlState[pokerMan.PokerNumOfNpc][m] = PLST_CALL;
                        if (Bet[pokerMan.PokerNumOfNpc] == PlBet[pokerMan.PokerNumOfNpc][m]) {
                            master.SayMsg(SAY_NETMSG,
                                          TextPackName::Dialogs,
                                          DLGSTR(DID, STR_DLGREPLY),
                                          "$gametext" + DlgTxt[pokerMan.PokerNumOfNpc] + DialStrAccept);
                            DlgTxt[pokerMan.PokerNumOfNpc] +=
                                DialStrAccept + "\n" + DialStrBank + Bank[pokerMan.PokerNumOfNpc] + "\n" + DialStrBet + Bet[pokerMan.PokerNumOfNpc];
                        }
                        else {
                            master.SayMsg(SAY_NETMSG,
                                          TextPackName::Dialogs,
                                          DLGSTR(DID, STR_DLGREPLY),
                                          "$gametext" + DlgTxt[pokerMan.PokerNumOfNpc] + DialStrCall);
                            DlgTxt[pokerMan.PokerNumOfNpc] +=
                                DialStrCall + "\n" + DialStrBank + Bank[pokerMan.PokerNumOfNpc] + "\n" + DialStrBet + Bet[pokerMan.PokerNumOfNpc];
                        }
                        PlBet[pokerMan.PokerNumOfNpc][m] = Bet[pokerMan.PokerNumOfNpc];
                    }
                }
            }
            master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + DialStrBank + Bank[pokerMan.PokerNumOfNpc]);
            master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + DialStrBet + Bet[pokerMan.PokerNumOfNpc]);
        }
    }
    else {
        if (Bet[pokerMan.PokerNumOfNpc] == PlBet[pokerMan.PokerNumOfNpc][m]) {
            PlState[pokerMan.PokerNumOfNpc][m] = PLST_CALL;
            DlgTxt[pokerMan.PokerNumOfNpc] += DialStrAccept;
            master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + DlgTxt[pokerMan.PokerNumOfNpc]);
            master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + DialStrBank + Bank[pokerMan.PokerNumOfNpc]);
            master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + DialStrBet + Bet[pokerMan.PokerNumOfNpc]);
        }
        else {
            PlState[pokerMan.PokerNumOfNpc][m] = PLST_PASS;
            DlgTxt[pokerMan.PokerNumOfNpc] += DialStrFold;
            master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + DlgTxt[pokerMan.PokerNumOfNpc]);
            master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + DialStrBank + Bank[pokerMan.PokerNumOfNpc]);
            master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + DialStrBet + Bet[pokerMan.PokerNumOfNpc]);
        }
    }

    if (ChWinFold(pokerMan)) {
        EndGame(master, pokerMan);
        return;
    }
    BetEnd[pokerMan.PokerNumOfNpc]++;
}

void GetNpcBet(Critter master, Critter pokerMan)
{
    if ((GameStage[pokerMan.PokerNumOfNpc] != GAME_E_BETROUND1) and (GameStage[pokerMan.PokerNumOfNpc] != GAME_E_BETROUND2) and
        (GameStage[pokerMan.PokerNumOfNpc] != GAME_E_REPLACECARD)) {
        return;
    }
    if (MHod[pokerMan.PokerNumOfNpc] != 0) {
        NpcAction(MHod[pokerMan.PokerNumOfNpc], master, pokerMan);
        MHod[pokerMan.PokerNumOfNpc] = (MHod[pokerMan.PokerNumOfNpc] + 1) % PLAYERS_COUNT;
        if (BetEnd[pokerMan.PokerNumOfNpc] == PLAYERS_COUNT) {
            BetEnd[pokerMan.PokerNumOfNpc] = 0;
            if (GameStage[pokerMan.PokerNumOfNpc] == GAME_E_BETROUND1) {
                GameStage[pokerMan.PokerNumOfNpc] = GAME_E_REPLACECARD;
            }
            else {
                if (GameStage[pokerMan.PokerNumOfNpc] == GAME_E_BETROUND2) {
                    EraseData(pokerMan);
                    EndGame(master, pokerMan);
                }
            }
        }
    }
}

void EndGame(Critter master, Critter pokerMan) // Определение победителя, вывод результата на экран, распределение банка
{
    uint8 max = 0;
    uint8 maxHC = 0;
    uint8 wCount = 0;
    uint prize;
    uint8[] winners = array<uint8> = {0, 0, 0, 0};
    uint8 wc = 0;
    string comb = "";
    auto pokerWincash = pokerMan.PokerWincash.clone();
    pokerWincash.setIfNotExist(master.Id, 0);

    GameStage[pokerMan.PokerNumOfNpc] = GAME_E_END;
    for (uint8 i = 0; i < PLAYERS_COUNT; i++) {
        if (PlState[pokerMan.PokerNumOfNpc][i] != PLST_PASS) {
            if (GetCombo(i, GameCards[pokerMan.PokerNumOfNpc]) % 10 > max) {
                max = GetCombo(i, GameCards[pokerMan.PokerNumOfNpc]) % 10;
            }
        }
    }
    for (uint8 i = 0; i < PLAYERS_COUNT; i++) {
        if (PlState[pokerMan.PokerNumOfNpc][i] != PLST_PASS) {
            if (GetCombo(i, GameCards[pokerMan.PokerNumOfNpc]) % 10 == max) {
                wCount++;
            }
        }
    }
    if (wCount == 1) {
        for (uint8 i = 0; i < PLAYERS_COUNT; i++) {
            if (PlState[pokerMan.PokerNumOfNpc][i] != PLST_PASS) {
                if (GetCombo(i, GameCards[pokerMan.PokerNumOfNpc]) % 10 == max) {
                    winners[i] = 1;
                }
            }
        }
    }
    else {
        for (uint8 i = 0; i < PLAYERS_COUNT; i++) {
            if (PlState[pokerMan.PokerNumOfNpc][i] != PLST_PASS) {
                if (GetCombo(i, GameCards[pokerMan.PokerNumOfNpc]) % 10 == max) {
                    if (GetCombo(i, GameCards[pokerMan.PokerNumOfNpc]) / 10 > maxHC) {
                        maxHC = GetCombo(i, GameCards[pokerMan.PokerNumOfNpc]) / 10;
                    }
                }
            }
        }
        for (uint8 i = 0; i < PLAYERS_COUNT; i++) {
            if (PlState[pokerMan.PokerNumOfNpc][i] != PLST_PASS) {
                if (GetCombo(i, GameCards[pokerMan.PokerNumOfNpc]) % 10 == max) {
                    if (GetCombo(i, GameCards[pokerMan.PokerNumOfNpc]) / 10 == maxHC) {
                        winners[i] = 1;
                    }
                }
            }
        }
    }
    uint8 t = 0;
    for (uint8 i = 0; i < PLAYERS_COUNT; i++) {
        wc += winners[i];
        if (winners[i] == 1) {
            t = i;
        }
    }
    DlgTxt[pokerMan.PokerNumOfNpc] = "@msg dlg " + DLGSTR(DID, STR_WINCOMBO) + "@ " + GetStrCombo(GetCombo(t, GameCards[pokerMan.PokerNumOfNpc]));
    PlayerCardsInDial[pokerMan.PokerNumOfNpc] = true;
    master.SayMsg(SAY_NETMSG,
                  TextPackName::Dialogs,
                  DLGSTR(DID, STR_DLGREPLY),
                  "$gametext" + "@msg dlg " + DLGSTR(DID, STR_WINCOMBO) + "@ " + GetStrCombo(GetCombo(t, GameCards[pokerMan.PokerNumOfNpc])));
    for (uint8 s = 0; s < CARD_COUNT; s++) {
        comb += GetStrCard(GameCards[pokerMan.PokerNumOfNpc][t * 5 + s]);
        if (s != CARD_COUNT - 1) {
            comb += ", ";
        }
    }
    master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + comb);
    DlgTxt[pokerMan.PokerNumOfNpc] += "\n" + comb + "\n" + "@msg dlg " + DLGSTR(DID, STR_WINERS) + "@";
    prize = Bank[pokerMan.PokerNumOfNpc] / wc;
    master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + "@msg dlg " + DLGSTR(DID, STR_WINERS) + "@");
    for (uint8 i = 0; i < 4; i++) {
        if (winners[i] == 1) {
            if (i == 0) {
                master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + "@msg dlg " + DLGSTR(DID, STR_YOUWIN) + "@");
                DlgTxt[pokerMan.PokerNumOfNpc] += " @msg dlg " + DLGSTR(DID, STR_YOUWIN) + "@" + "\n";
                master.PokerWins += 1;
                master.AddItem(Content::Item::bottle_caps, prize * (WinKoef[pokerMan.PokerNumOfNpc] / 100));
            }
            else {
                master.SayMsg(SAY_NETMSG, TextPackName::Dialogs, DLGSTR(DID, STR_DLGREPLY), "$gametext" + "@msg dlg " + DLGSTR(DID, STR_WINPLNUM) + "@ " + i);
                DlgTxt[pokerMan.PokerNumOfNpc] += " @msg dlg " + DLGSTR(DID, STR_WINPLNUM) + "@ " + i + "\n";
            }
        }
    }
    pokerWincash[master.Id] = pokerWincash[master.Id] + master.CountItem(Content::Item::bottle_caps) - StartGameMoney[pokerMan.PokerNumOfNpc];
    pokerMan.PokerWincash = pokerWincash;
    InGame[pokerMan.PokerNumOfNpc] = false;
}

// /////////////////////////////////////////////////////////////////////
//                                                                   //
//                          Диалоги                                  //
//                                                                   //
// /////////////////////////////////////////////////////////////////////

// ///////////////////Формирование диалога/////////////////////////////
void dlg_GameText(Critter player, Critter pokerMan, string& lexems)
{
    if (not IS_DIALOG_GENERATED(lexems)) {
        return;
    }
    lexems = "$gametext" + DlgTxt[pokerMan.PokerNumOfNpc];
    lexems += "$gametext2" + DlgTxt2[pokerMan.PokerNumOfNpc];
    lexems += "$ra_one" + Raise_1[pokerMan.PokerNumOfNpc];
    lexems += "$ra_two" + Raise_2[pokerMan.PokerNumOfNpc];
    lexems += "$ra_three" + Raise_3[pokerMan.PokerNumOfNpc];
    lexems += "$replaceCardOne";
    if (GetBit(ReplCards[pokerMan.PokerNumOfNpc][0], 1) == 1) {
        lexems += "@msg dlg " + DLGSTR(DID, STR_UNSELECT) + "@";
    }
    else {
        lexems += "@msg dlg " + DLGSTR(DID, STR_SELECT) + "@";
    }
    lexems += "$replaceCardTwo";
    if (GetBit(ReplCards[pokerMan.PokerNumOfNpc][0], 2) == 1) {
        lexems += "@msg dlg " + DLGSTR(DID, STR_UNSELECT) + "@";
    }
    else {
        lexems += "@msg dlg " + DLGSTR(DID, STR_SELECT) + "@";
    }
    lexems += "$replaceCardThree";
    if (GetBit(ReplCards[pokerMan.PokerNumOfNpc][0], 3) == 1) {
        lexems += "@msg dlg " + DLGSTR(DID, STR_UNSELECT) + "@";
    }
    else {
        lexems += "@msg dlg " + DLGSTR(DID, STR_SELECT) + "@";
    }
    lexems += "$replaceCardFour";
    if (GetBit(ReplCards[pokerMan.PokerNumOfNpc][0], 4) == 1) {
        lexems += "@msg dlg " + DLGSTR(DID, STR_UNSELECT) + "@";
    }
    else {
        lexems += "@msg dlg " + DLGSTR(DID, STR_SELECT) + "@";
    }
    lexems += "$replaceCardFive";
    if (GetBit(ReplCards[pokerMan.PokerNumOfNpc][0], 5) == 1) {
        lexems += "@msg dlg " + DLGSTR(DID, STR_UNSELECT) + "@";
    }
    else {
        lexems += "@msg dlg " + DLGSTR(DID, STR_SELECT) + "@";
    }
}

void dlg_StartGemeMoney(Critter player, Critter pokerMan, string& lexems)
{
    if (not IS_DIALOG_GENERATED(lexems)) {
        return;
    }
    lexems = "$game_cost" + MoneyForStartGame[pokerMan.PokerNumOfNpc];
}

void dlg_VarRaise(Critter master, Critter pokerMan, string& str)
{
    uint min, max, bRaise = 0;
    int moneyString = 0;
    min = Bet[pokerMan.PokerNumOfNpc] - PlBet[pokerMan.PokerNumOfNpc][0];
    max = master.CountItem(Content::Item::bottle_caps);
    if ((PlBet[pokerMan.PokerNumOfNpc][0] + max) > MaxBet[pokerMan.PokerNumOfNpc]) {
        max = MaxBet[pokerMan.PokerNumOfNpc] - PlBet[pokerMan.PokerNumOfNpc][0];
    }
    if (not IS_DIALOG_SAY_MODE(str)) {
        if (not IS_DIALOG_GENERATED(str)) {
            return;
        }
        App[pokerMan.PokerNumOfNpc] = false;
        str += "$min " + min + "$max " + max;
    }
    else {
        if (VarRiseSucc[pokerMan.PokerNumOfNpc] == 1) {
            return;
        }
        if (!str.tryToInt(moneyString)) {
            if (not App[pokerMan.PokerNumOfNpc]) {
                master.SayMsg(SAY_APPEND, TextPackName::Dialogs, STR_INVALID_MONEY_COUNT);
                App[pokerMan.PokerNumOfNpc] = true;
            }
        }
        else {
            if (moneyString < 0) {
                if (not App[pokerMan.PokerNumOfNpc]) {
                    master.SayMsg(SAY_APPEND, TextPackName::Dialogs, STR_INVALID_MONEY_COUNT);
                    App[pokerMan.PokerNumOfNpc] = true;
                }
            }
            else {
                bRaise = moneyString;
                if ((bRaise < min) or (bRaise > max)) {
                    if (not App[pokerMan.PokerNumOfNpc]) {
                        master.SayMsg(SAY_APPEND, TextPackName::Dialogs, STR_INVALID_MONEY_COUNT);
                        App[pokerMan.PokerNumOfNpc] = true;
                    }
                }
                else {
                    master.SayMsg(SAY_DIALOG, TextPackName::Dialogs, STR_OPERATION_SUCCESS);
                    VarRiseSucc[pokerMan.PokerNumOfNpc] = 1;
                    PlBet[pokerMan.PokerNumOfNpc][0] += bRaise;
                    Bank[pokerMan.PokerNumOfNpc] += bRaise;
                    if (PlBet[pokerMan.PokerNumOfNpc][0] > Bet[pokerMan.PokerNumOfNpc]) {
                        Bet[pokerMan.PokerNumOfNpc] = PlBet[pokerMan.PokerNumOfNpc][0];
                        BetEnd[pokerMan.PokerNumOfNpc] = 1;
                        MHod[pokerMan.PokerNumOfNpc]++;
                        PlState[pokerMan.PokerNumOfNpc][0] = PLST_RAISE;
                    }
                    else {
                        BetEnd[pokerMan.PokerNumOfNpc]++;
                        MHod[pokerMan.PokerNumOfNpc]++;
                        if (BetEnd[pokerMan.PokerNumOfNpc] == PLAYERS_COUNT) {
                            BetEnd[pokerMan.PokerNumOfNpc] = 0;
                            if (GameStage[pokerMan.PokerNumOfNpc] == GAME_E_BETROUND1) {
                                GameStage[pokerMan.PokerNumOfNpc] = GAME_E_REPLACECARD;
                            }
                            else {
                                if (GameStage[pokerMan.PokerNumOfNpc] == GAME_E_BETROUND2) {
                                    EraseData(pokerMan);
                                    EndGame(master, pokerMan);
                                }
                            }
                        }
                        PlState[pokerMan.PokerNumOfNpc][0] = PLST_CALL;
                    }
                    if (master.CountItem(Content::Item::bottle_caps) >= bRaise) {
                        master.DestroyItem(Content::Item::bottle_caps, bRaise);
                    }
                    else {
                        DL("Player have not money");
                    }
                    PrintCards(null, pokerMan, 0);
                }
            }
        }
    }
}

void dlg_FraudCheck(Critter player, Critter pokerMan, string& lexems)
{
    if (not IS_DIALOG_GENERATED(lexems)) {
        return;
    }

    auto pokerFraud = pokerMan.PokerFraud.clone();
    pokerFraud.setIfNotExist(player.Id, 0);

    if (pokerFraud[player.Id] != 1) {
        lexems = "$fraud@msg dlg " + DLGSTR(DID, STR_FRAUD_ON) + "@";
    }
    else {
        lexems = "$fraud@msg dlg " + DLGSTR(DID, STR_FRAUD_OFF) + "@";
    }
}

void dlg_ManyWins(Critter player, Critter pokerMan, string& lexems)
{
    if (not IS_DIALOG_GENERATED(lexems)) {
        return;
    }

    auto pokerMamywins = pokerMan.PokerManywins.clone();
    pokerMamywins.setIfNotExist(player.Id, 0);
    if (Game.GetFullSecond() - pokerMamywins[player.Id] < (WaitForGame[pokerMan.PokerNumOfNpc] * 24 * 60 * 60)) {
        lexems = "$manywins@msg dlg " + DLGSTR(DID, STR_MANYWINS_ON) + "@";
    }
    else {
        lexems = "$manywins@msg dlg " + DLGSTR(DID, STR_MANYWINS_OFF) + "@";
    }
}

// ///////////////////Результаты реплик////////////////////////////////
void r_Replace(Critter master, Critter pokerMan) // замена карт
{
    uint8 m;
    uint8[] cardsInPack = {};
    for (uint8 i = 1; i <= 52; i++) {
        if (GetBit(Koloda[pokerMan.PokerNumOfNpc], i) == 1) {
            cardsInPack.insertLast(i);
        }
    }
    NpcReplaceCards(pokerMan);
    for (uint8 t = 0; t < PLAYERS_COUNT; t++) {
        for (uint8 i = 0; i < CARD_COUNT; i++) {
            if (GetBit(ReplCards[pokerMan.PokerNumOfNpc][t], i + 1) == 1) {
                if (cardsInPack.length() != 0) {
                    m = Game.Random(0, cardsInPack.length() - 1);
                    Koloda[pokerMan.PokerNumOfNpc] = SetBit(Koloda[pokerMan.PokerNumOfNpc], cardsInPack[m], false);
                    GameCards[pokerMan.PokerNumOfNpc][t * CARD_COUNT + i] = cardsInPack[m];
                }
                else {
                    Game.Log("Error: Pack of cards is empty");
                    return;
                }
            }
        }
        ReplCards[pokerMan.PokerNumOfNpc][t] = 0;
    }
    GameStage[pokerMan.PokerNumOfNpc] = GAME_E_BETROUND2;
    PrintCards(master, pokerMan, 0);
}

void r_ReplSet(Critter master, Critter pokerMan, int val)
{
    if (GetBit(ReplCards[pokerMan.PokerNumOfNpc][0], val) == 1) {
        ReplCards[pokerMan.PokerNumOfNpc][0] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][0], val, false); // отменить выбор карты для замены
    }
    else {
        ReplCards[pokerMan.PokerNumOfNpc][0] = SetBit5(ReplCards[pokerMan.PokerNumOfNpc][0], val, true); // выбор карты для замены
    }
}

void r_BetRaise(Critter master, Critter pokerMan, int val) // Повышение ставки
{
    switch (val) {
    case -1:
        if (master.CountItem(Content::Item::bottle_caps) > 0) {
            Bank[pokerMan.PokerNumOfNpc] += master.CountItem(Content::Item::bottle_caps);
            PlBet[pokerMan.PokerNumOfNpc][0] = PlBet[pokerMan.PokerNumOfNpc][0] + master.CountItem(Content::Item::bottle_caps);
            Bet[pokerMan.PokerNumOfNpc] = PlBet[pokerMan.PokerNumOfNpc][0];
            master.DestroyItem(Content::Item::bottle_caps, master.CountItem(Content::Item::bottle_caps));
        }
        else {
            DL("Player have not money");
        }
        break;
    case 0:
        if (master.CountItem(Content::Item::bottle_caps) >= Raise_1[pokerMan.PokerNumOfNpc]) {
            Bank[pokerMan.PokerNumOfNpc] += Raise_1[pokerMan.PokerNumOfNpc];
            PlBet[pokerMan.PokerNumOfNpc][0] = PlBet[pokerMan.PokerNumOfNpc][0] + Raise_1[pokerMan.PokerNumOfNpc];
            Bet[pokerMan.PokerNumOfNpc] = PlBet[pokerMan.PokerNumOfNpc][0];
            master.DestroyItem(Content::Item::bottle_caps, Raise_1[pokerMan.PokerNumOfNpc]);
        }
        else {
            DL("Player have not money");
        }
        break;
    case 1:
        if (master.CountItem(Content::Item::bottle_caps) >= Raise_2[pokerMan.PokerNumOfNpc]) {
            Bank[pokerMan.PokerNumOfNpc] += Raise_2[pokerMan.PokerNumOfNpc];
            PlBet[pokerMan.PokerNumOfNpc][0] = PlBet[pokerMan.PokerNumOfNpc][0] + Raise_2[pokerMan.PokerNumOfNpc];
            Bet[pokerMan.PokerNumOfNpc] = PlBet[pokerMan.PokerNumOfNpc][0];
            master.DestroyItem(Content::Item::bottle_caps, Raise_2[pokerMan.PokerNumOfNpc]);
        }
        else {
            DL("Player have not money");
        }
        break;
    case 2:
        if (master.CountItem(Content::Item::bottle_caps) >= Raise_3[pokerMan.PokerNumOfNpc]) {
            Bank[pokerMan.PokerNumOfNpc] += Raise_3[pokerMan.PokerNumOfNpc];
            PlBet[pokerMan.PokerNumOfNpc][0] = PlBet[pokerMan.PokerNumOfNpc][0] + Raise_3[pokerMan.PokerNumOfNpc];
            Bet[pokerMan.PokerNumOfNpc] = PlBet[pokerMan.PokerNumOfNpc][0];
            master.DestroyItem(Content::Item::bottle_caps, Raise_3[pokerMan.PokerNumOfNpc]);
        }
        else {
            DL("Player have not money");
        }
        break;
    default:
        Game.Log("ERROR");
        break;
    }
    BetEnd[pokerMan.PokerNumOfNpc] = 1;
    MHod[pokerMan.PokerNumOfNpc]++;
    PlState[pokerMan.PokerNumOfNpc][0] = PLST_RAISE;
    ModChFr[pokerMan.PokerNumOfNpc]++;
    PrintCards(master, pokerMan, 0);
}

void r_BetCall(Critter master, Critter pokerMan, int val) // Ответ на ставку
{
    if (val == D_VA_BANK) {
        WinKoef[pokerMan.PokerNumOfNpc] =
            ((PlBet[pokerMan.PokerNumOfNpc][0] + master.CountItem(Content::Item::bottle_caps)) / Bet[pokerMan.PokerNumOfNpc]) * 100;
        Game.Log("Koef: " + WinKoef[pokerMan.PokerNumOfNpc]);
    }
    if (Bet[pokerMan.PokerNumOfNpc] - PlBet[pokerMan.PokerNumOfNpc][0] != 0) {
        if (Bet[pokerMan.PokerNumOfNpc] - PlBet[pokerMan.PokerNumOfNpc][0] > master.CountItem(Content::Item::bottle_caps)) {
            master.DestroyItem(Content::Item::bottle_caps, master.CountItem(Content::Item::bottle_caps));
        }
        else {
            master.DestroyItem(Content::Item::bottle_caps, Bet[pokerMan.PokerNumOfNpc] - PlBet[pokerMan.PokerNumOfNpc][0]);
        }
    }
    PlBet[pokerMan.PokerNumOfNpc][0] = Bet[pokerMan.PokerNumOfNpc];
    BetEnd[pokerMan.PokerNumOfNpc]++;
    MHod[pokerMan.PokerNumOfNpc]++;
    if (BetEnd[pokerMan.PokerNumOfNpc] == PLAYERS_COUNT) {
        BetEnd[pokerMan.PokerNumOfNpc] = 0;
        if (GameStage[pokerMan.PokerNumOfNpc] == GAME_E_BETROUND1) {
            GameStage[pokerMan.PokerNumOfNpc] = GAME_E_REPLACECARD;
        }
        else {
            if (GameStage[pokerMan.PokerNumOfNpc] == GAME_E_BETROUND2) {
                EraseData(pokerMan);
                EndGame(master, pokerMan);
            }
        }
    }
    PlState[pokerMan.PokerNumOfNpc][0] = PLST_CALL;
    PrintCards(master, pokerMan, 0);
}

void r_BetPass(Critter master, Critter pokerMan) // Игрок спасовал
{
    PlState[pokerMan.PokerNumOfNpc][0] = PLST_PASS;
    EndGame(master, pokerMan);
}

uint r_StartNewGame(Critter master, Critter pokerMan) // Начало новой игры
{
    auto pokerWincash = pokerMan.PokerWincash.clone();
    pokerWincash.setIfNotExist(master.Id, 0);

    if (pokerWincash[master.Id] > StopGameMoney[pokerMan.PokerNumOfNpc]) {
        return D_MANYWINS;
    }

    if (master.CountItem(Content::Item::bottle_caps) >= Raise_1[pokerMan.PokerNumOfNpc]) {
        master.DestroyItem(Content::Item::bottle_caps, Raise_1[pokerMan.PokerNumOfNpc]);
    }
    else {
        DL("Player have not money");
    }

    InitGame(pokerMan, master);
    EraseData(pokerMan);
    PrintCards(master, pokerMan, 0);
    return 0;
}

void r_TermGame(Critter master, Critter pokerMan)
{
    InGame[pokerMan.PokerNumOfNpc] = false;
}

void r_GetCards(Critter master, Critter pokerMan) // Начало игры
{
    FirstGame[pokerMan.PokerNumOfNpc] = true;
    InitGame(pokerMan, master);
    EraseData(pokerMan);
    PrintCards(master, pokerMan, 0);
}

void r_BetNext(Critter master, Critter pokerMan)
{
    GetNpcBet(master, pokerMan);
}

void r_ViewCards(Critter master, Critter pokerMan)
{
    PrintCards(master, pokerMan, 0);
}

void r_GetStartMoney(Critter master, Critter pokerMan)
{
    if (master.CountItem(Content::Item::bottle_caps) >= MoneyForStartGame[pokerMan.PokerNumOfNpc]) {
        master.DestroyItem(Content::Item::bottle_caps, MoneyForStartGame[pokerMan.PokerNumOfNpc]);
    }
    else {
        DL("Player have not money");
    }
}

void r_Fraud(Critter master, Critter pokerMan)
{
    FraudMode[pokerMan.PokerNumOfNpc] = 1;
}

uint r_Fraud1(Critter master, Critter pokerMan, int val)
{
    bool fraudSucc = false;
    uint diffic, rand;
    int luckModif;
    if ((val <= 2) and (val >= 0)) {
        diffic = int(3.3 * float(master.SkillGambling)) / PMLevel[pokerMan.PokerNumOfNpc];
        luckModif = int((float(master.Luck) - 5.5) * 4.0);
        if (diffic + luckModif > 0) {
            diffic += luckModif;
        }
        else {
            diffic = 0;
        }
        if (diffic > 100) {
            diffic = 100;
        }
        diffic = int(float(diffic) * 0.95);
        rand = Game.Random(1, 100);

        DL("\n<Poker> PMLevel: " + PMLevel[pokerMan.PokerNumOfNpc] + ", player.Param[SK_GAMBLING]: " + master.SkillGambling + ", master.Luck: " + master.Luck +
           ", Chance: " + diffic);

        if (rand <= diffic) {
            fraudSucc = true;
        }
        if (fraudSucc) {
            PrintCards(master, pokerMan, val + 1);
        }
        else {
            RunCheatScript(OnCheat1[pokerMan.PokerNumOfNpc], master, pokerMan);
            return uint(-1);
        }
    }
    return 0;
}

void r_Fraud2(Critter master, Critter pokerMan)
{
    FraudMode[pokerMan.PokerNumOfNpc] = 2;
    PrintFraud2Text(master, pokerMan);
}

uint r_Fraud2(Critter master, Critter pokerMan, int val)
{
    bool fraudSucc = false;
    uint diffic, rand;
    if ((val <= 4) and (val >= 0)) {
        diffic = int(3.3 * float(master.SkillGambling)) / PMLevel[pokerMan.PokerNumOfNpc];
        if (diffic > 100) {
            diffic = 100;
        }
        diffic = int(float(diffic) * 0.95);
        rand = Game.Random(1, 100);

        DL("\n<Poker> PMLevel: " + PMLevel[pokerMan.PokerNumOfNpc] + ", player.Param[SK_GAMBLING]: " + master.SkillGambling + ", Chance: " + diffic);

        if (rand <= diffic) {
            fraudSucc = true;
        }
        if (fraudSucc) {
            if ((val >= 0) and (val <= 4)) {
                GameCards[pokerMan.PokerNumOfNpc][val] = CardInSleeve[pokerMan.PokerNumOfNpc];
                PrintCards(master, pokerMan, 0);
                Fraud2Succ[pokerMan.PokerNumOfNpc] = 1;
                FraudMode[pokerMan.PokerNumOfNpc] = 1;
            }
        }
        else {
            RunCheatScript(OnCheat2[pokerMan.PokerNumOfNpc], master, pokerMan);
            return uint(-1);
        }
    }
    return 0;
}

void r_FraudCancel(Critter master, Critter pokerMan)
{
    FraudMode[pokerMan.PokerNumOfNpc] = 0;
}

void r_FraudCheck(Critter master, Critter pokerMan)
{
    auto pokerFraud = pokerMan.PokerFraud.clone();
    pokerFraud.setIfNotExist(master.Id, 0);
    uint pf = pokerFraud[master.Id];

    DL("<poker> pokerMan.PokerFraud: " + pf + " FM: " + Game.GetFullSecond());

    if (pokerFraud[master.Id] <= Game.GetFullSecond()) {
        pokerFraud[master.Id] = 1;
        pokerMan.PokerFraud = pokerFraud;
    }
}

void r_VarRise(Critter master, Critter pokerMan)
{
    VarRiseSucc[pokerMan.PokerNumOfNpc] = 0;
}

void r_ManyWinsCheck(Critter master, Critter pokerMan)
{
    auto pokerManywins = pokerMan.PokerManywins.clone();
    pokerManywins.setIfNotExist(master.Id, 0);
    auto pokerWincash = pokerMan.PokerWincash.clone();
    pokerWincash.setIfNotExist(master.Id, 0);
    if ((Game.GetFullSecond() - pokerManywins[master.Id]) > (WaitForGame[pokerMan.PokerNumOfNpc]) * 24 * 60 * 60) {
        pokerWincash[master.Id] = 0;
        pokerMan.PokerWincash = pokerWincash;
    }
}

// /////////////////////Условия для появления реплик/////////////////////////////////
bool d_GameOver(Critter master, Critter pokerMan)
{
    if (GameStage[pokerMan.PokerNumOfNpc] == GAME_E_END) {
        return true;
    }
    return false;
}

bool d_TermGame(Critter master, Critter pokerMan)
{
    if (FraudMode[pokerMan.PokerNumOfNpc] != 0) {
        return false;
    }
    if (GameStage[pokerMan.PokerNumOfNpc] != GAME_E_END) {
        return true;
    }
    else {
        return false;
    }
}

bool d_Replaced(Critter master, Critter pokerMan) // для отображения реплик игрока в диалоге
{
    if (GameStage[pokerMan.PokerNumOfNpc] != GAME_E_REPLACECARD) {
        return false;
    }
    if (FraudMode[pokerMan.PokerNumOfNpc] != 0) {
        return false;
    }
    return true;
}

bool d_Replace(Critter master, Critter pokerMan) // для вывода строки "заменить карты"
{
    if (FraudMode[pokerMan.PokerNumOfNpc] != 0) {
        return false;
    }
    if (GameStage[pokerMan.PokerNumOfNpc] == GAME_E_REPLACECARD) {
        return true;
    }
    return false;
}

bool d_InGame(Critter master, Critter pokerMan, int val)
{
    if ((InGame[pokerMan.PokerNumOfNpc]) and (master.Id == InGamePl[pokerMan.PokerNumOfNpc])) {
        if (val == PL_RESUME_GAME) {
            return true;
        }
        else {
            return false;
        }
    }
    else {
        if (val == PL_START_GAME) {
            return true;
        }
        else {
            return false;
        }
    }
}

bool d_BetCall(Critter master, Critter pokerMan, int val) // Вывод строки "Ответить на ставку"
{
    if (FraudMode[pokerMan.PokerNumOfNpc] != 0) {
        return false;
    }
    if ((GameStage[pokerMan.PokerNumOfNpc] == GAME_E_BETROUND1) or (GameStage[pokerMan.PokerNumOfNpc] == GAME_E_BETROUND2)) {
        if (val != D_VA_BANK) {
            if (Bet[pokerMan.PokerNumOfNpc] < PlBet[pokerMan.PokerNumOfNpc][0]) {
                return false;
            }
            else {
                if ((Bet[pokerMan.PokerNumOfNpc] - PlBet[pokerMan.PokerNumOfNpc][0]) <= master.CountItem(Content::Item::bottle_caps)) {
                    if (Bet[pokerMan.PokerNumOfNpc] - PlBet[pokerMan.PokerNumOfNpc][0] == 0) {
                        if (val == D_PRIN) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        if (val == D_PRIN) {
                            return false;
                        }
                        else {
                            return true;
                        }
                    }
                }
                else {
                    return false;
                }
            }
        }
        else {
            if (master.CountItem(Content::Item::bottle_caps) > 0) {
                if ((Bet[pokerMan.PokerNumOfNpc] - PlBet[pokerMan.PokerNumOfNpc][0]) > master.CountItem(Content::Item::bottle_caps)) {
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
    }
    return false;
}

bool d_BetRaise(Critter master, Critter pokerMan, int val) // Вывод строк на повышение ставки
{
    uint betMoney;
    uint min, max;
    min = Bet[pokerMan.PokerNumOfNpc] - PlBet[pokerMan.PokerNumOfNpc][0];
    max = master.CountItem(Content::Item::bottle_caps);
    if ((PlBet[pokerMan.PokerNumOfNpc][0] + max) > MaxBet[pokerMan.PokerNumOfNpc]) {
        max = MaxBet[pokerMan.PokerNumOfNpc] - PlBet[pokerMan.PokerNumOfNpc][0];
    }
    if (FraudMode[pokerMan.PokerNumOfNpc] != 0) {
        return false;
    }
    if ((GameStage[pokerMan.PokerNumOfNpc] == GAME_E_BETROUND1) or (GameStage[pokerMan.PokerNumOfNpc] == GAME_E_BETROUND2)) {
        switch (val) {
        case -1:
            betMoney = master.CountItem(Content::Item::bottle_caps);
            break;
        case 0:
            betMoney = Raise_1[pokerMan.PokerNumOfNpc];
            break;
        case 1:
            betMoney = Raise_2[pokerMan.PokerNumOfNpc];
            break;
        case 2:
            betMoney = Raise_3[pokerMan.PokerNumOfNpc];
            break;
        case 3:
            if (Bet[pokerMan.PokerNumOfNpc] == MaxBet[pokerMan.PokerNumOfNpc]) {
                return false;
            }
            if (max >= min) {
                return true;
            }
            else {
                return false;
            }
        default:
            Game.Log("Error");
            break;
        }
        if ((betMoney <= master.CountItem(Content::Item::bottle_caps)) and ((betMoney + PlBet[pokerMan.PokerNumOfNpc][0]) > Bet[pokerMan.PokerNumOfNpc]) and
            ((betMoney + PlBet[pokerMan.PokerNumOfNpc][0]) <= MaxBet[pokerMan.PokerNumOfNpc])) {
            return true;
        }
    }
    return false;
}

bool d_BetNext(Critter master, Critter pokerMan, int val)
{
    if (FraudMode[pokerMan.PokerNumOfNpc] != 0) {
        return false;
    }
    if ((GameStage[pokerMan.PokerNumOfNpc] == GAME_E_BETROUND1) or (GameStage[pokerMan.PokerNumOfNpc] == GAME_E_BETROUND2)) {
        if (val == 0) {
            if (MHod[pokerMan.PokerNumOfNpc] != 0) {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            if (MHod[pokerMan.PokerNumOfNpc] != 0) {
                return false;
            }
            else {
                return true;
            }
        }
    }
    else {
        return false;
    }
}

bool d_ViewCards(Critter master, Critter pokerMan)
{
    if (FraudMode[pokerMan.PokerNumOfNpc] != 0) {
        return false;
    }
    if (GameStage[pokerMan.PokerNumOfNpc] == GAME_E_BETROUND1) {
        if (MHod[pokerMan.PokerNumOfNpc] == 0) {
            if (not PlayerCardsInDial[pokerMan.PokerNumOfNpc]) {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            return false;
        }
    }
    else {
        if (GameStage[pokerMan.PokerNumOfNpc] == GAME_E_REPLACECARD) {
            if (not PlayerCardsInDial[pokerMan.PokerNumOfNpc]) {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            return false;
        }
    }
}

bool d_Fraud(Critter master, Critter pokerMan)
{
    if (GameStage[pokerMan.PokerNumOfNpc] != GAME_E_END) {
        if (FraudMode[pokerMan.PokerNumOfNpc] == 0) {
            return true;
        }
        else {
            return false;
        }
    }
    else {
        return false;
    }
}
bool d_Fraud1(Critter master, Critter pokerMan, int val)
{
    if (GameStage[pokerMan.PokerNumOfNpc] != GAME_E_END) {
        if (FraudMode[pokerMan.PokerNumOfNpc] == 1) {
            if (PlState[pokerMan.PokerNumOfNpc][val + 1] == PLST_PASS) {
                return false;
            }
            else {
                return true;
            }
        }
        else {
            return false;
        }
    }
    else {
        return false;
    }
}
bool d_Fraud2(Critter master, Critter pokerMan)
{
    if ((GameStage[pokerMan.PokerNumOfNpc] != GAME_E_END) and (Fraud2Succ[pokerMan.PokerNumOfNpc]) == 0) {
        if (FraudMode[pokerMan.PokerNumOfNpc] == 1) {
            if (master.CountItem(Content::Item::deck_of_cards) > 0) {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            return false;
        }
    }
    else {
        return false;
    }
}
bool d_Fraud3(Critter master, Critter pokerMan)
{
    if (GameStage[pokerMan.PokerNumOfNpc] != GAME_E_END) {
        if (FraudMode[pokerMan.PokerNumOfNpc] == 2) {
            return true;
        }
        else {
            return false;
        }
    }
    else {
        return false;
    }
}

bool d_FraudCancel(Critter master, Critter pokerMan)
{
    if (FraudMode[pokerMan.PokerNumOfNpc] == 1) {
        return true;
    }
    else {
        return false;
    }
}

bool d_Fraud2Cancel(Critter master, Critter pokerMan)
{
    if (FraudMode[pokerMan.PokerNumOfNpc] == 2) {
        return true;
    }
    else {
        return false;
    }
}

bool d_ManyWinsCheck(Critter master, Critter pokerMan, int val)
{
    if (StopGameMoney[pokerMan.PokerNumOfNpc] == 0) {
        return false;
    }
    auto pokerWincash = pokerMan.PokerWincash.clone();
    pokerWincash.setIfNotExist(master.Id, 0);
    if (pokerWincash[master.Id] < StopGameMoney[pokerMan.PokerNumOfNpc]) {
        return val == 1;
    }
    else {
        return val != 1;
    }
}
