namespace NukeMachine
{

#if SERVER

/*
   Автомат нюка-колы
   Игрок может использовать монету на автомате, в этом случае, если пройдет проверку по удаче получит одну бутылку нюка-колы.
   Если проверка не пройдена, автомат выстрелит в него бутылкой. Бутылка летит на HIT_RANGE гексов в направлении игрока.
   Если игрок не пройдет проверку на ловкость, получит от MIN_DMG до MAX_DMG повреждений.
   Если на пути бутылки стоит другой криттер, получить повреждения может он. Игрок, использовавший монетку будет считаться атакующим.
 */

///@ Property Critter Server int32 NukeStock Mutable Persistent
///@ Property Critter Server synctime NukeRestockTime Mutable Persistent

#define MAX_STOCK           (10)
#define HIT_RANGE           (3) // расстояние, на которое "стреляет" автомат
#define MIN_DMG             (1)
#define MAX_DMG             (75)

#define STR_USE_CAPS        (101)
#define STR_GET_NUKE        (102)
#define STR_HITTED          (103)
#define STR_DODGE           (104)
#define STR_SOMEBODY_DODGE  (105)
#define STR_EMPTY           (106)

#define PLAYERS_SRCH_RADIUS (10)

#define _CheckStat          #(cr, stat, bonus)(Game.Random(1, 10) < cr.GetAsInt(stat) + bonus)

bool _UseCapsOnNukeMachine(Critter player, Item scenery, int skill, Item item)
{
    if (!valid(item) || item.ProtoId != Content::Item::bottle_caps) {
        return false;
    }

    if (player.NukeRestockTime < Game.SynchronizedTime) {
        player.NukeStock = int(Game.Random(MAX_STOCK / 2, MAX_STOCK));
        player.NukeRestockTime = Game.SynchronizedTime + Time::GameDays(7);
    }

    if (player.NukeStock > 0) {
        player.DestroyItem(Content::Item::bottle_caps, 1);

        player.NukeStock -= 1;
        Messaging::Info(player, TextPackName::Text, STR_USE_CAPS);

        if (_CheckStat(player, CritterProperty::Luck, 0)) {
            player.AddItem(Content::Item::nuka_cola, 1);
            Messaging::Info(player, TextPackName::Text, STR_GET_NUKE);
            return true;
        }
        else {
            TryHitSomeOne(player, scenery);
            return true;
        }
    }
    else {
        Messaging::Info(player, TextPackName::Text, STR_EMPTY);
        return true;
    }
}

void TryHitSomeOne(Critter player, Item nukeMashine)
{
    Map map = player.GetMap();
    if (!valid(map)) {
        return;
    }

    mpos hex0 = nukeMashine.Hex;
    mpos hex1 = hex0;

    uint8 dir = Game.GetDirection(hex0, player.Hex);
    bool targetHitted = false;

    map.MoveHexByDir(hex1, dir, 3);
    Effects::RunFlyEffect(map, Content::Item::flying_knife, hex0, hex1);

    for (int i = 0; i < HIT_RANGE; i++) {
        map.MoveHexByDir(hex0, dir, 1);
        Critter target = map.GetCritter(hex0);
        if (valid(target) && !targetHitted) {
            if (target.IsAlive()) {
                if (_CheckStat(target, CritterProperty::Agility, 0)) {
                    Messaging::Info(target, TextPackName::Text, STR_DODGE);
                    _CritAnimate(target, CritterActionAnim::DodgeFront);
                    Critter[] critters = map.GetCritters(target.Hex, PLAYERS_SRCH_RADIUS, CritterFindType::Players);
                    if (!critters.isEmpty()) {
                        string lexems = "$name " + (target.ControlledByPlayer ?
                                                        PlayerRegistration::GetPlayerName(target.Id) :
                                                        (target.DialogId != EMPTY_HSTRING ? "@text Dialogs " + STR_NPC_NAME_DLG(target.DialogId) + " @" : ""));
                        for (int j = 0; j < critters.length(); j++) {
                            if (critters[j].Id != target.Id) {
                                Messaging::Info(critters[j], TextPackName::Text, STR_SOMEBODY_DODGE, lexems);
                            }
                        }
                    }
                }
                else {
                    Messaging::SayShout(target, TextPackName::Text, STR_HITTED);
                    targetHitted = true;
                    Combat::InjureCritter(target, Game.Random(MIN_DMG, MAX_DMG), DamageTypes::Normal, dir, player.Id);
                    map.AddItem(hex0, Content::Item::nuka_cola, 1);
                    break;
                }
            }
        }
    }
}

#endif

}
