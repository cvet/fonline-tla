// FOS Client

CLASS_ALIAS( Sprite, Sprite::Sprite );
CLASS_ALIAS( Serializator, Serializator::Serializator );

#pragma enum CursorType Default = 0
#pragma globalvar CursorType __Cursor
#pragma globalvar uint __CursorData
#pragma globalvar CursorType __DraggableCursor

/*EXPORT*/ funcdef Screen@ CreateScreenFunc();
/*EXPORT*/ funcdef bool    DragAndDropHandler( Object& obj, Object@ target );
/*EXPORT*/ funcdef bool    DropMenuNeedShowButton( Critter@ cr, Item@ item );
/*EXPORT*/ funcdef void    DropMenuButtonAction( Critter@ cr, Item@ item );

// Inheritance
// Object
//   Panel
//     Screen
//     Grid
//       ItemView
//     Button
//       CheckBox
//         RadioButton
//   Text
//     TextInput
//       Console
//     MessageBox

// Callbacks
// Object
//   void OnConstruct()
//   void OnInit()
//   void OnShow()
//   void OnShow( dictionary@ params )
//   void OnHide()
//   void OnAppear()
//   void OnDisappear()
//   void OnDraw()
//   void OnMove( int deltaX, int deltaY )
//   void OnMouseDown( int button )
//   void OnMouseUp( int button, bool lost )
//   void OnMousePressed( int button )
//   void OnLMousePressed()
//   void OnRMousePressed()
//   void OnMouseClick( int button )
//   void OnLMouseClick()
//   void OnRMouseClick()
//   void OnMouseMove()
//   void OnGlobalMouseDown( int button )
//   void OnGlobalMouseUp( int button )
//   void OnGlobalMousePressed( int button )
//   void OnGlobalMouseClick( int button )
//   void OnGlobalMouseMove()
//   void OnInput()
//   void OnInput( uint8 key )
//   void OnInput( string& text )
//   void OnInput( uint8 key, string@ text )
//   void OnGlobalInput( uint8 key, string@ text )
//   void OnActiveChanged()
//   void OnFocusChanged()
//   void OnHoverChanged()
//   void OnDragChanged()
//   void OnResizeGrid( Object@ cell, uint cellIndex )
//   void OnDrawItem( Item@ item, Object@ cell, uint cellIndex )
// CheckBox
//   void OnCheckedChanged()
// ItemView
//   Item@[]@ OnGetItems() - return all items for display
//   int OnCheckItem( Item@ item ) - return slot index if UseSorting == false; sorting value if UseSorting == true; < 0 to discard item

// API
// Object
//   bool Active
//   bool ActiveSelf
//   string Name
//   int PosX
//   int PosY
//   int AbsolutePosX
//   int AbsolutePosY
//   int Width
//   int Height
//   int Anchor
//   int Dock
//   bool IsDraggable
//   bool IsNotHittable
//   bool IsNotCatchable
//   bool CheckTransparentOnHit
//   bool IsFocused
//   bool IsPressed
//   bool IsHovered
//   bool IsDragged
//   uint ChildCount
//   Object@ Parent
//   Screen@ Screen
//   Grid@ Grid
//   uint CellIndex
//   void Init( Object@ parent )
//   void Remove()
//   void SetActive( bool active )
//   void SetPosition( int x, int y )
//   void SetPosition( string& iniKey )
//   void SetSize( int w, int h )
//   void SetAnchor( int anchorStyles )
//   void SetDock( int dockStyle )
//   void SetDraggable( bool enabled )
//   void SetNotHittable( bool enabled )
//   void SetNotCatchable( bool enabled )
//   void SetCheckTransparentOnHit( bool enabled )
//   Object@ FindMouseHit()
//   Object@ FindHit( int x, int y )
//   bool IsMouseHit()
//   bool IsHit( int x, int y )
//   void GetWholeSize( int& centerX, int& centerY, int& wholeWidth, int& wholeHeight, bool onlyChidren = false )
//   void Draw( int x, int y )
//   void Move( int deltaX, int deltaY )
//   void MouseClick( int button )
//   void Input( uint8 key, string& text )
//   Panel@ FindPanel( string& name )
//   Text@ FindText( string& name )
//   TextInput@ FindTextInput( string& name )
//   Button@ FindButton( string& name )
//   Object@ Find( string& name, bool deepFind = true )
//   Object@ GetChild( uint index )
// Panel : Object
//   Sprite@ BackgroundImage
//   int BackgroundImageLayout
//   void SetBackgroundImage( string@ imageName, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetBackgroundImage( uint imageNameHash, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetCropContent( bool enabled )
//   void SetAutoScroll( bool ver, bool hor )
//   void ModifyScroll( int ver, int hor )
//   bool CanModifyScroll( int ver, int hor )
// Text : Object
//   string@ Text (overridable)
//   int TextFont
//   uint TextColor
//   uint TextColorFocused
//   int TextFlags
//   void SetText( string@ text, int font, int flags )
//   void SetText( string@ text )
//   void SetTextWithResize( string@ text )
//   void SetTextFont( int font )
//   void SetTextFlags( int flags )
//   void SetTextColor( uint color )
//   void SetTextFocusedColor( uint color )
// TextInput : Text : Object
//   uint InputLength
//   bool IsTextPassword
//   string PasswordChar
//   void SetInputLength( uint length )
//   void SetInputPassword( string@ passwordChar )
//   void SetCarriage( bool enable )
// Button : Panel : Object
//   Sprite@ PressedImage
//   int PressedImageLayout
//   Sprite@ HoverImage
//   int HoverImageLayout
//   bool IsSwitched
//   bool IsDisabled
//   void SetPressedImage( string@ imageName, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetPressedImage( uint imageNameHash, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetHoverImage( string@ imageName, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetHoverImage( uint imageNameHash, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetDisabledImage( string@ imageName, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetDisabledImage( uint imageNameHash, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetSwitch( bool enabled )
//   void SetCondition( bool enabled )
// CheckBox : Button : Panel : Object
//   bool IsChecked
//   void SetChecked( bool checked )
// RadioButton : CheckBox : Button : Panel : Object
// Screen : Panel : Object
//   int Index
//   bool IsHardcoded
//   bool IsMain
//   bool IsModal
//   bool IsMultiinstance
//   bool IsCloseOnMiss
//   bool IsCanMove
//   bool IsMoveIgnoreBorders
//   int[] AvailableCursors
//   int Cursor
//   bool IsOnTop
//   void SetModal( bool enabled )
//   void SetMultiinstance( bool enabled )
//   void SetCloseOnMiss( bool enabled )
//   void SetCanMove( bool enabled, bool ignoreBorders )
//   void SetAvailableCursors( CursorType[] cursors )
// Grid : Panel : Object
//   string@ CellPrototype
//   uint GridSize
//   int Columns
//   Object@[]@ Cells
//   void ResizeGrid( uint size )
//   void RefreshContentPositions()
//   void SetCellPrototype( string name )
//   void SetGridSize( uint size )
//   void SetColumns( int length )
//   void SetPadding( int x, int y )
// MessageBox : Text : Object
//   string[] MessageTexts
//   int[] MessageTypes
//   string[] MessageTimes
//   bool[] DisplayedMessages
//   bool InvertMessages
//   void AddMessage( string@ text, int type = FOMB_GAME )
//   void SetDisplayedMessages( int[] messageTypes )
//   void ChangeDisplayedMessage( int messageType, bool enable )
//   void SetInvertMessages( bool invert )
//   void ClearMessages()
// Console : TextInput : Text : Object
//   string HistoryStorageName
//   string[]@ History
//   uint HistoryMaxLength
//   void Activate()
//   void Deactivate()
//   void SendText()
//   void Toggle() // Automatically manage calls of Activate / Deactivate / SendText
//   void SetHistoryStorage( string storageName )
//   void SetHistoryMaxLength( uint length )
// ItemView : Grid : Panel : Object
//   int UserData
//   int UserDataExt
//   bool UseSorting
//   Item@[] Items
//   Item@ GetItem( uint cellIndex )
//   void Resort()
//   void SetUserData( int data )
//   void SetUserDataExt( int data )
//   void SetUseSorting( bool enable )

/*EXPORT*/ class Object
{
    bool    get_Active() final                { return _ActiveSelf && ( _Parent !is null ? _Parent.Active : true ); }
    bool    get_ActiveSelf() final            { return _ActiveSelf; }
    string@ get_Name() final                  { return _Name; }
    int     get_PosX() final                  { return _Parent !is null ? _AbsolutePosX - _Parent._AbsolutePosX : _AbsolutePosX; }
    int     get_PosY() final                  { return _Parent !is null ? _AbsolutePosY - _Parent._AbsolutePosY : _AbsolutePosY; }
    int     get_AbsolutePosX() final          { return _AbsolutePosX; }
    int     get_AbsolutePosY() final          { return _AbsolutePosY; }
    int     get_Width() final                 { return _Width; }
    int     get_Height() final                { return _Height; }
    int     get_Anchor() final                { return _Anchor; }
    int     get_Dock() final                  { return _Dock; }
    bool    get_IsDraggable() final           { return _IsDraggable; }
    bool    get_IsNotHittable() final         { return _IsNotHittable; }
    bool    get_IsNotCatchable() final        { return _IsNotCatchable; }
    bool    get_CheckTransparentOnHit() final { return _CheckTransparentOnHit; }
    bool    get_IsFocused() final             { return _IsFocused; }
    bool    get_IsPressed() final             { return _IsPressed; }
    bool    get_IsHovered() final             { return _IsHovered; }
    bool    get_IsDragged() final             { return _IsDragged || ( _Parent !is null && _Parent.IsDragged ); }
    uint    get_ChildCount() final            { return _Children.length(); }
    Object@ get_Parent() final                { return _Parent; }
    Screen@ get_Screen() final                { return _Parent !is null ? _Parent.Screen : cast< Screen >( this ); }
    Grid@   get_Grid() final                  { return _Grid; }
    uint    get_CellIndex() final             { return _CellIndex; }

    bool    _ActiveSelf;
    string@ _Name;
    int     _BasePosX;
    int     _BasePosY;
    int     _BaseWidth;
    int     _BaseHeight;
    int     _AbsolutePosX;
    int     _AbsolutePosY;
    int     _Width;
    int     _Height;
    int     _Anchor;
    int     _Dock;
    bool    _IsDragged;
    bool    _IsDraggable;
    bool    _IsNotHittable;
    bool    _IsNotCatchable;
    bool    _CheckTransparentOnHit;
    bool    _DeferredMousePressed;
    bool    _IsFocused;
    bool    _IsPressed;
    bool    _IsHovered;
    int     _PressedButton;
    int     _PressedX;
    int     _PressedY;
    Object@ _Parent;
    Object@[] _Children;
    Grid@   _Grid;
    uint    _CellIndex;

    // Callbacks
    void OnConstruct()                                          {}
    void OnInit()                                               {}
    void OnShow()                                               {}
    void OnShow( dictionary@ params )                           {}
    void OnHide()                                               {}
    void OnAppear()                                             {}
    void OnDisappear()                                          {}
    void OnRemove()                                             {}
    void OnDraw()                                               {}
    void OnMove( int deltaX, int deltaY )                       {}
    void OnMouseDown( int button )                              {}
    void OnMouseUp( int button, bool lost )                     {}
    void OnMousePressed( int button )                           {}
    void OnLMousePressed()                                      {}
    void OnRMousePressed()                                      {}
    void OnMouseClick( int button )                             {}
    void OnLMouseClick()                                        {}
    void OnRMouseClick()                                        {}
    void OnMouseMove()                                          {}
    void OnGlobalMouseDown( int button )                        {}
    void OnGlobalMouseUp( int button )                          {}
    void OnGlobalMousePressed( int button )                     {}
    void OnGlobalMouseClick( int button )                       {}
    void OnGlobalMouseMove()                                    {}
    void OnInput()                                              {}
    void OnInput( uint8 key )                                   {}
    void OnInput( string& text )                                {}
    void OnInput( uint8 key, string@ text )                     {}
    void OnGlobalInput( uint8 key, string@ text )               {}
    void OnActiveChanged()                                      {}
    void OnFocusChanged()                                       {}
    void OnHoverChanged()                                       {}
    void OnDragChanged()                                        {}
    void OnResizeGrid( Object@ cell, uint cellIndex )           {}
    void OnDrawItem( Item@ item, Object@ cell, uint cellIndex ) {}

    void Init( Object@ parent )
    {
        _ActiveSelf = true;
        @_Name = reflection::typeof < Object > ( this ).nameWithoutNamespace;

        if( _Parent !is null )
            _Parent._Children.removeAt( _Parent._Children.findByRef( this ) );
        @_Parent = parent;
        if( parent !is null )
            parent._Children.insertLast( this );

        _Construct();

        Screen@ screen = Screen;
        if( screen !is null && screen._IsRegistered )
            _Init();
    }

    void _Construct()
    {
        OnConstruct();
    }

    void _Init()
    {
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._Init();
        OnInit();
        _RefreshPosition();
    }

    void _Show( dictionary@ params )
    {
        OnShow();
        OnShow( params );
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._Show( params );
    }

    void _Hide()
    {
        OnHide();
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._Hide();
    }

    void _Appear()
    {
        OnAppear();
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._Appear();
    }

    void _Disappear()
    {
        OnDisappear();
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._Disappear();
    }

    void _DragChanged()
    {
        OnDragChanged();
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._DragChanged();
    }

    void Remove()
    {
        if( _Parent !is null )
        {
            _Parent._Children.removeAt( _Parent._Children.findByRef( this ) );
            @_Parent = null;
        }

        _Remove();

        _ActiveSelf = false;
    }

    void _Remove()
    {
        OnRemove();
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._Remove();
    }

    void _Reload( bool reconstruct, bool refreshPosition )
    {
        if( reconstruct )
            OnConstruct();
        if( refreshPosition )
            _RefreshPosition();

        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._Reload( reconstruct, refreshPosition );
    }

    void _DrawCallback()
    {
        // Draw item callback
        if( _Grid !is null )
        {
            ItemView@ itemView = cast< ItemView >( _Grid );
            if( itemView !is null )
                OnDrawItem( itemView.GetItem( _CellIndex ), this, _CellIndex );
        }

        // Common draw callback
        OnDraw();
    }

    void _Draw( bool callCallback )
    {
        if( callCallback )
            _DrawCallback();

        // _Children
        for( uint i = 0; i < _Children.length(); i++ )
        {
            Object@ child = _Children[ i ];
            if( child._ActiveSelf && !child._IsDragged )
                child._Draw( true );
        }
    }

    void Draw( int x, int y )
    {
        int dx = x - _AbsolutePosX;
        int dy = y - _AbsolutePosY;
        _Move( dx, dy, false, false );
        _Draw( true );
        _Move( -dx, -dy, false, false );
    }

    void Move( int deltaX, int deltaY )
    {
        _Move( deltaX, deltaY, true, true );
    }

    void _Move( int deltaX, int deltaY, bool callCallback, bool moveBasePos )
    {
        _AbsolutePosX += deltaX;
        _AbsolutePosY += deltaY;

        if( moveBasePos )
        {
            _BasePosX += deltaX;
            _BasePosY += deltaY;
        }

        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._Move( deltaX, deltaY, false, false );

        if( callCallback )
            _MoveCallback( deltaX, deltaY );
    }

    void _MoveCallback( int deltaX, int deltaY )
    {
        OnMove( deltaX, deltaY );
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._MoveCallback( deltaX, deltaY );
    }

    bool _IsCatchable()
    {
        bool result = ( !_IsNotCatchable && !_IsDraggable && cast< Panel >( this ) !is null  && cast< Button >( this ) is null  && cast< Grid >( this ) is null );
        return result && ( Parent !is null ? Parent._IsCatchable() : true );
    }

    Object@ FindMouseHit()
    {
        return FindHit( __MouseX, __MouseY );
    }

    Object@ FindHit( int x, int y )
    {
        // Check children
        for( int i = int( _Children.length() ) - 1; i >= 0; i-- )
        {
            Object@ obj = _Children[ i ].FindHit( x, y );
            if( obj !is null )
                return obj;
        }

        // Check own
        if( IsHit( x, y ) )
            return this;

        // No collision found
        return null;
    }

    bool IsMouseHit()
    {
        return IsHit( __MouseX, __MouseY );
    }

    bool IsHit( int x, int y )
    {
        return Active && !_IsNotHittable && _Width > 0 && _Height > 0 &&
               IS_COLLISION( x, y, _AbsolutePosX, _AbsolutePosY, _Width, _Height ) && !_IsCropped( x, y );
    }

    bool _IsCropped( int x, int y )
    {
        Object@ obj = Parent;
        while( obj !is null )
        {
            Panel@ panel = cast< Panel >( obj );
            if( panel !is null && panel._CropContent && !IS_COLLISION( x, y, obj._AbsolutePosX, obj._AbsolutePosY, obj._Width, obj._Height ) )
                return true;
            @obj = obj.Parent;
        }
        return false;
    }

    void _GetWholeSizeRect( int[]& rect )
    {
        int l = _AbsolutePosX;
        int t = _AbsolutePosY;
        int r = l + Width;
        int b = t + Height;

        if( l < rect[ 0 ] )
            rect[ 0 ] = l;
        if( t < rect[ 1 ] )
            rect[ 1 ] = t;
        if( r > rect[ 2 ] )
            rect[ 2 ] = r;
        if( b > rect[ 3 ] )
            rect[ 3 ] = b;

        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._GetWholeSizeRect( rect );
    }

    void GetWholeSize( int& centerX, int& centerY, int& wholeWidth, int& wholeHeight, bool onlyChidren = false )
    {
        int[] rect = { 1000000000, 1000000000, -1000000000, -1000000000 };
        if( !onlyChidren )
        {
            _GetWholeSizeRect( rect );
        }
        else if( _Children.length() > 0 )
        {
            for( uint i = 0; i < _Children.length(); i++ )
                _Children[ i ]._GetWholeSizeRect( rect );
        }
        else
        {
            rect[ 0 ] = rect[ 1 ] = rect[ 2 ] = rect[ 3 ] = 0;
        }
        wholeWidth = rect[ 2 ] - rect[ 0 ];
        wholeHeight = rect[ 3 ] - rect[ 1 ];
        centerX = rect[ 0 ] + wholeWidth / 2;
        centerY = rect[ 1 ] + wholeHeight / 2;
    }

    void _MouseDown( int button )
    {
        _IsPressed = true;
        _PressedButton = button;
        _PressedX = __MouseX;
        _PressedY = __MouseY;
        OnMouseDown( button );

        if( _IsDraggable && _PressedButton == MOUSE_BUTTON_LEFT )
        {
            bool draggableCursor = ( __DraggableCursor != CursorType::Default && __Cursor == __DraggableCursor );
            if( draggableCursor )
            {
                _IsDragged = true;
                _DragChanged();
            }
        }

        if( !_DeferredMousePressed )
        {
            Screen._GlobalMousePressed( button );
            _MousePressed( button );
        }
    }

    void _MousePressed( int button )
    {
        OnMousePressed( button );
        if( button == MOUSE_BUTTON_LEFT )
            OnLMousePressed();
        else if( button == MOUSE_BUTTON_RIGHT )
            OnRMousePressed();

        _MousePressedUnder( button );
    }

    void _MousePressedUnder( int button )
    {
        if( Parent !is null )
            Parent._MousePressedUnder( button );
    }

    void _MouseUp( bool lost )
    {
        _IsPressed = false;

        if( _DeferredMousePressed )
        {
            Screen._GlobalMousePressed( _PressedButton );
            _MousePressed( _PressedButton );
        }

        OnMouseUp( _PressedButton, lost );

        if( _IsDragged )
        {
            _IsDragged = false;
            _DragChanged();
        }
    }

    void MouseClick( int button )
    {
        OnMouseClick( button );
        if( button == MOUSE_BUTTON_LEFT )
            OnLMouseClick();
        else if( button == MOUSE_BUTTON_RIGHT )
            OnRMouseClick();
    }

    void _MouseMove()
    {
        OnMouseMove();
    }

    void _GlobalMouseDown( int button )
    {
        OnGlobalMouseDown( button );
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._GlobalMouseDown( button );
    }

    void _GlobalMouseUp( int button )
    {
        OnGlobalMouseUp( button );
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._GlobalMouseUp( button );
    }

    void _GlobalMousePressed( int button )
    {
        OnGlobalMousePressed( button );
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._GlobalMousePressed( button );
    }

    void _GlobalMouseClick( int button )
    {
        OnGlobalMouseClick( button );
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._GlobalMouseClick( button );
    }

    void _GlobalMouseMove()
    {
        OnGlobalMouseMove();
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._GlobalMouseMove();
    }

    void Input( uint8 key, string@ text )
    {
        OnInput();
        if( text is null )
            OnInput( key );
        else
            OnInput( text );
        OnInput( key, text );
    }

    void _GlobalInput( uint8 key, string@ text )
    {
        OnGlobalInput( key, text );
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._GlobalInput( key, text );
    }

    void _Focus()
    {
        if( !_IsFocused )
        {
            _IsFocused = true;
            OnFocusChanged();
        }
    }

    void _Unfocus()
    {
        if( _IsFocused )
        {
            _IsFocused = false;
            OnFocusChanged();
        }
    }

    void _Hover()
    {
        if( !_IsHovered )
        {
            _IsHovered = true;
            OnHoverChanged();
        }
    }

    void _Unhover()
    {
        if( _IsHovered )
        {
            _IsHovered = false;
            OnHoverChanged();
        }
    }

    Object@ _Clone( Object@ parent )
    {
        Object@              newObject;
        reflection::typeof < Object > ( this ).instantiate( @this, @newObject );
        newObject._Children.clear();
        @newObject._Parent = parent;
        if( parent !is null )
            parent._Children.insertLast( newObject );
        newObject.OnConstruct();
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._Clone( newObject );
        return @newObject;
    }

    Panel@ FindPanel( string& name )
    {
        return cast< Panel >( Find( name ) );
    }

    Text@ FindText( string& name )
    {
        return cast< Text >( Find( name ) );
    }

    TextInput@ FindTextInput( string& name )
    {
        return cast< TextInput >( Find( name ) );
    }

    Button@ FindButton( string& name )
    {
        return cast< Button >( Find( name ) );
    }

    Object@ Find( string& name, bool deepFind = true )
    {
        for( uint i = 0; i < _Children.length(); i++ )
        {
            Object@ child = _Children[ i ];
            if( child._Name !is null && child._Name == name )
                return child;

            if( deepFind )
            {
                Object@ obj = child.Find( name );
                if( obj !is null )
                    return obj;
            }
        }
        return null;
    }

    Object@ GetChild( uint index )
    {
        return _Children[ index ];
    }

    void _RefreshPosition()
    {
        // Base data
        _Width = _BaseWidth;
        _Height = _BaseHeight;
        int parentAbsolutePosX = ( _Parent !is null ? _Parent._AbsolutePosX : 0 );
        int parentAbsolutePosY = ( _Parent !is null ? _Parent._AbsolutePosY : 0 );
        int parentWidth = ( _Parent !is null ? _Parent._Width : __ScreenWidth );
        int parentHeight = ( _Parent !is null ? _Parent._Height : __ScreenHeight );
        int parentBaseWidth = ( _Parent !is null ? _Parent._BaseWidth : _BaseWidth );
        int parentBaseHeight = ( _Parent !is null ? _Parent._BaseHeight : _BaseHeight );

        // Dock
        int newPosX;
        int newPosY;
        if( _Dock != 0 )
        {
            if( _Dock == DOCK_LEFT )
            {
                newPosX = parentAbsolutePosX;
                newPosY = parentAbsolutePosY;
                _Height = parentHeight;
            }
            else if( _Dock == DOCK_RIGHT )
            {
                newPosX = parentAbsolutePosX + parentWidth - _Width;
                newPosY = parentAbsolutePosY;
                _Height = parentHeight;
            }
            else if( _Dock == DOCK_TOP )
            {
                newPosX = parentAbsolutePosX;
                newPosY = parentAbsolutePosY;
                _Width = parentWidth;
            }
            else if( _Dock == DOCK_BOTTOM )
            {
                newPosX = parentAbsolutePosX;
                newPosY = parentAbsolutePosY + parentHeight - _Height;
                _Width = parentWidth;
            }
            else if( _Dock == DOCK_FILL )
            {
                newPosX = parentAbsolutePosX;
                newPosY = parentAbsolutePosY;
                _Width = parentWidth;
                _Height = parentHeight;
            }
            else
            {
                newPosX = _BasePosX + parentAbsolutePosX;
                newPosY = _BasePosY + parentAbsolutePosY;
            }
        }
        // Anchor
        else
        {
            if( ( _Anchor & ANCHOR_LEFT ) != 0 )
                newPosX = parentAbsolutePosX + _BasePosX;
            else if( ( _Anchor & ANCHOR_RIGHT ) != 0 )
                newPosX = parentAbsolutePosX + _BasePosX + ( parentWidth - parentBaseWidth );
            else
                newPosX = parentAbsolutePosX + _BasePosX + ( parentWidth - parentBaseWidth ) / 2;

            if( ( _Anchor & ANCHOR_TOP ) != 0 )
                newPosY = parentAbsolutePosY + _BasePosY;
            else if( ( _Anchor & ANCHOR_BOTTOM ) != 0 )
                newPosY = parentAbsolutePosY + _BasePosY + ( parentHeight - parentBaseHeight );
            else
                newPosY = parentAbsolutePosY + _BasePosY + ( parentHeight - parentBaseHeight ) / 2;
        }

        // Move control
        if( newPosX != _AbsolutePosX || newPosY != _AbsolutePosY )
            _Move( newPosX - _AbsolutePosX, newPosY - _AbsolutePosY, false, false );
    }

    void _SizeChanged()
    {
        // Internal callback
    }

    // Options
    void SetName( string@ name )
    {
        @_Name = name;
    }

    void SetActive( bool active )
    {
        if( _ActiveSelf != active )
        {
            _ActiveSelf = active;
            _ActiveChanged();
        }
    }

    void _ActiveChanged()
    {
        OnActiveChanged();
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._ActiveChanged();
    }

    void SetPosition( int x, int y )
    {
        if( _BasePosX == x && _BasePosY == y )
            return;

        _BasePosX = x;
        _BasePosY = y;
        _RefreshPosition();
    }

    void SetSize( int w, int h )
    {
        if( _BaseWidth == w && _BaseHeight == h )
            return;

        _BaseWidth = w;
        _BaseHeight = h;
        _RefreshPosition();
        _SizeChanged();
    }

    void SetAnchor( int anchorStyles )
    {
        if( _Anchor == anchorStyles )
            return;

        _Anchor = anchorStyles;
        _RefreshPosition();
    }

    void SetDock( int dockStyle )
    {
        if( _Dock == dockStyle )
            return;

        _Dock = dockStyle;
        _RefreshPosition();
    }

    void SetDraggable( bool enabled )
    {
        _IsDraggable = enabled;
    }

    void SetNotHittable( bool enabled )
    {
        _IsNotHittable = enabled;
    }

    void SetNotCatchable( bool enabled )
    {
        _IsNotCatchable = enabled;
    }

    void SetCheckTransparentOnHit( bool enabled )
    {
        _CheckTransparentOnHit = enabled;
    }

    void SetDeferredMousePressed( bool enabled )
    {
        _DeferredMousePressed = enabled;
    }
}

/*EXPORT*/ class Panel : Object
{
    Sprite@ get_BackgroundImage() final         { return _BackgroundImage; }
    int     get_BackgroundImageLayout() final   { return _BackgroundImage !is null ? _BackgroundImage.Layout : IMAGE_LAYOUT_NONE; }
    bool    get_IsVerticalScroll() final        { return _IsVerticalScroll; }
    bool    get_IsHorizontalScroll() final      { return _IsHorizontalScroll; }
    int     get_VerticalScrollPercent() final   { return _VerticalScrollPercent; }
    int     get_HorizontalScrollPercent() final { return _HorizontalScrollPercent; }

    Sprite@ _BackgroundImage;
    bool    _CropContent;
    bool    _IsVerticalScroll;
    bool    _IsHorizontalScroll;
    int     _VerticalScroll;
    int     _HorizontalScroll;
    int     _VerticalScrollPercent;
    int     _HorizontalScrollPercent;

    bool IsHit( int x, int y ) override
    {
        if( Object::IsHit( x, y ) )
        {
            if( _CheckTransparentOnHit && _BackgroundImage !is null )
                return ( GetPixelColor( _BackgroundImage.Id, _BackgroundImage.Frame, x - _AbsolutePosX, y - _AbsolutePosY ) & 0xFF000000 ) != 0;
            return true;
        }
        return false;
    }

    void _Draw( bool callCallback ) override
    {
        _ModifyScroll( 0, 0 );

        bool crop = _CropContent;
        if( crop )
            PushDrawScissor( AbsolutePosX, AbsolutePosY, Width, Height );

        if( callCallback )
            _DrawCallback();

        // Normal sprite
        if( _BackgroundImage !is null )
            _DrawImage( _BackgroundImage );

        Object::_Draw( false );

        if( crop )
            PopDrawScissor();
    }

    void _DrawImage( Sprite@ image )
    {
        if( _Width > 0 && _Height > 0 )
            image.Draw( _AbsolutePosX, _AbsolutePosY, _Width, _Height );
    }

    void SetBackgroundImage( string@ imageName, int imageLayout = IMAGE_LAYOUT_NONE )
    {
        _SetImage( _BackgroundImage, imageName, imageLayout );
    }

    void SetBackgroundImage( uint imageNameHash, int imageLayout = IMAGE_LAYOUT_NONE )
    {
        _SetImage( _BackgroundImage, imageNameHash, imageLayout );
    }

    void _SetImage( Sprite@& curImage, string@ imageName, int imageLayout )
    {
        @curImage = null;
        if( imageName !is null )
        {
            Sprite spr;
            spr.Load( imageName );
            if( spr.Id != 0 )
                @curImage = spr;
        }

        if( curImage !is null )
            curImage.Layout = imageLayout;

        if( curImage !is null && ( imageLayout == IMAGE_LAYOUT_NONE || ( _BaseWidth == 0 && _BaseHeight == 0 ) ) )
            SetSize( curImage.Width, curImage.Height );
    }

    void _SetImage( Sprite@& curImage, uint imageNameHash, int imageLayout )
    {
        if( curImage !is null && curImage.LoadedNameHash == imageNameHash )
            return;

        @curImage = null;
        if( imageNameHash != 0 )
        {
            Sprite spr;
            spr.Load( imageNameHash );
            if( spr.Id != 0 )
                @curImage = spr;
        }

        if( curImage !is null )
            curImage.Layout = imageLayout;

        if( curImage !is null && ( imageLayout == IMAGE_LAYOUT_NONE || ( _BaseWidth == 0 && _BaseHeight == 0 ) ) )
            SetSize( curImage.Width, curImage.Height );
    }

    void _MousePressedUnder( int button ) override
    {
        if( _IsVerticalScroll && ( button == MOUSE_BUTTON_WHEEL_UP || button == MOUSE_BUTTON_WHEEL_DOWN ) )
        {
            int dy = 0;
            if( button == MOUSE_BUTTON_WHEEL_UP )
                dy = -1;
            else if( button == MOUSE_BUTTON_WHEEL_DOWN )
                dy = 1;

            if( dy != 0 )
                _ModifyScroll( dy * 10, 0 );

            // Stop processing
            return;
        }

        Object::_MousePressedUnder( button );
    }

    void ModifyScroll( int ver, int hor )
    {
        _ModifyScroll( ver, hor );
    }

    bool CanModifyScroll( int ver, int hor )
    {
        return _ModifyScroll( ver, hor, true );
    }

    void SetScrollPercent( int verPercent, int horPercent )
    {
        if( !_IsVerticalScroll && !_IsHorizontalScroll )
            return;

        int maxVerScroll = 0, maxHorScroll = 0;
        _GetScrollableSize( maxVerScroll, maxHorScroll );

        int newVer = ( maxVerScroll > 0 ? maxVerScroll * verPercent / 100 : 0 );
        int newHor = ( maxHorScroll > 0 ? maxHorScroll * horPercent / 100 : 0 );

        if( newVer != _VerticalScroll || newHor != _HorizontalScroll )
            _ModifyScroll( newVer - _VerticalScroll, newHor - _HorizontalScroll );
    }

    bool _ModifyScroll( int ver, int hor, bool onlyCheck = false )
    {
        if( !_IsVerticalScroll && !_IsHorizontalScroll )
            return false;

        int curVer = _VerticalScroll;
        int curHor = _HorizontalScroll;
        int oldVer = curVer;
        int oldHor = curHor;

        if( _IsVerticalScroll )
            curVer += ver;
        if( _IsHorizontalScroll )
            curHor += hor;

        int maxVerScroll = 0, maxHorScroll = 0;
        _GetScrollableSize( maxVerScroll, maxHorScroll );

        if( _IsVerticalScroll )
        {
            if( curVer > maxVerScroll )
                curVer = maxVerScroll;
            if( curVer < 0 )
                curVer = 0;
        }
        if( _IsHorizontalScroll )
        {
            if( curHor > maxHorScroll )
                curHor = maxHorScroll;
            if( curHor < 0 )
                curHor = 0;
        }

        if( !onlyCheck || ( ver == 0 && hor == 0 ) )
        {
            _VerticalScrollPercent = ( maxVerScroll > 0 ? curVer * 100 / maxVerScroll : 0 );
            _HorizontalScrollPercent = ( maxHorScroll > 0 ? curHor * 100 / maxHorScroll : 0 );
        }

        if( curVer != oldVer || curHor != oldHor )
        {
            if( !onlyCheck )
            {
                _VerticalScroll = curVer;
                _HorizontalScroll = curHor;
                for( uint i = 0; i < _Children.length(); i++ )
                    _Children[ i ]._Move( -( curHor - oldHor ), -( curVer - oldVer ), true, false );
            }
            return true;
        }
        return false;
    }

    void _GetScrollableSize( int& maxVerScroll, int& maxHorScroll )
    {
        if( !_IsVerticalScroll && !_IsHorizontalScroll )
            return;

        int centerX = 0, centerY = 0, wholeWidth = 0, wholeHeight = 0;
        GetWholeSize( centerX, centerY, wholeWidth, wholeHeight, true );
        if( _IsVerticalScroll )
            maxVerScroll = wholeHeight - Height + ( ( centerY + _VerticalScroll ) - wholeHeight / 2 - AbsolutePosY );
        if( _IsHorizontalScroll )
            maxHorScroll = wholeWidth - Width + ( ( centerX + _HorizontalScroll ) - wholeWidth / 2 - AbsolutePosX );
    }

    void SetCropContent( bool enabled )
    {
        _CropContent = enabled;
    }

    void SetAutoScroll( bool ver, bool hor )
    {
        _IsVerticalScroll = ver;
        _IsHorizontalScroll = hor;
    }
}

/*EXPORT*/ class Text : Object
{
    string@ get_Text()                   { return _Text; }
    int     get_TextFont() final         { return _TextFont; }
    uint    get_TextColor() final        { return _TextColor; }
    uint    get_TextColorFocused() final { return _TextColorFocused; }
    int     get_TextFlags() final        { return _TextFlags; }

    string _Text;
    int    _TextFont = FONT_DEFAULT;
    uint   _TextColor = COLOR_TEXT;
    uint   _TextColorFocused;
    int    _TextFlags;

    void _Draw( bool callCallback ) override
    {
        if( callCallback )
            _DrawCallback();

        // Text
        string@ text = Text;
        if( text.length() > 0 )
        {
            uint color = ( _IsFocused && _TextColorFocused != 0 ? _TextColorFocused : _TextColor );
            DrawText( text, _AbsolutePosX, _AbsolutePosY, _Width, _Height, color, _TextFont, _TextFlags );
        }

        Object::_Draw( false );
    }

    void SetText( string@ text, int font, int flags )
    {
        if( text !is null )
            _Text = text;
        else
            _Text = "";

        _TextFont = font;
        _TextFlags = flags;
    }

    void SetText( string@ text )
    {
        if( text !is null )
            _Text = text;
        else
            _Text = "";
    }

    void SetTextWithResize( string@ text )
    {
        int tw = 0, th = 0, lines = 0;
        GetTextInfo( text, Width, 1000, _TextFont, _TextFlags, tw, th, lines );
        SetSize( _Width, th + 5 );
        SetText( text );
    }

    void SetTextFont( int font )
    {
        _TextFont = font;
    }

    void SetTextFlags( int flags )
    {
        _TextFlags = flags;
    }

    void SetTextColor( uint color )
    {
        _TextColor = color;
    }

    void SetTextFocusedColor( uint color )
    {
        _TextColorFocused = color;
    }
}

#define PASSWORD_SHOW_TIME    ( 1000 )
/*EXPORT*/ class TextInput : Text
{
    uint   get_InputLength() final    { return _InputLength; }
    bool   get_IsTextPassword() final { return _IsTextPassword; }
    string get_PasswordChar() final   { return _PasswordChar; }

    uint   _InputLength;
    bool   _IsTextPassword;
    string _PasswordChar;
    uint   _PasswordTime;
    int    _CarriagePos;

    void _Construct() override
    {
        SetCarriage( false );
        _TextColorFocused = COLOR_TEXT_FOCUSED;

        Text::_Construct();
    }

    void _Draw( bool callCallback ) override
    {
        if( callCallback )
            _DrawCallback();

        // Text
        string@ text = Text;
        if( _IsTextPassword && text.length() > 0 )
        {
            string@ rawText = text;
            @text = "";
            for( uint i = 0; i < rawText.length(); i++ )
                text += _PasswordChar;
            if( GetTick() - _PasswordTime <= PASSWORD_SHOW_TIME )
                text[ -1 ] = rawText[ -1 ];
        }
        if( _CarriagePos != -1 && _IsFocused )
        {
            if( _CarriagePos < 0 )
                _CarriagePos = 0;
            if( _CarriagePos > int( text.length() ) )
                _CarriagePos = text.length();
            @text = text.substring( 0, _CarriagePos ) + ( GetTick() % 800 < 400 ? "!" : "." ) + text.substring( _CarriagePos );
        }
        if( text.length() > 0 )
        {
            uint color = ( _IsFocused && _TextColorFocused != 0 ? _TextColorFocused : _TextColor );
            DrawText( text, _AbsolutePosX, _AbsolutePosY, _Width, _Height, color, _TextFont, _TextFlags );
        }

        Object::_Draw( false );
    }

    void Input( uint8 key, string@ text ) override
    {
        uint oldLen = _Text.length();
        _ProcessKey( key, text, _Text, _CarriagePos );
        while( _InputLength != 0 && _Text.length() > _InputLength )
            _Text[ -1 ] = "";
        if( _IsTextPassword )
            _PasswordTime = ( _Text.length() > oldLen ? GetTick() : 0 );

        Text::Input( key, text );
    }

    bool _ProcessKey( uint8 key, string@ text, string& resultText, int& carriagePos )
    {
        if( carriagePos != -1 )
        {
            if( carriagePos < 0 )
                carriagePos = 0;
            else if( carriagePos > int( resultText.length() ) )
                carriagePos = resultText.length();

            if( key == DIK_BACK )
            {
                if( carriagePos > 0 )
                {
                    resultText[ carriagePos - 1 ] = "";
                    carriagePos--;
                }
            }
            else if( key == DIK_DELETE )
            {
                if( carriagePos < int( resultText.length() ) )
                    resultText[ carriagePos ] = "";
            }
            else if( key == DIK_RIGHT )
            {
                if( carriagePos < int( resultText.length() ) )
                    carriagePos++;
            }
            else if( key == DIK_LEFT )
            {
                if( carriagePos > 0 )
                    carriagePos--;
            }
            else if( key == DIK_HOME )
            {
                carriagePos = 0;
            }
            else if( key == DIK_END )
            {
                carriagePos = resultText.length();
            }
            else if( text !is null )
            {
                resultText = resultText.substring( 0, carriagePos ) + text + resultText.substring( carriagePos );
                carriagePos += text.length();
            }
            else
            {
                return false;
            }
        }
        else
        {
            if( key == DIK_BACK )
            {
                if( resultText.length() > 0 )
                    resultText[ -1 ] = "";
            }
            else if( text !is null )
            {
                resultText += text;
            }
            else
            {
                return false;
            }
        }
        return true;
    }

    void SetInputLength( uint length )
    {
        _InputLength = length;
    }

    void SetInputPassword( string@ passwordChar )
    {
        _IsTextPassword = ( @passwordChar != null && passwordChar.length() == 1 );
        _PasswordChar = passwordChar;
        _PasswordTime = 0;
    }

    void SetCarriage( bool enable )
    {
        _CarriagePos = ( enable ? int( _Text.length() ) : -1 );
    }
}

/*EXPORT*/ class Button : Panel
{
    bool    get_IsDisabled() final          { return _IsDisabled; }
    bool    get_IsSwitched() final          { return _IsSwitched; }
    Sprite@ get_PressedImage() final        { return _PressedImage; }
    int     get_PressedImageLayout() final  { return _PressedImage !is null ? _PressedImage.Layout : IMAGE_LAYOUT_NONE; }
    Sprite@ get_HoverImage() final          { return _HoverImage; }
    int     get_HoverImageLayout() final    { return _HoverImage !is null ? _HoverImage.Layout : IMAGE_LAYOUT_NONE; }
    Sprite@ get_DisabledImage() final       { return _DisabledImage; }
    int     get_DisabledImageLayout() final { return _DisabledImage !is null ? _DisabledImage.Layout : IMAGE_LAYOUT_NONE; }

    bool    _IsDisabled;
    bool    _IsSwitched;
    Sprite@ _PressedImage;
    Sprite@ _HoverImage;
    Sprite@ _DisabledImage;

    void _Construct() override
    {
        _DeferredMousePressed = true;

        Panel::_Construct();
    }

    void _Draw( bool callCallback ) override
    {
        if( callCallback )
            _DrawCallback();

        if( !_IsDisabled )
        {
            // Pressed image
            bool isPressed = ( ( _IsPressed && _PressedButton == MOUSE_BUTTON_LEFT ) || _IsSwitched );
            if( isPressed && _PressedImage !is null )
                _DrawImage( _PressedImage );
            // Hover image
            else if( _IsHovered && _HoverImage !is null )
                _DrawImage( _HoverImage );
            // Normal image
            else if( _BackgroundImage !is null )
                _DrawImage( _BackgroundImage );
        }
        else
        {
            // Disabled image
            if( _DisabledImage !is null )
                _DrawImage( _DisabledImage );
            // Normal image
            else if( _BackgroundImage !is null )
                _DrawImage( _BackgroundImage );
        }

        Object::_Draw( false );
    }

    void MouseClick( int button )
    {
        if( _IsDisabled )
            return;

        Panel::MouseClick( button );
    }

    void _MousePressed( int button )
    {
        if( _IsDisabled )
            return;

        Panel::_MousePressed( button );
    }

    void SetPressedImage( string@ imageName, int imageLayout = IMAGE_LAYOUT_NONE )
    {
        _SetImage( _PressedImage, imageName, imageLayout );
    }

    void SetPressedImage( uint imageNameHash, int imageLayout = IMAGE_LAYOUT_NONE )
    {
        _SetImage( _PressedImage, imageNameHash, imageLayout );
    }

    void SetHoverImage( string@ imageName, int imageLayout = IMAGE_LAYOUT_NONE )
    {
        _SetImage( _HoverImage, imageName, imageLayout );
    }

    void SetHoverImage( uint imageNameHash, int imageLayout = IMAGE_LAYOUT_NONE )
    {
        _SetImage( _HoverImage, imageNameHash, imageLayout );
    }

    void SetDisabledImage( string@ imageName, int imageLayout = IMAGE_LAYOUT_NONE )
    {
        _SetImage( _DisabledImage, imageName, imageLayout );
    }

    void SetDisabledImage( uint imageNameHash, int imageLayout = IMAGE_LAYOUT_NONE )
    {
        _SetImage( _DisabledImage, imageNameHash, imageLayout );
    }

    void SetSwitch( bool enabled )
    {
        _IsSwitched = enabled;
    }

    void SetCondition( bool enabled )
    {
        _IsDisabled = !enabled;
    }
}

/*EXPORT*/ class CheckBox : Button
{
    bool get_IsChecked() final { return _IsSwitched; }

    // Callbacks
    void OnCheckedChanged() {}

    void MouseClick( int button )
    {
        if( _IsDisabled )
            return;

        if( button == MOUSE_BUTTON_LEFT )
            SetChecked( !_IsSwitched );

        Panel::MouseClick( button );
    }

    void SetChecked( bool checked )
    {
        if( _IsSwitched != checked )
        {
            _IsSwitched = checked;
            OnCheckedChanged();
        }
    }
}

/*EXPORT*/ class RadioButton : CheckBox
{
    void MouseClick( int button )
    {
        if( _IsDisabled || _IsSwitched )
            return;

        if( button == MOUSE_BUTTON_LEFT )
            SetChecked( true );

        Panel::MouseClick( button );
    }

    void SetChecked( bool checked ) override
    {
        if( checked && _Parent !is null )
        {
            for( uint i = 0; i < _Parent._Children.length(); i++ )
            {
                RadioButton@ button = cast< RadioButton >( _Parent._Children[ i ] );
                if( button !is null && button._IsSwitched )
                {
                    button._IsSwitched = false;
                    button.OnCheckedChanged();
                }
            }
        }

        if( _IsSwitched != checked )
        {
            _IsSwitched = checked;
            OnCheckedChanged();
        }
    }
}

/*EXPORT*/ class Screen : Panel
{
    int          get_Index() final               { return _Index; }
    bool         get_IsHardcoded() final         { return _IsHardcoded; }
    bool         get_IsMain() final              { return IS_CLIENT_MAIN_SCREEN( _Index ); }
    bool         get_IsModal() final             { return _IsModal; }
    bool         get_IsMultiinstance() final     { return _IsMultiinstance; }
    bool         get_IsCloseOnMiss() final       { return _IsCloseOnMiss; }
    CursorType[] get_AvailableCursors() final    { return _AvailableCursors; }
    CursorType   get_Cursor() final              { return _Cursor; }
    bool         get_IsCanMove() final           { return _IsCanMove; }
    bool         get_IsMoveIgnoreBorders() final { return _IsMoveIgnoreBorders; }
    bool         get_IsOnTop() final             { return _IsOnTop; }

    int        _Index;
    bool       _IsHardcoded;
    bool       _IsRegistered;
    bool       _IsModal;
    bool       _IsMultiinstance;
    bool       _IsCloseOnMiss;
    CursorType[] _AvailableCursors;
    CursorType _Cursor;
    bool       _IsCanMove;
    bool       _IsMoveIgnoreBorders;
    bool       _IsOnTop;

    // Workaround for input state accessing from shared code
    bool[] @ _InputKeyPressed;
    bool[] @ _InputMousePressed;

    void _Show( dictionary@ params ) override
    {
        // Make screen active
        _ActiveSelf = true;

        // Set default cursor
        _Cursor = ( _AvailableCursors.length() > 0 ? AvailableCursors[ 0 ] : CursorType::Default );

        // Base behaviour
        Panel::_Show( params );
    }

    void _Hide() override
    {
        // Make screen active
        _ActiveSelf = false;

        // Base behaviour
        Panel::_Hide();
    }

    void _Appear() override
    {
        // On top
        _IsOnTop = true;

        // Set screen cursor
        __Cursor = _Cursor;

        // Base behaviour
        Panel::_Appear();
    }

    void _Disappear() override
    {
        // Not on top more
        _IsOnTop = false;

        // Store cursor
        _Cursor = __Cursor;
        if( _AvailableCursors.find( _Cursor ) == -1 )
            _Cursor = ( _AvailableCursors.length() > 0 ? AvailableCursors[ 0 ] : CursorType::Default );

        // Base behaviour
        Panel::_Disappear();
    }

    void _GlobalMouseClick( int button ) override
    {
        if( button == MOUSE_BUTTON_RIGHT )
        {
            if( _AvailableCursors.length() > 0 )
            {
                CursorType curCursor = __Cursor;
                int        curCursorIndex = _AvailableCursors.find( curCursor );
                if( curCursorIndex != -1 )
                {
                    curCursorIndex++;
                    if( curCursorIndex >= int( _AvailableCursors.length() ) )
                        curCursorIndex = 0;
                    __Cursor = _AvailableCursors[ curCursorIndex ];
                }
            }
        }
        else
        {
            Panel::_GlobalMouseClick( button );
        }
    }

    void _GlobalMouseMove() override
    {
        // Process moving
        if( _IsCanMove )
        {
            Object@ pressedObj = _FindPressed( this );
            if( pressedObj !is null && pressedObj._PressedButton == MOUSE_BUTTON_LEFT && pressedObj._IsCatchable() )
            {
                int lastPosX = _AbsolutePosX;
                int lastPosY = _AbsolutePosY;
                int newPosX = _AbsolutePosX + ( __MouseX - pressedObj._PressedX );
                int newPosY = _AbsolutePosY + ( __MouseY - pressedObj._PressedY );
                pressedObj._PressedX = __MouseX;
                pressedObj._PressedY = __MouseY;

                // Check screen borders
                if( !_IsMoveIgnoreBorders )
                {
                    int parentAbsolutePosX = ( _Parent !is null ? _Parent._AbsolutePosX : 0 );
                    int parentAbsolutePosY = ( _Parent !is null ? _Parent._AbsolutePosY : 0 );
                    int parentWidth = ( _Parent !is null ? _Parent._Width : __ScreenWidth );
                    int parentHeight = ( _Parent !is null ? _Parent._Height : __ScreenHeight );
                    int px = newPosX;
                    int py = newPosY;
                    if( newPosX < parentAbsolutePosX )
                        newPosX = parentAbsolutePosX;
                    if( newPosY < parentAbsolutePosY )
                        newPosY = parentAbsolutePosY;
                    if( newPosX + _Width > parentWidth )
                        newPosX = parentWidth - _Width;
                    if( newPosY + _Height > parentHeight )
                        newPosY = parentHeight - _Height;
                    pressedObj._PressedX += newPosX - px;
                    pressedObj._PressedY += newPosY - py;
                }

                // Callback
                if( lastPosX != newPosX || lastPosY != newPosY )
                {
                    int deltaX = newPosX - lastPosX;
                    int deltaY = newPosY - lastPosY;
                    _Move( deltaX, deltaY, true, true );
                }
            }
        }

        Panel::_GlobalMouseMove();
    }

    Object@ _FindPressed( Object@ obj )
    {
        if( obj._IsPressed )
            return obj;
        for( uint i = 0; i < obj._Children.length(); i++ )
        {
            Object@ pressedObj = _FindPressed( obj._Children[ i ] );
            if( pressedObj !is null )
                return pressedObj;
        }
        return null;
    }

    // Options
    void SetModal( bool enabled )
    {
        _IsModal = enabled;
    }

    void SetMultiinstance( bool enabled )
    {
        _IsMultiinstance = enabled;
    }

    void SetCloseOnMiss( bool enabled )
    {
        _IsCloseOnMiss = enabled;
    }

    void SetAvailableCursors( CursorType[] cursors )
    {
        _AvailableCursors = cursors;
    }

    void SetCanMove( bool enabled, bool ignoreBorders )
    {
        _IsCanMove = enabled;
        _IsMoveIgnoreBorders = ignoreBorders;
    }
}

/*EXPORT*/ class Grid : Panel
{
    string@   get_CellPrototype() final { return _CellPrototype; }
    uint      get_GridSize() final      { return _GridSize; }
    int       get_Columns() final       { return _Columns; }
    int       get_PaddingX() final      { return _PaddingX; }
    int       get_PaddingY() final      { return _PaddingY; }
    Object@[] get_Cells() final         { return _Cells; }

    string@ _CellPrototype;
    uint    _GridSize;
    int     _Columns;
    int     _PaddingX;
    int     _PaddingY;
    Object@[] _Cells;

    void _Init() override
    {
        Panel::_Init();

        if( _CellPrototype !is null )
            SetCellPrototype( _CellPrototype );

        if( _GridSize > 0 )
            ResizeGrid( _GridSize );
    }

    void ResizeGrid( uint size )
    {
        // Refresh grid size
        _GridSize = size;

        // Find cell prototype
        if( _CellPrototype is null || _CellPrototype.length() == 0 )
            return;
        Object@ cellPrototype = ( _CellPrototype[ 0 ] != "." ? Find( _CellPrototype ) : Parent.Find( _CellPrototype.substring( 1 ), false ) );
        if( cellPrototype is null )
            return;

        // Get cell index
        int childIndex = -1;
        if( cellPrototype._Parent is this )
            childIndex = cellPrototype._Parent._Children.findByRef( cellPrototype );

        // Remove current instances
        for( uint i = 0; i < _Children.length();)
        {
            if( _Cells.findByRef( _Children[ i ] ) != -1 )
                _Children.removeAt( i );
            else
                i++;
        }
        _Cells.clear();

        // Create new intsances
        cellPrototype._ActiveSelf = true;
        Object@[] cellInstances;
        for( uint i = 0; i < _GridSize; i++ )
        {
            Object@ cellInstance = cellPrototype._Clone( this );
            _Children.removeLast();
            _Children.insertAt( ++childIndex, cellInstance );
            _Cells.insertLast( cellInstance );
            _SetCellIndex( cellInstance, this, cellInstances.length() );
            cellInstances.insertLast( cellInstance );
        }
        cellPrototype._ActiveSelf = false;

        // Callbacks
        for( uint i = 0; i < cellInstances.length(); i++ )
        {
            OnResizeGrid( cellInstances[ i ], i );
            _ResizeGrid( cellInstances[ i ], cellInstances[ i ], i );
        }

        // Init
        for( uint i = 0; i < cellInstances.length(); i++ )
            cellInstances[ i ]._Init();

        // Move
        int col = 0, row = 0;
        int rowHeight = 0;
        int shiftX = -_HorizontalScroll;
        int shiftY = -_VerticalScroll;
        for( uint i = 0; i < cellInstances.length(); i++ )
        {
            cellInstances[ i ]._Move( shiftX, shiftY, false, true );
            shiftX += cellInstances[ i ]._Width + _PaddingX;
            if( rowHeight < cellInstances[ i ]._Height + _PaddingY )
                rowHeight = cellInstances[ i ]._Height + _PaddingY;
            if( ++col >= _Columns )
            {
                col = 0;
                row++;
                shiftX = 0;
                shiftY += rowHeight;
                rowHeight = 0;
            }
        }
        _ModifyScroll( 0, 0 );
    }

    void RefreshContentPositions()
    {
        if( _Cells.length() == 0 )
            return;

        int col = 0, row = 0;
        int rowHeight = 0;
        int shiftX = -_HorizontalScroll;
        int shiftY = -_VerticalScroll;
        int baseX = _Cells[ 0 ]._BasePosX - _HorizontalScroll;
        int baseY = _Cells[ 0 ]._BasePosY - _VerticalScroll;
        for( uint i = 0; i < _Cells.length(); i++ )
        {
            int ox = shiftX - _Cells[ i ]._BasePosX + baseX;
            int oy = shiftY - _Cells[ i ]._BasePosY + baseY;
            if( ox != 0 || oy != 0 )
                _Cells[ i ]._Move( ox, oy, false, true );
            shiftX += _Cells[ i ]._Width + _PaddingX;
            if( rowHeight < _Cells[ i ]._Height + _PaddingY )
                rowHeight = _Cells[ i ]._Height + _PaddingY;
            if( ++col >= _Columns )
            {
                col = 0;
                row++;
                shiftX = 0;
                shiftY += rowHeight;
                rowHeight = 0;
            }
        }
        _ModifyScroll( 0, 0 );
    }

    void _SetCellIndex( Object@ obj, Grid@ grid, uint cellIndex )
    {
        @obj._Grid = grid;
        obj._CellIndex = cellIndex;

        for( uint i = 0; i < obj._Children.length(); i++ )
            _SetCellIndex( obj._Children[ i ], grid, cellIndex );
    }

    void _ResizeGrid( Object@ obj, Object@ cell, uint cellIndex )
    {
        obj.OnResizeGrid( cell, cellIndex );

        for( uint i = 0; i < obj._Children.length(); i++ )
            _ResizeGrid( obj._Children[ i ], cell, cellIndex );
    }

    void SetCellPrototype( string name )
    {
        @_CellPrototype = name;
        if( _CellPrototype !is null && _CellPrototype.length() > 0 )
        {
            Object@ cellPrototype = ( _CellPrototype[ 0 ] != "." ? Find( _CellPrototype ) : Parent.Find( _CellPrototype.substring( 1 ), false ) );
            if( cellPrototype !is null )
                cellPrototype._ActiveSelf = false;
        }
    }

    void SetGridSize( uint size )
    {
        _GridSize = size;
    }

    void SetColumns( int length )
    {
        _Columns = length;
    }

    void SetPadding( int x, int y )
    {
        _PaddingX = x;
        _PaddingY = y;
    }
}

/*EXPORT*/ class MessageBox : Text
{
    string[] get_MessageTexts() final      { return _MessageTexts; }
    int[]    get_MessageTypes() final      { return _MessageTypes; }
    string[] get_MessageTimes() final      { return _MessageTimes; }
    bool[]   get_DisplayedMessages() final { return _DisplayedMessages; }
    bool     get_InvertMessages() final    { return _InvertMessages; }

    string[] _MessageTexts;
    int[]    _MessageTypes;
    string[] _MessageTimes;
    bool[]   _DisplayedMessages;
    bool   _InvertMessages;
    int    _Scroll;
    int    _MaxScroll;
    int    _ScrollLines;
    Sprite _ScrollUp;
    Sprite _ScrollDown;

    void _Construct() override
    {
        _DisplayedMessages = array< bool >( FOMB_ALL, true );

        _ScrollUp.Load( "MiniArrowUp.png" );
        _ScrollDown.Load( "MiniArrowDown.png" );

        Text::_Construct();
    }

    void _Show( dictionary@ params ) override
    {
        Text::_Show( params );

        _InvertMessages = __MsgboxInvert;
        _GenerateText();
    }

    void _Draw( bool callCallback ) override
    {
        if( !_InvertMessages )
            _TextFlags = FT_UPPER | FT_BOTTOM | FT_SKIPLINES_END( _ScrollLines );
        else
            _TextFlags = FT_SKIPLINES( _ScrollLines );

        Text::_Draw( callCallback );

        if( _IsHovered )
        {
            Sprite@ spr = ( __MouseY < _AbsolutePosY + _Height / 2 ? _ScrollUp : _ScrollDown );
            spr.Draw( __MouseX - spr.Width / 2, __MouseY - spr.Height / 2 );
        }
    }

    void _Remove() override
    {
        __HideCursor = false;

        Text::_Remove();
    }

    void _Hover() override
    {
        Text::_Hover();

        __HideCursor = true;
    }

    void _Unhover() override
    {
        Text::_Unhover();

        __HideCursor = false;
    }

    void _SizeChanged() override
    {
        _GenerateText();

        Text::_SizeChanged();
    }

    void _ActiveChanged() override
    {
        if( Active )
            _GenerateText();

        Text::_ActiveChanged();
    }

    void _MousePressed( int button ) override
    {
        if( button == MOUSE_BUTTON_LEFT || button == MOUSE_BUTTON_WHEEL_UP || button == MOUSE_BUTTON_WHEEL_DOWN )
        {
            if( button == MOUSE_BUTTON_WHEEL_UP || ( button == MOUSE_BUTTON_LEFT && __MouseY < _AbsolutePosY + _Height / 2 ) )
            {
                if( _InvertMessages && _Scroll > 0 )
                    _Scroll--;
                if( !_InvertMessages && _Scroll < _MaxScroll )
                    _Scroll++;
            }
            else if( button == MOUSE_BUTTON_WHEEL_DOWN || ( button == MOUSE_BUTTON_LEFT && __MouseY >= _AbsolutePosY + _Height / 2 ) )
            {
                if( _InvertMessages && _Scroll < _MaxScroll )
                    _Scroll++;
                if( !_InvertMessages && _Scroll > 0 )
                    _Scroll--;
            }
            _GenerateText();
        }

        Text::_MousePressed( button );
    }

    void AddMessage( string@ text, int type = FOMB_GAME )
    {
        // Skip error messages
        if( type == FOMB_GAME && text == "error" )
            return;

        // Set text
        string messageText;
        if( type >= FOMB_GAME && type <= FOMB_VIEW )
        {
            uint[] sayColors = { COLOR_DGREEN, COLOR_TEXT, COLOR_DRED, COLOR_DDGREEN };
            messageText = "|" + sayColors[ type ] + " " + EncodeUTF8( 0x2022 ) + " |" + COLOR_TEXT + " " + text;
        }
        else
        {
            messageText = text;
        }
        _MessageTexts.insertLast( messageText );

        // Set type
        int messageType = type;
        _MessageTypes.insertLast( messageType );

        // Set time
        uint16 year = 0;
        uint16 month = 0;
        uint16 day = 0;
        uint16 dayOfWeek = 0;
        uint16 hour = 0;
        uint16 minute = 0;
        uint16 second = 0;
        uint16 milliseconds;
        GetTime( year, month, day, dayOfWeek, hour, minute, second, milliseconds );
        string messageTime = ( hour <= 9 ? "0" : "" ) + hour + ":" + ( minute <= 9 ? "0" : "" ) + minute + ":" + ( second <= 9 ? "0" : "" ) + second + " ";
        _MessageTimes.insertLast( messageTime );

        // Generate mess box
        if( _DisplayedMessages[ type ] )
        {
            if( _Scroll > 0 && _IsHovered )
                _Scroll++;
            else
                _Scroll = 0;
        }
        _GenerateText();
    }

    void _GenerateText()
    {
        if( !Active )
            return;

        _Text = "";
        if( _MessageTexts.length() == 0 )
            return;

        int tw = 0, th = 0;
        int maxLines = 0;
        GetTextInfo( null, _Width, _Height, _TextFont, 0, tw, th, maxLines );
        if( maxLines <= 0 )
        {
            _MaxScroll = 0;
            _ScrollLines = 0;
            return;
        }

        _ScrollLines = -1;
        int lines = 0;
        for( int i = _MessageTexts.length() - 1; i >= 0; i-- )
        {
            string@ messageText = _MessageTexts[ i ];
            int     messageType = _MessageTypes[ i ];
            string@ messageTime = _MessageTimes[ i ];

            // Skip if not need to display
            if( !_DisplayedMessages[ messageType ] )
                continue;

            // Skip scrolled lines
            int curLines = lines;
            int skipLines = 0;
            GetTextInfo( messageText, _Width, 1000, _TextFont, 0, tw, th, skipLines );
            lines += skipLines;

            if( _ScrollLines < 0 )
            {
                if( lines <= _Scroll )
                    continue;
                _ScrollLines = _Scroll - curLines;
            }

            if( curLines - _Scroll < maxLines )
            {
                // Add to message box
                if( _InvertMessages )
                    _Text += messageText + "\n";
                else
                    _Text = messageText + "\n" + _Text;
            }
            else
            {
                break;
            }
        }
        _MaxScroll = lines - maxLines;
        if( _ScrollLines < 0 )
            _ScrollLines = 0;
    }

    bool _SetDisplayedMessage( int messageType, bool enable )
    {
        bool generateText = false;

        if( messageType != FOMB_ALL )
        {
            if( _DisplayedMessages[ messageType ] != enable )
            {
                _DisplayedMessages[ messageType ] = enable;
                generateText = true;
            }
        }
        else
        {
            for( uint i = 0; i < FOMB_ALL; i++ )
            {
                if( _DisplayedMessages[ messageType ] != enable )
                {
                    _DisplayedMessages[ messageType ] = enable;
                    generateText = true;
                }
            }
        }

        return generateText;
    }

    void SetDisplayedMessages( int[] messageTypes )
    {
        bool generateText = false;
        bool displayAll = ( messageTypes.find( FOMB_ALL ) != -1 );
        for( uint i = 0; i < _DisplayedMessages.length(); i++ )
            if( _SetDisplayedMessage( i, displayAll || messageTypes.find( i ) != -1 ) )
                generateText = true;
        if( generateText )
            _GenerateText();
    }

    void ChangeDisplayedMessage( int messageType, bool enable )
    {
        if( _SetDisplayedMessage( messageType, enable ) )
            _GenerateText();
    }

    void SetInvertMessages( bool invert )
    {
        _InvertMessages = invert;
        _GenerateText();
    }

    void ClearMessages()
    {
        _MessageTexts.clear();
        _MessageTypes.clear();
        _MessageTimes.clear();
        _GenerateText();
    }
}

#define CONSOLE_DATA_PREFIX    "console_"
/*EXPORT*/ class Console : TextInput
{
    bool   get_DisableDeactivation() final { return _DisableDeactivation; }
    string get_HistoryStorageName() final  { return _HistoryStorageName; }
    string[] @ get_History() final        {
        return _History;
    }
    uint get_HistoryMaxLength() final { return _HistoryMaxLength; }

    bool    _DisableDeactivation;
    string@ _HistoryStorageName;
    string  _HistoryActualStorageName;
    string[] _History;
    uint    _HistoryMaxLength;
    uint    _HistoryCur;

    void _Construct() override
    {
        SetCarriage( true );
        @_HistoryStorageName = "";

        TextInput::_Construct();
    }

    void Toggle()
    {
        if( !Active )
        {
            // Activate console
            Activate();
        }
        else if( _Text.length() == 0 )
        {
            // Deactivate console
            if( !_DisableDeactivation )
                Deactivate();
        }
        else
        {
            // Send text
            SendText();
        }
    }

    void Activate()
    {
        // Activate console
        if( Active || !Parent.Active )
            return;

        // Load history
        string actualStorageName = "";
        if( _HistoryStorageName !is null && __Name !is null && __Name != "" )
            actualStorageName = CONSOLE_DATA_PREFIX + __Name + _HistoryStorageName;

        if( _HistoryActualStorageName != actualStorageName )
        {
            _History.clear();
            _HistoryActualStorageName = actualStorageName;
            if( _HistoryActualStorageName != "" )
            {
                Serializator data;
                if( data.LoadFromCache( _HistoryActualStorageName ) > 0 )
                    data.Get( _History );
            }
        }

        _HistoryCur = _History.length();

        // Raise callbacks
        SetActive( true );
    }

    void Deactivate()
    {
        // Deactivate console
        if( _ActiveSelf )
            SetActive( false );
    }

    void SendText()
    {
        if( !Active )
            return;

        // Modify history
        _History.insertLast( _Text );
        for( uint i = 0; i < _History.length() - 1;)
        {
            if( _History[ i ] == _History.last() )
                _History.removeAt( i );
            else
                i++;
        }

        // Trim history length
        uint historyMaxLength = ( _HistoryMaxLength != 0 ? _HistoryMaxLength : __ConsoleHistorySize );
        while( _History.length() > historyMaxLength )
            _History.removeAt( 0 );
        _HistoryCur = _History.length();

        // Save history
        if( _HistoryActualStorageName != "" )
        {
            Serializator data;
            data.Set( _History );
            data.SaveToCache( _HistoryActualStorageName );
        }

        // Send
        bool[] @ keyPressed = Screen._InputKeyPressed;
        if( keyPressed[ DIK_LCONTROL ] || keyPressed[ DIK_RCONTROL ] )
            CustomCall( "ConsoleMessage\n/s" + _Text, "\n" );
        else if( keyPressed[ DIK_LMENU ] || keyPressed[ DIK_RMENU ] )
            CustomCall( "ConsoleMessage\n/w" + _Text, "\n" );
        else if( keyPressed[ DIK_LSHIFT ] || keyPressed[ DIK_RSHIFT ] )
            CustomCall( "ConsoleMessage\n/r" + _Text, "\n" );
        else
            CustomCall( "ConsoleMessage\n" + _Text, "\n" );

        // Clear text
        _Text = "";
        _CarriagePos = 0;
    }

    void _ConsoleInput( uint8 key, string@ text )
    {
        if( Active )
        {
            if( key == DIK_UP && _HistoryCur > 0 )
            {
                _HistoryCur--;
                _Text = _History[ _HistoryCur ];
                _CarriagePos = _Text.length();
            }
            else if( key == DIK_DOWN )
            {
                if( _HistoryCur + 1 < _History.length() )
                {
                    _HistoryCur++;
                    _Text = _History[ _HistoryCur ];
                    _CarriagePos = _Text.length();
                }
                else
                {
                    _HistoryCur = _History.length();
                    _Text = "";
                    _CarriagePos = 0;
                }

            }
            else
            {
                TextInput::Input( key, text );
            }
        }

        if( key == DIK_RETURN || key == DIK_NUMPADENTER )
        {
            Toggle();
        }
    }

    void Input( uint8 key, string@ text ) override
    {
        Text::Input( key, text );
    }

    void _Draw( bool callCallback ) override
    {
        if( callCallback )
            _DrawCallback();

        string@ text = Text;

        if( _CarriagePos < 0 )
            _CarriagePos = 0;
        if( _CarriagePos > int( text.length() ) )
            _CarriagePos = text.length();

        @text = text.substring( 0, _CarriagePos ) + ( GetTick() % 800 < 400 ? "!" : "." ) + text.substring( _CarriagePos );
        DrawText( text, _AbsolutePosX, _AbsolutePosY, _Width, _Height, _TextColor, _TextFont, _TextFlags );

        Object::_Draw( false );
    }

    void SetDisableDeactivation( bool enable )
    {
        _DisableDeactivation = enable;
    }

    void SetHistoryStorage( string storageName )
    {
        // Set storage name
        _HistoryStorageName = storageName;
    }

    void SetHistoryMaxLength( uint length )
    {
        _HistoryMaxLength = length;
    }
}

/*EXPORT*/ class ItemView : Grid
{
    int  get_UserData() final    { return _UserData; }
    int  get_UserDataExt() final { return _UserDataExt; }
    bool get_UseSorting() final  { return _UseSorting; }

    int  _UserData;
    int  _UserDataExt;
    bool _UseSorting;
    Item@[] _Items;
    uint _ItemsGridSize;

    // Callbacks
    Item@[] @ OnGetItems()
    {
        return null;
    }
    int OnCheckItem( Item@ item ) { return -1; }

    void _Init() override
    {
        _ItemsGridSize = _GridSize;

        Grid::_Init();
    }

    Item@ GetItem( uint cellIndex )
    {
        return _Items[ cellIndex ];
    }

    void Resort()
    {
        ResizeGrid( 0 );
    }

    void ResizeGrid( uint size ) override
    {
        _Items.clear();

        Item@[] @ items = OnGetItems();
        if( items is null )
            @items = array< Item@ >();

        if( !_UseSorting )
        {
            _Items.resize( _ItemsGridSize );
            for( uint i = 0; i < items.length(); i++ )
            {
                int itemIndex = OnCheckItem( items[ i ] );
                if( itemIndex >= 0 && itemIndex < int( _Items.length() ) )
                    @_Items[ itemIndex ] = items[ i ];
            }
        }
        else
        {
            int[] sortValues;
            for( uint i = 0; i < items.length(); i++ )
            {
                int sortValue = OnCheckItem( items[ i ] );
                if( sortValue >= 0 )
                {
                    bool added = false;
                    for( uint j = 0; j < _Items.length(); j++ )
                    {
                        if( sortValues[ j ] > sortValue )
                        {
                            _Items.insertAt( j, items[ i ] );
                            sortValues.insertAt( j, sortValue );
                            added = true;
                            break;
                        }
                    }
                    if( !added )
                    {
                        _Items.insertLast( items[ i ] );
                        sortValues.insertLast( sortValue );
                    }
                }
            }
        }

        Grid::ResizeGrid( _Items.length() );
    }

    void SetUserData( int data )
    {
        _UserData = data;
    }

    void SetUserDataExt( int data )
    {
        _UserDataExt = data;
    }

    void SetUseSorting( bool enable )
    {
        _UseSorting = enable;
    }
}

// Implementation

dict< int, CreateScreenFunc@ > ScreenCreators;

Screen@[] Screens;
Screen@ CursorScreen;

Object@ FocusedObject;
Object@ PressedObject;
uint    PressedObjectRepeatTime;
Object@ LastPressedObject;
Object@ HoveredObject;

DragAndDropHandler@[] DragAndDropHandlers;

// Drop menu
class DropButton
{
    int                     SortIndex;
    Sprite                  PicNormal;
    Sprite                  PicActive;
    DropMenuNeedShowButton@ NeedShow;
    DropMenuButtonAction@   Action;
}

class DropMenuSettings
{
    int        MouseButton;
    CursorType Cursor;
    uint       ShowTime;
    int        ButtonHeight;
    string     ArtDir;
    string     OpenSound;
    DropButton[]  Buttons;
    DropButton@[] ShowButtons;
    bool    Pressed;
    int     PressedOffsetY;
    uint    MouseStayTick;
    Entity@ SelectedEntity;
}

DropMenuSettings@ DropMenu;

//
// Public API
//

/*EXPORT*/ void RegisterScreen( int screenIndex, CreateScreenFunc@ screenFunc )
{
    UnregisterScreen( screenIndex );

    if( screenIndex == CLIENT_SCREEN_NONE )
        return;

    UnregisterScreen( screenIndex );
    @ScreenCreators[ screenIndex ] = screenFunc;

    // Precache
    Screen@ screen = CreateScreen( screenIndex );
    if( screen.IsMultiinstance )
    {
        screen._Remove();
        Screens.removeAt( Screens.findByRef( screen ) );
    }
}

/*EXPORT*/ Screen@ GetScreen( int screenIndex )
{
    Screen@ lastMultiinstanceScreen = null;
    for( int i = int( Screens.length() ) - 1; i >= 0; i-- )
    {
        Screen@ screen = Screens[ i ];
        if( screen.Index == screenIndex )
        {
            if( !screen.IsMultiinstance )
                return screen;
            else
                @lastMultiinstanceScreen = screen;
        }
    }
    return lastMultiinstanceScreen;
}

/*EXPORT*/ Screen@ GetActiveMainScreen()
{
    for( uint i = 0; i < Screens.length(); i++ )
        if( Screens[ i ].ActiveSelf && Screens[ i ].IsMain )
            return Screens[ i ];
    return null; // Should not be reach this point
}

/*EXPORT*/ Screen@ GetActiveScreen()
{
    for( int i = int( Screens.length() ) - 1; i >= 0; i-- )
        if( Screens[ i ].ActiveSelf )
            return Screens[ i ];
    return null; // Should not be reach this point
}

/*EXPORT*/ void GetActiveScreens( Screen@[]& result )
{
    for( uint i = 0; i < Screens.length(); i++ )
        if( Screens[ i ].ActiveSelf )
            result.insertLast( Screens[ i ] );
}

/*EXPORT*/ Object@ GetFocusedObject()
{
    if( FocusedObject !is null && !FocusedObject.Active )
    {
        FocusedObject._Unfocus();
        @FocusedObject = null;
    }
    return FocusedObject;
}

/*EXPORT*/ void SetFocusedObject( Object@ obj )
{
    if( FocusedObject !is null )
        FocusedObject._Unfocus();

    if( obj !is null && obj.Active )
    {
        @FocusedObject = obj;
        if( FocusedObject !is null )
            FocusedObject._Focus();
    }
    else
    {
        @FocusedObject = null;
    }
}

/*EXPORT*/ Object@ GetPressedObject()
{
    if( PressedObject !is null && !PressedObject.Active )
    {
        PressedObject._MouseUp( true );
        @PressedObject = null;
        @LastPressedObject = null;
    }
    return PressedObject;
}

/*EXPORT*/ Object@ GetLastPressedObject()
{
    if( LastPressedObject !is null && !LastPressedObject.Active )
        @LastPressedObject = null;
    return LastPressedObject;
}

/*EXPORT*/ Object@ GetDraggedObject()
{
    if( PressedObject !is null && !PressedObject.Active )
    {
        PressedObject._MouseUp( true );
        @PressedObject = null;
    }
    return PressedObject !is null && PressedObject._IsDragged ? PressedObject : null;
}

/*EXPORT*/ Object@ GetHoveredObject()
{
    if( HoveredObject !is null && !HoveredObject.Active )
    {
        HoveredObject._Unhover();
        @HoveredObject = null;
    }
    return HoveredObject;
}

/*EXPORT*/ void NextTextInput()
{
    Screen@ screen = GetActiveScreen();
    if( screen is null )
        return;

    TextInput@ curTextInput = cast< TextInput >( FocusedObject );
    @FindNextTextInputSkipObj = curTextInput;
    TextInput@ textInput = FindNextTextInput( screen );
    @FindNextTextInputSkipObj = null;
    if( textInput is null && curTextInput !is null )
        @textInput = FindNextTextInput( screen );

    if( textInput !is null && textInput !is curTextInput )
    {
        if( FocusedObject !is null )
            FocusedObject._Unfocus();
        @FocusedObject = textInput;
        FocusedObject._Focus();
    }
}

Object@ FindNextTextInputSkipObj = null;
TextInput@ FindNextTextInput( Object@ obj )
{
    if( FindNextTextInputSkipObj is null )
    {
        TextInput@ textInput = cast< TextInput >( obj );
        if( textInput !is null )
            return textInput;
    }
    else if( obj is FindNextTextInputSkipObj )
    {
        @FindNextTextInputSkipObj = null;
    }

    for( uint i = 0; i < obj._Children.length(); i++ )
    {
        if( obj._Children[ i ]._ActiveSelf )
        {
            TextInput@ textInput = FindNextTextInput( obj._Children[ i ] );
            if( textInput !is null )
                return textInput;
        }
    }
    return null;
}

/*EXPORT*/ void CollectMessageBoxes( MessageBox@[]& messageBoxes )
{
    for( int i = int( Screens.length() ) - 1; i >= 0; i-- )
        CollectMessageBoxes( Screens[ i ], messageBoxes );
}

void CollectMessageBoxes( Object@ obj, MessageBox@[]& messageBoxes )
{
    MessageBox@ mb = cast< MessageBox >( obj );
    if( mb !is null )
        messageBoxes.insertLast( mb );

    for( uint i = 0; i < obj._Children.length(); i++ )
        CollectMessageBoxes( obj._Children[ i ], messageBoxes );
}

/*EXPORT*/ bool IsConsoleActive()
{
    for( int i = int( Screens.length() ) - 1; i >= 0; i-- )
        if( IsConsoleActive( Screens[ i ] ) )
            return true;
    return false;
}

bool IsConsoleActive( Object@ obj )
{
    if( !obj.ActiveSelf )
        return false;

    Console@ console = cast< Console >( obj );
    if( console !is null )
        return true;

    for( uint i = 0; i < obj._Children.length(); i++ )
        if( IsConsoleActive( obj._Children[ i ] ) )
            return true;

    return false;
}

/*EXPORT*/ void AddDragAndDropHandler( DragAndDropHandler@ handler )
{
    DragAndDropHandlers.insertLast( handler );
}

/*EXPORT*/ void SetDropMenu( int mouseButton, CursorType cursor, uint showTime, uint buttonHeight, string artDir, string openSound )
{
    if( showTime > 0 )
    {
        @DropMenu = DropMenuSettings();
        DropMenu.MouseButton = mouseButton;
        DropMenu.Cursor = cursor;
        DropMenu.ShowTime = showTime;
        DropMenu.ButtonHeight = buttonHeight;
        DropMenu.ArtDir = artDir;
        DropMenu.OpenSound = openSound;
        DropMenu.Buttons.clear();
        DropMenu.ShowButtons.clear();
        DropMenu.Pressed = false;
        DropMenu.PressedOffsetY = 0;
        DropMenu.MouseStayTick = 0;
        @DropMenu.SelectedEntity = null;
    }
    else
    {
        @DropMenu = null;
    }
}

/*EXPORT*/ void DropMenuButton( int sortIndex, DropMenuNeedShowButton@ needShow, DropMenuButtonAction@ action, string picNormal, string picActive )
{
    if( DropMenu is null )
        return;

    DropButton button;
    button.SortIndex = sortIndex;
    button.PicNormal.Load( DropMenu.ArtDir + picNormal );
    button.PicActive.Load( DropMenu.ArtDir + picActive );
    @button.NeedShow = needShow;
    @button.Action = action;
    DropMenu.Buttons.insertLast( button );
    // Todo: sort
}

/*EXPORT*/ bool CheckHit( int x, int y )
{
    for( uint i = 0; i < Screens.length(); i++ )
        if( Screens[ i ].ActiveSelf && Screens[ i ].FindHit( x, y ) !is null )
            return true;
    return false;
}

//
// Engine callbacks
//

/*EXPORT*/ void EngineCallback_Start()
{
    // Register custom screens
    GuiScreens::InitializeScreens();

    // Register hardcoded screens
    CreateHardcodedScreen( CLIENT_MAIN_SCREEN_LOGIN );
    CreateHardcodedScreen( CLIENT_MAIN_SCREEN_GAME );
    CreateHardcodedScreen( CLIENT_MAIN_SCREEN_GLOBAL_MAP );
    CreateHardcodedScreen( CLIENT_MAIN_SCREEN_WAIT );
    CreateHardcodedScreen( CLIENT_SCREEN_PICKUP );
    CreateHardcodedScreen( CLIENT_SCREEN_DIALOG );
    CreateHardcodedScreen( CLIENT_SCREEN_BARTER );
    CreateHardcodedScreen( CLIENT_SCREEN_DIALOGBOX );
    CreateHardcodedScreen( CLIENT_SCREEN_TOWN_VIEW );
}

/*EXPORT*/ void EngineCallback_ShowScreen( int screenIndex, dictionary@ params )
{
    __ScrollMouseUp = false;
    __ScrollMouseRight = false;
    __ScrollMouseDown = false;
    __ScrollMouseLeft = false;
    __ScrollKeybUp = false;
    __ScrollKeybRight = false;
    __ScrollKeybDown = false;
    __ScrollKeybLeft = false;

    // Manage multiinstance
    for( int i = int( Screens.length() ) - 1; i >= 0; i-- )
    {
        // Find instance
        Screen@ screen = Screens[ i ];
        if( screen.Index != screenIndex )
            continue;

        // Move to top created instance
        if( !screen.IsMultiinstance )
        {
            ShowHideScreen( screen, params, true );
            return;
        }
    }

    // Create new instance
    Screen@ screen = CreateScreen( screenIndex );
    ShowHideScreen( screen, params, true );
}

/*EXPORT*/ void EngineCallback_HideScreen( int screenIndex )
{
    for( int i = int( Screens.length() ) - 1; i >= 0; i-- )
    {
        // Find instance
        Screen@ screen = Screens[ i ];
        if( !screen.ActiveSelf || screen.Index != screenIndex )
            continue;

        // Hide
        ShowHideScreen( screen, null, false );

        // Hide only one screen per call
        break;
    }
}

/*EXPORT*/ void EngineCallback_Draw()
{
    for( uint i = 0; i < Screens.length(); i++ )
    {
        Screen@ screen = Screens[ i ];
        if( screen.ActiveSelf )
        {
            if( screen.Index == CLIENT_MAIN_SCREEN_WAIT )
                CustomCall( "DrawWait" );
            screen._Draw( true );
        }
    }
}

/*EXPORT*/ void EngineCallback_DrawCursor()
{
    // Dragged object
    Object@ draggedObject = GetDraggedObject();
    if( draggedObject !is null )
    {
        int x = 0, y = 0, w = 0, h = 0;
        draggedObject.GetWholeSize( x, y, w, h );
        draggedObject.Draw( __MouseX - w / 2, __MouseY - h / 2 );
        return;
    }

    // Cursor
    CursorScreen._Draw( true );

    // Drop menu
    if( DropMenu !is null && DropMenu.ShowButtons.length() > 0 )
    {
        int x = __MouseX + 20; // Todo: rework to actual cursor size
        int y = __MouseY + 20;
        int activeIndex = DropMenu.PressedOffsetY / DropMenu.ButtonHeight;
        activeIndex = CLAMP( activeIndex, 0, int( DropMenu.ShowButtons.length() ) - 1 );
        for( uint i = 0; i < DropMenu.ShowButtons.length(); i++ )
        {
            DropButton@ button = DropMenu.ShowButtons[ i ];
            Sprite@     pic = ( int(i) == activeIndex ? button.PicActive : button.PicNormal );
            pic.Draw( x, y );
            y += DropMenu.ButtonHeight;
        }
    }
}

/*EXPORT*/ void EngineCallback_MouseDown( int button )
{
    // Unfocus current object
    if( button == MOUSE_BUTTON_LEFT && FocusedObject !is null )
    {
        FocusedObject._Unfocus();
        @FocusedObject = null;
    }

    // Release mouse from current object
    if( PressedObject !is null )
    {
        PressedObject._MouseUp( true );
        @PressedObject = null;
    }

    // Process mouse down
    Screen@ screen = GetActiveScreen();
    if( screen is null )
        return;

    // Global callback
    screen._GlobalMouseDown( button );

    // Click on entity
    if( DropMenu !is null && DropMenu.MouseButton == button &&
        DropMenu.Cursor == __Cursor && DropMenu.SelectedEntity !is null )
    {
        DropMenu.Pressed = true;
        DropMenu.PressedOffsetY = 0;
        DropMenu.MouseStayTick = GetTick();
    }

    // Check hit on current screen
    Object@ hitObj = screen.FindMouseHit();
    if( hitObj !is null )
    {
        // Handle pressed object
        @PressedObject = hitObj;
        PressedObjectRepeatTime = GetTick() + 500;
        @LastPressedObject = hitObj;
        PressedObject._MouseDown( button );

        // Handle focused object
        if( button == MOUSE_BUTTON_LEFT )
        {
            @FocusedObject = hitObj;
            FocusedObject._Focus();
        }
        return;
    }

    // Close on miss
    if( button == MOUSE_BUTTON_LEFT && screen.IsCloseOnMiss )
    {
        ShowHideScreen( screen, null, false );
        return;
    }

    // Switch to another screen
    if( button == MOUSE_BUTTON_LEFT && !screen.IsModal )
    {
        int screenIndex = Screens.findByRef( screen );
        for( int i = screenIndex - 1; i >= 0; i-- )
        {
            Screen@ nextScreen = Screens[ i ];
            if( !nextScreen.ActiveSelf )
                continue;

            if( nextScreen.IsModal || nextScreen.FindMouseHit() !is null )
            {
                // Show screen to top and click on it
                ShowHideScreen( nextScreen, null, true, nextScreen );
                EngineCallback_MouseDown( button );
                return;
            }
        }
    }
}

/*EXPORT*/ void EngineCallback_MouseUp( int button )
{
    // Global handler
    Screen@ screen = GetActiveScreen();
    if( screen !is null )
        screen._GlobalMouseUp( button );

    // Release mouse from current object
    if( PressedObject !is null && button == PressedObject._PressedButton )
    {
        Object@ obj = PressedObject;
        bool    isDragged = obj._IsDragged;
        PressedObject._MouseUp( false );
        @PressedObject = null;

        if( obj.IsMouseHit() )
        {
            if( screen !is null )
                screen._GlobalMouseClick( button );
            obj.MouseClick( button );
        }

        if( isDragged && screen !is null )
        {
            Object@ target = screen.FindMouseHit();
            for( uint i = 0; i < DragAndDropHandlers.length(); i++ )
                if( DragAndDropHandlers[ i ] ( obj, target ) )
                    break;
        }
    }

    // Drop menu
    if( DropMenu !is null && DropMenu.MouseButton == button && DropMenu.SelectedEntity !is null )
    {
        DropMenu.Pressed = false;

        if( DropMenu.ShowButtons.length() == 0 )
            CollectShowButtons( true );

        int         activeIndex = DropMenu.PressedOffsetY / DropMenu.ButtonHeight;
        activeIndex = CLAMP( activeIndex, 0, int( DropMenu.ShowButtons.length() ) - 1 );
        DropButton@ dropButton = DropMenu.ShowButtons[ activeIndex ];
        DropMenu.ShowButtons.clear();

        Entity@ entity = DropMenu.SelectedEntity;
        @DropMenu.SelectedEntity = null;

        if( !entity.IsDestroyed )
        {
            Critter@ cr = cast< Critter >( entity );
            Item@    item = cast< Item >( entity );
            if( dropButton.NeedShow( cr, item ) )
                dropButton.Action( cr, item );
        }
    }
}

/*EXPORT*/ void EngineCallback_MouseMove( int offsetX, int offsetY )
{
    bool realMove = ( offsetX != 0 || offsetY != 0 );

    // Drop menu activated
    if( DropMenu !is null && DropMenu.Pressed )
    {
        if( realMove )
        {
            DropMenu.PressedOffsetY += offsetY;
            CustomCall( "SetMousePos " + ( __MouseX - offsetX ) + " " + ( __MouseY - offsetY ) + " false" );
        }
        return;
    }

    // Move mouse for active screen
    Screen@ screen = GetActiveScreen();
    Object@ hoveredObj;
    if( screen !is null )
    {
        if( realMove )
            screen._GlobalMouseMove();
        @hoveredObj = screen.FindMouseHit();
        if( realMove && hoveredObj !is null )
            hoveredObj._MouseMove();
    }

    // Change hover object
    if( HoveredObject !is hoveredObj )
    {
        if( HoveredObject !is null )
            HoveredObject._Unhover();
        @HoveredObject = hoveredObj;
        if( HoveredObject !is null )
            HoveredObject._Hover();
    }

    // Detect entity for drop menu
    if(DropMenu !is null &&  DropMenu.Cursor == __Cursor )
    {
        Entity@ prevEntity = DropMenu.SelectedEntity;
        @DropMenu.SelectedEntity = null;

        if( hoveredObj !is null )
        {
            if( hoveredObj.Grid !is null && cast< ItemView >( hoveredObj.Grid ) !is null )
                @DropMenu.SelectedEntity = cast< ItemView >( hoveredObj.Grid ).GetItem( hoveredObj.CellIndex );
        }
        else if( !screen.IsModal )
        {
            Entity@ entity = GetMonitorEntity( __MouseX, __MouseY );
            if( entity !is null && ( cast< Critter >( entity ) !is null || cast< Item >( entity ) !is null ) )
                @DropMenu.SelectedEntity = entity;
        }

        if( prevEntity !is DropMenu.SelectedEntity || realMove )
        {
            DropMenu.MouseStayTick = GetTick();
            DropMenu.ShowButtons.clear();
        }
    }
}

/*EXPORT*/ void EngineCallback_KeyDown( uint8 key, string@ text )
{
    // Global input handler
    for( int i = int( Screens.length() ) - 1; i >= 0; i-- )
        if( Screens[ i ]._ActiveSelf )
            Screens[ i ]._GlobalInput( key, text );

    // Console input
    Console@ console = GetFirstConsole();
    if( console !is null )
        console._ConsoleInput( key, text );

    // Focused object input
    Screen@ screen = GetActiveScreen();
    if( FocusedObject !is null && FocusedObject !is screen )
        FocusedObject.Input( key, text );
}

Console@ GetFirstConsole()
{
    for( int i = int( Screens.length() ) - 1; i >= 0; i-- )
    {
        Console@ console = GetFirstConsole( Screens[ i ] );
        if( console !is null )
            return console;
    }
    return null;
}

Console@ GetFirstConsole( Object@ obj )
{
    Console@ console = cast< Console >( obj );
    if( console !is null )
        return console;

    for( uint i = 0; i < obj._Children.length(); i++ )
    {
        @console = GetFirstConsole( obj._Children[ i ] );
        if( console !is null )
            return console;
    }
    return null;
}

/*EXPORT*/ void EngineCallback_KeyUp( uint8 key )
{
    // ...
}

/*EXPORT*/ void EngineCallback_InputLost()
{
    if( HoveredObject !is null )
    {
        HoveredObject._Unhover();
        @HoveredObject = null;
    }
    if( FocusedObject !is null )
    {
        FocusedObject._Unfocus();
        @FocusedObject = null;
    }
    if( PressedObject !is null )
    {
        PressedObject._MouseUp( true );
        @PressedObject = null;
    }

    if( DropMenu !is null )
    {
        DropMenu.Pressed = false;
        @DropMenu.SelectedEntity = null;
        DropMenu.ShowButtons.clear();
    }
}

/*EXPORT*/ void EngineCallback_Loop()
{
    if( __WaitPing )
        Input::ReleaseMouse();

    if( PressedObject !is null )
    {
        uint tick = GetTick();
        if( tick >= PressedObjectRepeatTime && PressedObject.IsMouseHit() )
        {
            PressedObjectRepeatTime = tick + 40;
            GetActiveScreen()._GlobalMousePressed( PressedObject._PressedButton );
            PressedObject._MousePressed( PressedObject._PressedButton );
        }
    }

    EngineCallback_MouseMove( 0, 0 );

    // Drop menu
    if( DropMenu !is null && DropMenu.SelectedEntity !is null )
    {
        if( DropMenu.Cursor != __Cursor )
        {
            DropMenu.Pressed = false;
            @DropMenu.SelectedEntity = null;
            DropMenu.ShowButtons.clear();
        }
        else if( DropMenu.MouseStayTick != 0 && GetTick() - DropMenu.ShowTime >= DropMenu.MouseStayTick )
        {
            DropMenu.MouseStayTick = 0;

            CollectShowButtons( !DropMenu.Pressed );

            if( DropMenu.ShowButtons.length() == 0 )
            {
                DropMenu.Pressed = false;
                @DropMenu.SelectedEntity = null;
            }
        }
    }
}

void CollectShowButtons( bool onlyFirst )
{
    DropMenu.ShowButtons.clear();
    Critter@ cr = cast< Critter >( DropMenu.SelectedEntity );
    Item@    item = cast< Item >( DropMenu.SelectedEntity );
    for( uint i = 0; i < DropMenu.Buttons.length(); i++ )
    {
        if( DropMenu.Buttons[ i ].NeedShow( cr, item ) )
        {
            DropMenu.ShowButtons.insertLast( DropMenu.Buttons[ i ] );
            if( onlyFirst )
                break;
        }
    }
}

/*EXPORT*/ void EngineCallback_GetActiveScreens( int[]& result )
{
    for( uint i = 0; i < Screens.length(); i++ )
        if( Screens[ i ].ActiveSelf )
            result.insertLast( Screens[ i ].Index );
}

/*EXPORT*/ void EngineCallback_ItemChanged( bool onMap )
{
    if( !onMap )
    {
        ItemView@[] itemViews;
        CollectItemView( itemViews );
        for( uint i = 0; i < itemViews.length(); i++ )
            itemViews[ i ].Resort();
    }
}

void CollectItemView( ItemView@[]& itemViews )
{
    for( int i = int( Screens.length() ) - 1; i >= 0; i-- )
        CollectItemView( Screens[ i ], itemViews );
}

void CollectItemView( Object@ obj, ItemView@[]& itemViews )
{
    ItemView@ itemView = cast< ItemView >( obj );
    if( itemView !is null )
        itemViews.insertLast( itemView );

    for( uint i = 0; i < obj._Children.length(); i++ )
        CollectItemView( obj._Children[ i ], itemViews );
}

//
// Custom callbacks
//

/*EXPORT*/ void Callback_OnResolutionChanged()
{
    for( uint i = 0; i < Screens.length(); i++ )
        Screens[ i ]._Reload( false, true );
}

/*EXPORT*/ void Callback_OnLanguageChanged()
{
    for( uint i = 0; i < Screens.length(); i++ )
        Screens[ i ]._Reload( true, true );
}

//
// Internal
//

Screen@ CreateEmptyScreen()
{
    Screen screen;
    return screen;
}

void CreateHardcodedScreen( int screenIndex )
{
    Screen@ screen = GetScreen( screenIndex );
    if( screen is null )
    {
        RegisterScreen( screenIndex, CreateEmptyScreen );
        @screen = GetScreen( screenIndex );
    }
    screen._IsHardcoded = true;
}

Screen@ CreateScreen( int screenIndex )
{
    CreateScreenFunc@ screenFunc = ScreenCreators[ screenIndex ];
    Screen@           screen = screenFunc();
    screen._Index = screenIndex;
    screen._ActiveSelf = false;
    screen._IsRegistered = true;
    @screen._InputKeyPressed = Input::GetKeyPressed();
    @screen._InputMousePressed = Input::GetMousePressed();
    screen._Init();
    if( screenIndex != CLIENT_SCREEN_CURSOR )
        Screens.insertLast( @screen );
    else
        @CursorScreen = screen;
    return screen;
}

void UnregisterScreen( int screenIndex )
{
    for( int i = int( Screens.length() ) - 1; i >= 0; i-- )
    {
        Screen@ screen = Screens[ i ];
        if( screen.Index == screenIndex )
        {
            if( screen.ActiveSelf )
                ShowHideScreen( screen, null, false );
            if( !screen.IsMultiinstance )
            {
                screen._Remove();
                Screens.removeAt( i );
            }
            screen._IsRegistered = false;
        }
    }
}

void ShowHideScreen( Screen& screen, dictionary@ params, bool show, Screen@ appearScreen = null )
{
    // Clean hovered/focused/pressed objects
    if( HoveredObject !is null )
    {
        HoveredObject._Unhover();
        @HoveredObject = null;
    }
    if( FocusedObject !is null )
    {
        FocusedObject._Unfocus();
        @FocusedObject = null;
    }
    if( PressedObject !is null )
    {
        PressedObject._MouseUp( true );
        @PressedObject = null;
    }

    if( show )
    {
        // Hide active screen
        Screen@ activeScreen = GetActiveScreen();
        if( activeScreen !is null && activeScreen !is screen )
            activeScreen._Disappear();

        // Focus and hover new elements
        @FocusedObject = FindNextTextInput( screen );
        if( FocusedObject !is null )
            FocusedObject._Focus();
        @HoveredObject = screen.FindMouseHit();
        if( HoveredObject !is null )
            HoveredObject._Hover();

        // Move to top
        if( Screens.last() !is screen )
        {
            Screens.removeAt( Screens.findByRef( @screen ) );
            Screens.insertLast( @screen );
        }

        // Callback
        if( !screen._ActiveSelf )
            screen.SetActive( true );
        if( appearScreen is null )
            screen._Show( params );
        screen._Appear();
    }
    else
    {
        // Ignore redundant hide
        if( !screen._ActiveSelf )
            return;

        // Callbacks
        screen._Disappear();
        screen._Hide();
        screen.SetActive( false );

        // Remove multiinstance
        if( screen.IsMultiinstance )
        {
            screen._Remove();
            Screens.removeAt( Screens.findByRef( @screen ) );
        }

        // Appear active screen
        if( appearScreen is null )
            @appearScreen = GetActiveScreen();
        if( appearScreen !is null )
        {
            // Move to top
            if( Screens.last() !is appearScreen )
            {
                Screens.removeAt( Screens.findByRef( appearScreen ) );
                Screens.insertLast( appearScreen );
            }

            appearScreen._Appear();
        }
    }
}

uint GetScreenCount( int screenIndex )
{
    uint count = 0;
    for( int i = int( Screens.length() ) - 1; i >= 0; i-- )
        if( Screens[ i ].Index == screenIndex )
            count++;
    return count;
}
