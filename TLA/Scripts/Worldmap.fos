// FOS Server

#include "Tla"

#pragma property Critter PrivateServer int   ReddingMortonBrothers
#pragma property Critter PrivateServer uint8 SpecialEncounterBaxChurch Max = 1
#pragma property Critter PrivateServer uint8 SpecialEncounteTim Max = 1
#pragma property Critter PrivateServer uint8 RacingSneakersTrap Max = 1
#pragma property Critter PrivateServer uint8 SpecialEncounterBridge Max = 1
#pragma property Critter PrivateServer uint8 SpecialEncounterHoly1 Max = 1
#pragma property Critter PrivateServer uint8 SpecialEncounterHoly2 Max = 1
#pragma property Critter PrivateServer uint8 SpecialEncounterToxic Max = 1
#pragma property Critter PrivateServer uint8 SpecialEncounterPariah Max = 1
#pragma property Critter PrivateServer uint8 SpecialEncounterBrahmin Max = 1
#pragma property Critter PrivateServer uint8 SpecialEncounterWhale Max = 1
#pragma property Critter PrivateServer uint8 SpecialEncounterHead Max = 1
#pragma property Critter PrivateServer uint8 SpecialEncounterShuttle Max = 1
#pragma property Critter PrivateServer uint8 SpecialEncounterGuardian Max = 1
#pragma property Critter PrivateServer uint8 SpecialEncounterWoodsman Max = 1
#pragma property Critter PrivateServer uint8 SpecialEncounterUnwashed Max = 1
#pragma property Critter PrivateServer uint8 SpecialEncounterTeleport Max = 2
#pragma property Critter PrivateServer uint8 SpecialWastelandChildren Max = 1
#pragma property Critter PrivateServer uint8 SpecialEncounterKotw Max = 3
#pragma property Critter PrivateServer uint8 SpecialSoldierHolo Max = 3
#pragma property Critter PrivateServer uint8 SpecialTrapperHolo Max = 3
#pragma property Critter PrivateServer uint8 SpecialDollHolo Max = 3
#pragma property Critter PrivateServer uint8 SpecialEncounterZergLaboratory Max = 3
#pragma property Critter PrivateServer uint8 SpecialEncounterDoughnutWarehouse Max = 3
#pragma property Critter PrivateServer uint8 SpecialEncounterAtomChurch Max = 3
#pragma property Critter PrivateServer int   GeckoFindWoody
#pragma property Critter PrivateServer uint8 NcrDappoLostCCtatus Max  = 5

// #pragma property Global PrivateServer uint8  ModocBrahminEscaped
#pragma property Global  PrivateServer  uint8  RaidersDead

import void GenerateItems( Map& map, Critter@[] @  grp ) from "EncounterItems";
import void GenerateCavernEncounter( Map@ map, Critter@[] @ critters ) from "CaveMobs";

#define ZONE_COUNT_X                       ( 28 )
#define ZONE_COUNT_Y                       ( 30 )
#define ZONE_LENGTH                        ( 50 )

#define STR_VIEW                           ( 10000010 )   // {10000010}{}{Вы наткнулись на @lex who@.}
#define STR_VIEW_WITH_PLAYER               ( 10000011 )   // {10000011}{}{Вы наткнулись на @lex who@ и @lex player@.}
#define STR_VIEW_WITH_PLAYERS              ( 10000012 )   // {10000012}{}{Вы наткнулись на @lex who@ и банду @lex player@.}
#define STR_VIEW_ONLY_PLAYER               ( 10000013 )   // {10000013}{}{Вы наткнулись на @lex player@.}
#define STR_VIEW_ONLY_PLAYERS              ( 10000014 )   // {10000014}{}{Вы наткнулись на банду @lex player@.}
#define STR_QUESTION                       ( 10000020 )   // {10000020}{}{Вы хотите увидеть @lex who@?}
#define STR_QUESTION_WITH_PLAYER           ( 10000021 )   // {10000021}{}{Вы хотите увидеть @lex who@ и @lex player@?}
#define STR_QUESTION_WITH_PLAYERS          ( 10000022 )   // {10000022}{}{Вы хотите увидеть @lex who@ и банду @lex player@?}
#define STR_QUESTION_ONLY_PLAYER           ( 10000023 )   // {10000023}{}{Вы хотите увидеть @lex player@?}
#define STR_QUESTION_ONLY_PLAYERS          ( 10000024 )   // {10000024}{}{Вы хотите увидеть банду @lex player@?}

#define ENCOUNTER_OBJECT_NONE              ( 0 )
#define ENCOUNTER_OBJECT_CRITTER           ( 1 )
#define ENCOUNTER_OBJECT_ITEM              ( 2 )

#define CHECK_RANDOM                       ( 0 )
#define CHECK_PARAM                        ( 1 )
#define CHECK_PROPERTY                     ( 2 )
#define CHECK_GVAR                         ( 3 )
#define CHECK_HOUR                         ( 4 )
#define CHECK_PROPERTY_ANY                 ( 5 )
#define CHECK_PARAM_ANY                    ( 6 )
#define ASSIGN_PROPERTY                    ( 10 )

#define ACTION_NONE                        ( 0 )
#define ACTION_FIGHTING                    ( 1 )   // Combined with Ambush

#define TERRAIN_Desert                     ( 0 )
#define TERRAIN_Mountain                   ( 1 )
#define TERRAIN_City                       ( 2 )
#define TERRAIN_Coast                      ( 3 )
#define TERRAIN_Water                      ( 4 )

#define FILL_No_Fill                       ( 0 )
#define FILL_Fill_W                        ( 1 )

// Encounter frequency percentages
#define CHANCE_Forced                      ( 100 ) // This shouldn't change
#define CHANCE_Frequent                    ( 38 )  // Was 9/3d6
#define CHANCE_Common                      ( 22 )  // Was 8/3d6
#define CHANCE_Uncommon                    ( 12 )  // Was 6/3d6
#define CHANCE_Rare                        ( 4 )   // Was 5/3d6
#define CHANCE_None                        ( 0 )   // This shouldn't change

#define POSITION_NONE                      ( 0 )
#define POSITION_SURROUNDING               ( 1 )   // Окружают
#define POSITION_HUDDLE                    ( 2 )   //
#define POSITION_WEDGE                     ( 3 )
#define POSITION_CONE                      ( 4 )
#define POSITION_DOUBLE_LINE               ( 5 )
#define POSITION_STRAIGHT_LINE             ( 6 )

uint[][] PositionDirs =
{
    { 0 },                                     // POSITION_NONE
// Steps Path 1       Path 2
    { 1, 4, 3, 2, 1, 0, 5, 2, 3, 4, 5, 0, 1 }, // POSITION_SURROUNDING
    { 1, 5, 0, 1, 2, 3, 4, 1, 0, 5, 4, 3, 2 }, // POSITION_HUDDLE
    { 1, 4,           2 },                     // POSITION_WEDGE
    { 1, 5,           1 },                     // POSITION_CONE
    { 2, 1, 2,         4, 5 },                 // POSITION_DOUBLE_LINE
    { 2, 1, 2,         4, 5 } // POSITION_STRAIGHT_LINE
};

#define GROUP_Player                       ( uint( -1 ) )
#define GROUP_Raiders                      ( 0 )   // Fallout 1 encounters, not in use
#define GROUP_Rad_Scorpions                ( 1 )
#define GROUP_Giant_Rats                   ( 2 )
#define GROUP_Merchant_Party               ( 3 )
#define GROUP_Manti                        ( 4 )
#define GROUP_Easy_Deathclaw               ( 5 )
#define GROUP_Easy_Gecko                   ( 6 )
#define GROUP_Easy_MoleRat                 ( 7 )
#define GROUP_Easy_Pigrat                  ( 8 )
#define GROUP_Dog                          ( 9 )
#define GROUP_Brahmin                      ( 10 )   // Fallout 1 encounters end.
#define GROUP_ARRO_Rats                    ( 11 )
#define GROUP_ARRO_Pig_Rats                ( 12 )
#define GROUP_ARRO_Sm_Scorpions            ( 13 )
#define GROUP_ARRO_Silver_Geckos           ( 14 )
#define GROUP_ARRO_Spore_Plants            ( 15 )
#define GROUP_ARRO_Hunting_Party           ( 16 )
#define GROUP_ARRO_War_Party               ( 17 )
#define GROUP_ARRO_Cannibals               ( 18 )
#define GROUP_ARRO_Outcasts                ( 19 )
#define GROUP_ARRO_Holy_People             ( 20 )
#define GROUP_ARRO_Nomads                  ( 21 )
#define GROUP_ARROK_Molerats               ( 22 )
#define GROUP_ARROK_Geckos                 ( 23 )
#define GROUP_KLA_Trappers                 ( 24 )
#define GROUP_KLA_Bandits                  ( 25 )
#define GROUP_KLA_Homeless                 ( 26 )
#define GROUP_KLA_Farmers                  ( 27 )
#define GROUP_KLA_Golden_Geckos            ( 28 )
#define GROUP_KLAD_Caravan                 ( 29 )
#define GROUP_KLAD_Scorpions               ( 30 )
#define GROUP_KLAD_Mole_Pig_Rat            ( 31 )
#define GROUP_DMRV_Caravan                 ( 32 )
#define GROUP_DMRV_Robbers                 ( 33 )
#define GROUP_DMRV_Highwaymen              ( 34 )
#define GROUP_DMRV_Golden_Geckos           ( 35 )
#define GROUP_DMRV_Scorpions               ( 36 )
#define GROUP_DEN_Slavers                  ( 37 )
#define GROUP_DEN_Slave_Run                ( 38 )
#define GROUP_DEN_Slaves                   ( 39 )
#define GROUP_DEN_Rave_Party               ( 40 )
#define GROUP_DEN_Molerats                 ( 41 )
#define GROUP_MOD_Moonshiners              ( 42 )
#define GROUP_MOD_Wild_Brahmin             ( 43 )
#define GROUP_MOD_Mantis                   ( 44 )
#define GROUP_DVMV_Robbers                 ( 45 )
#define GROUP_DVMV_Highwaymen              ( 46 )
#define GROUP_DVMV_Wild_Dogs               ( 47 )
#define GROUP_DVMV_Mantis_Swarm            ( 48 )
#define GROUP_DVMV_Caravan                 ( 49 )
#define GROUP_WILD1_Trader                 ( 50 )
#define GROUP_WILD2_Mutated_Molerats       ( 51 )
#define GROUP_WILD2_Mutated_Pig_Rats       ( 52 )
#define GROUP_WILD2_Hermit                 ( 53 )
#define GROUP_VPAT_Patrol                  ( 54 )
#define GROUP_VPAT_Strong_Slavers          ( 55 )
#define GROUP_GECK_Ghoul_Crazies           ( 56 )
#define GROUP_GECK_Crazies                 ( 57 )
#define GROUP_GECK_Ghoul_Scavs             ( 58 )
#define GROUP_GECK_Scavs                   ( 59 )
#define GROUP_GECK_Mutated_Rats            ( 60 )
#define GROUP_GECK_Geckos                  ( 61 )
#define GROUP_FISH_Fisherman               ( 62 )
#define GROUP_FISH_Wilder                  ( 63 )
#define GROUP_DNRV_Den_Caravan             ( 64 )
#define GROUP_DNRV_Vault_Caravan           ( 65 )
#define GROUP_DNRV_Reno_Caravan            ( 66 )
#define GROUP_DNRV_Redding_Caravan         ( 67 )
#define GROUP_RED_Bootlegger               ( 68 )
#define GROUP_RED_Trappers                 ( 69 )
#define GROUP_RED_Prospector               ( 70 )
#define GROUP_RED_Claim_Jumper             ( 71 )
#define GROUP_RED_Wolves                   ( 72 )
#define GROUP_RED_Homesteaders             ( 73 )
#define GROUP_RDRC_Broken_Hills_Caravan    ( 74 )
#define GROUP_RDRC_Gecko_Caravan           ( 75 )
#define GROUP_RDRC_Raiders                 ( 76 )
#define GROUP_EPA_Fire_Geckos              ( 77 )
#define GROUP_EPA_Tough_Fire_Geckos        ( 78 )
#define GROUP_EPA_Alien                    ( 79 )
#define GROUP_EPA_Tough_Alien              ( 80 )
#define GROUP_EPA_Deathclaws               ( 81 )
#define GROUP_EPA_Centaurs                 ( 82 )
#define GROUP_EPA_Floaters                 ( 83 )
#define GROUP_EPA_Floater_Centaurs         ( 84 )
#define GROUP_NAV_Enclave_Patrol           ( 85 )
#define GROUP_FRAN_Mercenaries             ( 86 )
#define GROUP_FRAN_Elronologists           ( 87 )
#define GROUP_FRAN_Press_Gang              ( 88 )
#define GROUP_FRAN2_San_Fran_Caravan       ( 89 )
#define GROUP_BROK_Unity_Patrol            ( 90 )
#define GROUP_BROK_Rogues                  ( 91 )
#define GROUP_NEW_Mobsters                 ( 92 )
#define GROUP_NEW_Yakuza                   ( 93 )
#define GROUP_NEW_Gang                     ( 94 )
#define GROUP_NEW_Traveller                ( 95 )
#define GROUP_NCR_Rangers                  ( 96 )
#define GROUP_NCR_Marauders                ( 97 )
#define GROUP_NCR_Masters_Army             ( 98 )
#define GROUP_NCR_Caravan                  ( 99 )
#define GROUP_V15_Caravan                  ( 100 )
#define GROUP_V15_Squatters                ( 101 )
#define GROUP_Special1                     ( 102 )
#define GROUP_Bounty_Hunter_Low            ( 103 )
#define GROUP_Bounty_Hunter_Low_Mid        ( 104 )
#define GROUP_Bounty_Hunter_High_Mid       ( 105 )
#define GROUP_Bounty_Hunter_High           ( 106 )
#define GROUP_Morton_Brother               ( 107 )
#define GROUP_ARRO_Ants                    ( 108 )
#define GROUP_Game_Foreshadowing           ( 109 )
#define GROUP_SF_Mirelurk                  ( 110 )
#define GROUP_NCR_Patrol_Rebels            ( 111 )
#define GROUP_NCR_Patrol_Raiders           ( 112 )
#define GROUP_OCEAN_W_Voles_Low            ( 113 )
#define GROUP_OCEAN_W_Voles_High           ( 114 )
#define GROUP_OCEAN_W_Voles_Mutated        ( 115 )
#define GROUP_OCEAN_Mantis                 ( 116 )
#define GROUP_OCEAN_Wasps                  ( 117 )
#define GROUP_ARRO_Patrol                  ( 118 )
#define GROUP_HELL_Patrol                  ( 119 )
#define GROUP_HELL_Patrol_R                ( 120 )
#define GROUP_HELL_Fugitives               ( 121 )
#define GROUP_QUEST_Lynett_Hitman          ( 122 )
#define GROUP_QUEST_Carlos_Jackals         ( 123 )
#define GROUP_MAX                          ( 124 )

#define TABLE_DstN                         ( 0 )   // Fallout 1 encounter tables, not in use
#define TABLE_DstS                         ( 1 )
#define TABLE_MtnN                         ( 2 )
#define TABLE_MtnS                         ( 3 )
#define TABLE_Vault                        ( 4 )
#define TABLE_Coast                        ( 5 )    // Fallout 1 encounter tables end.
#define TABLE_Arro_M                       ( 6 )
#define TABLE_Arro_D                       ( 7 )
#define TABLE_Arro_O                       ( 8 )
#define TABLE_Arrok_D                      ( 9 )
#define TABLE_Arrok_M                      ( 10 )
#define TABLE_Kla_D                        ( 11 )
#define TABLE_Kla_M                        ( 12 )
#define TABLE_Klad_D                       ( 13 )
#define TABLE_DMRV_D                       ( 14 )
#define TABLE_DMRV_M                       ( 15 )
#define TABLE_Den_D                        ( 16 )
#define TABLE_Den_M                        ( 17 )
#define TABLE_Band_M                       ( 18 )
#define TABLE_Mod_M                        ( 19 )
#define TABLE_DVMV_M                       ( 20 )
#define TABLE_DVMV_D                       ( 21 )
#define TABLE_Wild1_M                      ( 22 )
#define TABLE_Wild1_D                      ( 23 )
#define TABLE_Wild2_D                      ( 24 )
#define TABLE_Wild2_M                      ( 25 )
#define TABLE_VPat_M                       ( 26 )
#define TABLE_VPat_D                       ( 27 )
#define TABLE_Geck_M                       ( 28 )
#define TABLE_Geck_D                       ( 29 )
#define TABLE_Fish_O                       ( 30 )
#define TABLE_Prim_D                       ( 31 )
#define TABLE_Prim_M                       ( 32 )
#define TABLE_DNRV_D                       ( 33 )
#define TABLE_DNRV_M                       ( 34 )
#define TABLE_Red_D                        ( 35 )
#define TABLE_Red_M                        ( 36 )
#define TABLE_Wild3_M                      ( 37 )
#define TABLE_RDRC_M                       ( 38 )
#define TABLE_RDRC_D                       ( 39 )
#define TABLE_Raid_M                       ( 40 )
#define TABLE_Raid_D                       ( 41 )
#define TABLE_Nav_D                        ( 42 )
#define TABLE_Nav_M                        ( 43 )
#define TABLE_Nav_O                        ( 44 )
#define TABLE_EPA_D                        ( 45 )
#define TABLE_EPA_M                        ( 46 )
#define TABLE_EPA_C                        ( 47 )
#define TABLE_Wild4_D                      ( 48 )
#define TABLE_Wild4_M                      ( 49 )
#define TABLE_Wild4_O                      ( 50 )
#define TABLE_SRNRRN_D                     ( 51 )
#define TABLE_SRNRRN_M                     ( 52 )
#define TABLE_New_D                        ( 53 )
#define TABLE_New_M                        ( 54 )
#define TABLE_New_C                        ( 55 )
#define TABLE_Brok_D                       ( 56 )
#define TABLE_Brok_M                       ( 57 )
#define TABLE_Fran_O                       ( 58 )
#define TABLE_Fran_M                       ( 59 )
#define TABLE_Fran_C                       ( 60 )
#define TABLE_Fran_D                       ( 61 )
#define TABLE_Fran2_D                      ( 62 )
#define TABLE_Fran2_C                      ( 63 )
#define TABLE_Wild5_D                      ( 64 )
#define TABLE_Wild5_M                      ( 65 )
#define TABLE_NRNR_D                       ( 66 )
#define TABLE_NRNR_M                       ( 67 )
#define TABLE_Wild6_M                      ( 68 )
#define TABLE_Wild6_D                      ( 69 )
#define TABLE_VNNB_D                       ( 70 )
#define TABLE_VNNB_M                       ( 71 )
#define TABLE_NCR_M                        ( 72 )
#define TABLE_NCR_D                        ( 73 )
#define TABLE_V15_M                        ( 74 )
#define TABLE_V15_D                        ( 75 )
#define TABLE_Ocean1_O                     ( 76 )
#define TABLE_Ocean2_O                     ( 77 )
#define TABLE_HELL_M                       ( 78 )
#define TABLE_MAX                          ( 79 )


class CCheck
{
    uint  Type;
    uint  Index;
    uint8 Operator;
    int   Value;

    CCheck()
    {
        Type = 0;
        Index = 0;
        Operator = 0;
        Value = 0;
    }

    void Set( uint type, uint index, uint8 operator, int value )
    {
        Type = type;
        Index = index;
        Operator = operator;
        Value = value;
    }
}

class CEncounterObject
{
    uint   ObjectType;
    hash   Pid;                 // Proto id
    uint   DialogId;
    string ScriptName;
    uint   DistanceLength;      // Distance from players
    CEncounterObject@[] Childs; // Items in inventory or container
    CCheck[] Checks;
    // Only for critter
    uint RatioValue;
    bool IsDead;
    // Only for item
    uint Minimum;
    uint Maximum;
    uint InvSlot;

    CEncounterObject()
    {
        ObjectType = 0;
        Pid = 0;
        DialogId = 0;
        ScriptName = "";
        DistanceLength = 0;
        RatioValue = 0;
        IsDead = false;
        Minimum = 0;
        Maximum = 0;
        InvSlot = 0;
    }

    CEncounterObject@ NewCheck( uint type, uint index, uint8 operator, int value )
    {
        Checks.grow( 1 );
        Checks.last().Set( type, index, operator, value );
        return this;
    }

    CEncounterObject@ Dialog( uint dialog )
    {
        DialogId = dialog;
        return this;
    }
    CEncounterObject@ Script( string& script )
    {
        ScriptName = script;
        return this;
    }
    CEncounterObject@ Distance( uint distance )
    {
        DistanceLength = distance;
        return this;
    }
    CEncounterObject@ CheckRandom( int value )
    {
        NewCheck( CHECK_RANDOM, 0, 0, value );
        return this;
    }
    CEncounterObject@ CheckParam( int index, uint8 operator, int value )
    {
        NewCheck( CHECK_PARAM, index, operator, value );
        return this;
    }
    CEncounterObject@ CheckParamAny( int index, uint8 operator, int value )
    {
        NewCheck( CHECK_PARAM_ANY, index, operator, value );
        return this;
    }
    CEncounterObject@ CheckProperty( int index, uint8 operator, int value )
    {
        NewCheck( CHECK_PROPERTY, index, operator, value );
        return this;
    }
    CEncounterObject@ CheckPropertyAny( int index, uint8 operator, int value )
    {
        NewCheck( CHECK_PROPERTY_ANY, index, operator, value );
        return this;
    }
    CEncounterObject@ CheckGVar( int index, uint8 operator, int value )
    {
        NewCheck( CHECK_GVAR, index, operator, value );
        return this;
    }
    CEncounterObject@ CheckHour( uint8 operator, int value )
    {
        NewCheck( CHECK_HOUR, 0, operator, value );
        return this;
    }
    CEncounterObject@ Ratio( uint ratio )
    {
        RatioValue = ratio;
        return this;
    }
    CEncounterObject@ Dead( bool dead )
    {
        IsDead = dead;
        return this;
    }
    CEncounterObject@ Slot( uint slot )
    {
        InvSlot = slot;
        return this;
    }

    CEncounterObject@ AddItem( hash pid, uint min, uint max, uint slot )
    {
        CEncounterObject new_child;
        Childs.insertLast( @new_child );
        new_child.Pid = pid;
        new_child.Minimum = min;
        new_child.Maximum = max;
        new_child.InvSlot = slot;
        return this;
    }
}

class CEncounterGroup
{
    uint TeamNum;
    uint Position;
    uint Spacing;
    uint Distance;
    CEncounterObject[] Objects;

    CEncounterGroup()
    {
        TeamNum = 0;
        Position = 0;
        Spacing = 0;
        Distance = 0;
    }

    CEncounterObject@ NewObject()
    {
        Objects.grow( 1 );
        return Objects.last();
    }

    CEncounterObject@ AddCritter( hash pid )
    {
        CEncounterObject@ obj = NewObject();
        obj.ObjectType = ENCOUNTER_OBJECT_CRITTER;
        obj.Pid = pid;
        return obj;
    }

    CEncounterObject@ AddItem( hash pid )
    {
        CEncounterObject@ obj = NewObject();
        obj.ObjectType = ENCOUNTER_OBJECT_ITEM;
        obj.Pid = pid;
        return obj;
    }
}

class CEncounter
{
    uint Chance;
    uint StrNum;
    hash LocPid;
    bool IsSpecial;
    uint[] Groups;
    uint[] RatioMin;
    uint[] RatioMax;
    uint[] Actions;
    CCheck[] Checks;

    CEncounter()
    {
        Chance = 0;
        StrNum = 0;
        LocPid = 0;
        IsSpecial = false;
    }

    CEncounter@ AddGroup( uint group, uint ratioMin, uint ratioMax )
    {
        Groups.grow( 1 );
        RatioMin.grow( 1 );
        RatioMax.grow( 1 );
        Groups.last() = group;
        RatioMin.last() = ratioMin;
        RatioMax.last() = ratioMax;
        return this;
    }

    CEncounter@ Fighting( uint fromGroup, uint toGroup )
    {
        Actions.insertLast( fromGroup );
        Actions.insertLast( toGroup );
        Actions.insertLast( ACTION_FIGHTING );
        return this;
    }

    CEncounter@ NewCheck( uint type, uint index, uint8 operator, int value )
    {
        Checks.grow( 1 );
        Checks.last().Set( type, index, operator, value );
        return this;
    }

    CEncounter@ LocationPid( hash locationPid )
    {
        LocPid = locationPid;
        return this;
    }
    CEncounter@ Special( bool special )
    {
        IsSpecial = special;
        return this;
    }
    CEncounter@ CheckRandom( int value )
    {
        NewCheck( CHECK_RANDOM, 0, 0, value );
        return this;
    }
    CEncounter@ CheckParam( int index, uint8 operator, int value )
    {
        NewCheck( CHECK_PARAM, index, operator, value );
        return this;
    }
    CEncounter@ CheckParamAny( int index, uint8 operator, int value )
    {
        NewCheck( CHECK_PARAM_ANY, index, operator, value );
        return this;
    }
    CEncounter@ CheckProperty( int index, uint8 operator, int value )
    {
        NewCheck( CHECK_PROPERTY, index, operator, value );
        return this;
    }
    CEncounter@ CheckPropertyAny( int index, uint8 operator, int value )
    {
        NewCheck( CHECK_PROPERTY_ANY, index, operator, value );
        return this;
    }
    CEncounter@ CheckGVar( int index, uint8 operator, int value )
    {
        NewCheck( CHECK_GVAR, index, operator, value );
        return this;
    }
    CEncounter@ CheckHour( uint8 operator, int value )
    {
        NewCheck( CHECK_HOUR, 0, operator, value );
        return this;
    }
    CEncounter@ AssignProperty( int index, uint8 operator, int value )
    {
        NewCheck( ASSIGN_PROPERTY, index, operator, value );
        return this;
    }
}

class CEncounterTable
{
    hash[] LocationPids;
    CEncounter[] Encounters;

    void AddLocationPid( hash locationPid )
    {
        LocationPids.insertLast( locationPid );
    }

    CEncounter@ AddEncounter( uint chance, uint strNum )
    {
        Encounters.grow( 1 );
        Encounters.last().Chance = chance;
        Encounters.last().StrNum = strNum;
        return @Encounters.last();
    }
}

class CZone
{
    int              Difficulty;
    uint             Terrain;
    uint             MorningChance;
    uint             AfternoonChance;
    uint             NightChance;
    CEncounterTable@ Table;

    CZone()
    {
        Difficulty = 0;
        Terrain = 0;
        MorningChance = 0;
        AfternoonChance = 0;
        NightChance = 0;
        @Table = null;
    }
}

CEncounterGroup[] EncounterGroups( GROUP_MAX );
CEncounterTable[] EncounterTables( TABLE_MAX );
CZone@[]          WorldmapGround( ZONE_COUNT_X* ZONE_COUNT_Y );
CZone@[]          WorldmapWater( ZONE_COUNT_X* ZONE_COUNT_Y );

//
// Zone
//

void SetZone( uint zx, uint zy, uint table, int difficulty, uint terrain, uint morningChance, uint afternoonChance, uint nightChance )
{
    CZone@ zone = CZone();
    @zone.Table = EncounterTables[ table ];
    zone.Difficulty = difficulty;
    zone.Terrain = terrain;
    zone.MorningChance = morningChance;
    zone.AfternoonChance = afternoonChance;
    zone.NightChance = nightChance;

    if( terrain != TERRAIN_Water )
        @WorldmapGround[ zy * ZONE_COUNT_X + zx ] = zone;
    else
        @WorldmapWater[ zy * ZONE_COUNT_X + zx ] = zone;
}

void SetZone( uint zx, uint zy, uint table, int difficulty, uint terrain, uint chance )
{
    SetZone( zx, zy, table, difficulty, terrain, chance, chance, chance );
}

//
// Tables
//

void AddTableToAllTables( CEncounterTable& globalTable )
{
    for( uint i = 0; i < TABLE_MAX; i++ )
    {
        if( i != TABLE_Ocean1_O && i != TABLE_Ocean2_O )
        {
            CEncounterTable@ table = EncounterTables[ i ];

            for( uint j = 0; j < globalTable.LocationPids.length(); j++ )
            {
                table.LocationPids.grow( 1 );
                table.LocationPids.last() = globalTable.LocationPids[ j ];
            }

            for( uint j = 0; j < globalTable.Encounters.length(); j++ )
            {
                table.Encounters.grow( 1 );
                table.Encounters.last() = globalTable.Encounters[ j ];
            }
        }
    }
}

//
// Checks
//

bool CheckCompare( int val1, uint8 operator, int val2 )
{
    if( operator == '>' )
        return val1 > val2;
    if( operator == '<' )
        return val1 < val2;
    if( operator == '=' )
        return val1 == val2;
    Log( "Unknown operator." );
    return false;
}

bool CheckCompareAnyParam( CCheck& check, Critter@[]& critters )
{
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( CheckCompare( critters[ i ].GetAsInt( CritterProperty( check.Index ) ), check.Operator, check.Value ) )
            return true;
    }
    return false;
}

bool CheckCompareAnyVar( CCheck& check, Critter@[]& critters )
{
    for( uint i = 0, j = critters.length(); i < j; i++ )
        if( CheckCompare( critters[ i ].GetAsInt( CritterProperty( check.Index ) ), check.Operator, check.Value ) )
            return true;
    return false;
}

void CheckAssignVar( Critter& cr, CritterProperty prop, uint8 operator, int val2 )
{
    int val1 = cr.GetAsInt( prop );
    if( operator == '=' )
        val1 = val2;
    else if( operator == '+' )
        val1 += val2;
    else if( operator == '-' )
        val1 -= val2;
    else if( operator == '*' )
        val1 *= val2;
    else if( operator == '/' )
        val1 /= val2;
    else
        Log( "Unknown operator." );
    cr.SetAsInt( prop, val1 );
}

bool CheckChecks( CCheck[]& checks, Critter@[]& critters )
{
    for( uint i = 0; i < checks.length(); i++ )
    {
        CCheck@ check = checks[ i ];
        switch( check.Type )
        {
        case CHECK_RANDOM:
            return Random( 1, 100 ) <= check.Value;
        case CHECK_HOUR:
            return CheckCompare( __Hour, check.Operator, check.Value );
        case CHECK_PARAM:
            for( uint j = 0; j < critters.length(); j++ )
                if( not CheckCompare( critters[ j ].GetAsInt( CritterProperty( check.Index ) ), check.Operator, check.Value ) )
                    return false;
            break;
        case CHECK_PARAM_ANY:
            return CheckCompareAnyParam( check, critters );
        case CHECK_PROPERTY:
            for( uint j = 0; j < critters.length(); j++ )
                if( not CheckCompare( critters[ j ].GetAsInt( CritterProperty( check.Index ) ), check.Operator, check.Value ) )
                    return false;
            break;
        case CHECK_PROPERTY_ANY:
            return CheckCompareAnyVar( check, critters );
        case CHECK_GVAR:
        {
            if( not CheckCompare( Globals.GetAsInt( GlobalVarsProperty( check.Index ) ), check.Operator, check.Value ) )
                return false;
        }
        break;
        default:
            continue;
        }
    }
    return true;
}

void AssignChecks( CCheck[]& checks, Critter@[]& critters )
{
    for( uint i = 0; i < checks.length(); i++ )
    {
        CCheck@ check = checks[ i ];
        if( check.Type == ASSIGN_PROPERTY )
        {
            for( uint j = 0; j < critters.length(); j++ )
                CheckAssignVar( critters[ j ], CritterProperty( check.Index ), check.Operator, check.Value );
        }
    }
}

//
// Stored founded encounters
//

#define FOUNDED_ENCOUNTER_LIVE_TIME    ( REAL_MINUTE( 30 ) ) // 30 real minutes
class CFoundedEncounter
{
    uint        Index;
    hash[]      LocationPids;
    CEncounter@ Encounter;
    bool        IsGenerated;
    uint        FullSecond;
    uint        PositionX;
    uint        PositionY;
    uint        OwnerId;
    bool        OwnerGroup;
    uint        LocationId;
    bool        IsWater;
    uint16      StartHexX;
    uint16      StartHexY;
    bool[] DirBusy;
    uint        AskChance;

    CFoundedEncounter()
    {
        Index = 0;
        @Encounter = null;
        IsGenerated = false;
        FullSecond = 0;
        PositionX = 0;
        PositionY = 0;
        OwnerId = 0;
        OwnerGroup = false;
        LocationId = 0;
        IsWater = false;
        StartHexX = 0;
        StartHexY = 0;
        DirBusy.resize( 6 );
    }
}

CFoundedEncounter[] FoundedEncounters( 1000 );
uint FoundedEncountersLastIndex = 0;

CFoundedEncounter@ CreateFoundedEncounter( bool isWater, uint x, uint y, CEncounter@ encounter, hash[]& locationPids, uint ownerId, bool ownerGroup )
{
    for( int i = 0, j = FoundedEncounters.length(); i < j; i++ )
    {
        CFoundedEncounter@ ge = FoundedEncounters[ i ];
        if( ge.Index == 0 || __FullSecond - ge.FullSecond >= FOUNDED_ENCOUNTER_LIVE_TIME + REAL_MINUTE( 1 ) )
        {
            FoundedEncountersLastIndex++;
            ge.Index = FoundedEncountersLastIndex;
            ge.LocationPids = locationPids;
            @ge.Encounter = encounter;
            ge.IsGenerated = false;
            ge.FullSecond = __FullSecond;
            ge.PositionX = x;
            ge.PositionY = y;
            ge.OwnerId = ownerId;
            ge.OwnerGroup = ownerGroup;
            ge.LocationId = 0;
            ge.IsWater = isWater;
            for( uint k = 0; k < 6; k++ )
                ge.DirBusy[ k ] = false;
            return ge;
        }
    }

    // Grow buffer and refind
    FoundedEncounters.resize( FoundedEncounters.length() * 2 );
    return CreateFoundedEncounter( isWater, x, y, encounter, locationPids, ownerId, ownerGroup );
}

CFoundedEncounter@ GetFoundedEncounter( uint index )
{
    for( int i = 0, j = FoundedEncounters.length(); i < j; i++ )
    {
        CFoundedEncounter@ ge = FoundedEncounters[ i ];
        if( ge.Index == index )
            return ge;
    }
    return null;
}

CFoundedEncounter@ GetNearFoundedEncounter( bool isWater, Critter@[] @ group, uint x, uint y, uint radius )
{
    for( int i = 0, j = FoundedEncounters.length(); i < j; i++ )
    {
        CFoundedEncounter@ ge = FoundedEncounters[ i ];
        if( ge.Index == 0 )
            continue;
        if( ge.IsWater != isWater )
            continue;
        if( __FullSecond - ge.FullSecond >= FOUNDED_ENCOUNTER_LIVE_TIME )
            continue;
        if( not ge.IsGenerated )
            continue;
        if( valid( ge.Encounter ) && ge.Encounter.IsSpecial && not CheckChecks( ge.Encounter.Checks, group ) )
            continue;
        if( uint( sqrt( float( POW2( ge.PositionX - x ) + POW2( ge.PositionY - y ) ) ) ) > radius )
            continue;
        if( group[ 0 ].Id == ge.OwnerId )
            continue;
        if( not valid( GetLocation( ge.LocationId ) ) )
            continue;

        return ge;
    }
    return null;
}

uint GetFreeDir( bool[]& dirBysy )
{
    // Try find random
    uint dir = Random( 0, 5 );
    if( not dirBysy[ dir ] )
    {
        dirBysy[ dir ] = true;
        return dir;
    }

    // Try find any free
    for( uint i = 0; i < 6; i++ )
    {
        if( not dirBysy[ i ] )
        {
            dirBysy[ i ] = true;
            return i;
        }
    }

    // Any busy
    return Random( 0, 5 );
}

void RotatePosition( uint toDir, uint[]& positionsDirs )
{
    for( uint i = 1, j = positionsDirs.length(); i < j; i++ ) // Skip Steps
    {
        positionsDirs[ i ] += toDir;
        if( positionsDirs[ i ] > 5 )
            positionsDirs[ i ] -= 6;
    }
}

void MovePositionPoint( Map& map, uint16& pointX, uint16& pointY, uint[]& positionDirs, uint pathIndex, uint count, uint spacing )
{
    uint steps = positionDirs[ 0 ];
    uint pathLen = ( positionDirs.length() - 1 ) / 2;
    count *= steps;
    count %= pathLen;
    if( steps > 1 )
    {
        for( uint i = 0; i < spacing; i++ )
        {
            for( uint j = 0; j < steps; j++ )
            {
                uint dir = positionDirs[ 1 + pathLen * pathIndex + count + j ];
                map.MoveHexByDir( pointX, pointY, dir, 1 );
            }
        }
    }
    else
    {
        uint dir = positionDirs[ 1 + pathLen * pathIndex + count ];
        map.MoveHexByDir( pointX, pointY, dir, spacing );
    }
}

void ParseEncounterObject( CEncounterObject@ obj, Map@ map, uint16 posX, uint16 posY, uint8 reversDir, Critter@[]& crittersGrouop, uint teamId )
{
    if( obj.ObjectType == ENCOUNTER_OBJECT_CRITTER )
    {
        if( not map.IsHexPassed( posX, posY ) )
            return;

        int[] props =
        {
            CritterProperty::DialogId, obj.DialogId, CritterProperty::BagId, BAG_Empty,
            CritterProperty::TeamId, teamId, CritterProperty::ReplicationTime, -1
        };
        Critter@ npc = map.AddNpc( obj.Pid, posX, posY, reversDir, props, obj.ScriptName );
        if( not valid( npc ) )
            return;

        for( uint i = 0, j = obj.Childs.length(); i < j; i++ )
        {
            CEncounterObject@ child = obj.Childs[ i ];
            uint              count = Random( child.Minimum, child.Maximum );
            if( count > 0 )
            {
                Item@ item = npc.AddItem( child.Pid, count );
                if( child.InvSlot != SLOT_INV )
                    npc.MoveItem( item.Id, item.Count, child.InvSlot );
            }
        }

        if( obj.IsDead )
        {
            npc.ToDead( Random( 0, 1 ) == 0 ? ANIM2_DEAD_FRONT : ANIM2_DEAD_BACK, null );
        }
        else
        {
            crittersGrouop.insertLast( @npc );
        }
    }
    else if( obj.ObjectType == ENCOUNTER_OBJECT_ITEM )
    {
        Item@ item = map.AddItem( posX, posY, obj.Pid, 1 );
        if( not valid( item ) )
            return;

        if( obj.Childs.length() > 0 && item.Type == ItemType::Container )
        {
            for( uint i = 0, j = obj.Childs.length(); i < j; i++ )
            {
                CEncounterObject@ child = obj.Childs[ i ];
                uint              count = Random( child.Minimum, child.Maximum );
                if( count > 0 )
                    item.AddItem( child.Pid, count, 0 );
            }
        }
    }
    else
    {
        Log( "Unknown object type<" + obj.ObjectType + ">." );
    }
}

void ActionFighting( Critter@[]& npcL, Critter@[]& npcR )
{
    for( int i = 0, j = npcL.length(); i < j; i++ )
    {
        Critter@ nl = npcL[ i ];
        bool     nlIsNpc = nl.IsNpc();
        for( int k = 0, l = npcR.length(); k < l; k++ )
        {
            Critter@ nr = npcR[ k ];
            if( nlIsNpc )
            {
                AddAttackPlane( nl, 0, nr );
                nl.AddEnemyToStack( nr.Id );
                nl.Wait( Random( 4000, 5000 ) );
            }
            if( nr.IsNpc() )
            {
                AddAttackPlane( nr, 0, nl );
                nr.AddEnemyToStack( nl.Id );
                nr.Wait( Random( 4000, 5000 ) );
            }
        }
    }
}

Map@ GenerateEncounter( CFoundedEncounter@ fe, Critter@[] @ critters )
{
    CEncounter@ encounter = fe.Encounter;
    hash        locPid = ( valid( encounter ) ? encounter.LocPid : 0 );
    if( locPid == 0 )
        locPid = fe.LocationPids[ Random( 0, fe.LocationPids.length() - 1 ) ];

    fe.LocationId = CreateLocation( locPid, fe.PositionX, fe.PositionY, null );
    if( fe.LocationId == 0 )
    {
        Log( "CreateLocation fail, location pid<" + locPid + ">." );
        return null;
    }

    Location@ location = GetLocation( fe.LocationId );
    if( not valid( location ) )
    {
        Log( "GetLocation fail." );
        return null;
    }
    location.IsEncounter = true;

    // Генерация итемов на всех картах энкаунтера
    for( uint i = 0, l = location.GetMapCount(); i < l; i++ )
    {
        Map@ m = location.GetMapByIndex( i );
        if( valid( m ) )
        {
            GenerateItems( m, critters );
            if( i > 0 )
            {
                GenerateCavernEncounter( m, critters );
            }
        }
    }

    Map@ map = location.GetMapByIndex( 0 );
    if( not valid( map ) )
    {
        Log( "GetMapByIndex fail." );
        return null;
    }

    uint16 startX = 0, startY = 0;
    if( not map.GetEntireCoords( 0, 0, startX, startY ) )
    {
        Log( "Default entire not found." );
        return null;
    }
    fe.StartHexX = startX;
    fe.StartHexY = startY;

    if( not valid( encounter ) ) // Empty map
    {
        fe.IsGenerated = true;
        return map;
    }

    Critter@ leader = critters[ 0 ];
    Critter@[][] crittersGrouops( encounter.Groups.length() );

    for( uint i = 0, j = encounter.Groups.length(); i < j; i++ )
    {
        uint groupNum = encounter.Groups[ i ];

        if( groupNum == GROUP_Player )
        {
            Critter@[] @ crGroup = crittersGrouops[ i ];
            crGroup.resize( critters.length() );
            for( uint k = 0, l = critters.length(); k < l; k++ )
                @crGroup[ k ] = critters[ k ];
            continue;
        }

        if( groupNum >= GROUP_MAX )
        {
            Log( "Invalid group number." );
            continue;
        }

        CEncounterGroup@ group = EncounterGroups[ groupNum ];
        uint             ratio = Random( encounter.RatioMin[ i ], encounter.RatioMax[ i ] );

        uint             distance = group.Distance;
        if( distance == 0 )
            distance = 7 + leader.Perception + leader.PerkCautiousNature * 3;

        uint teamId = group.TeamNum;
        if( teamId == 0 )
            teamId = TEAM_Mob0 + i;

        uint position = group.Position;
        uint spacing = group.Spacing;
        if( position == POSITION_SURROUNDING )
            spacing = leader.Perception + leader.PerkCautiousNature * 3;

        uint[] positionDirs = PositionDirs[ position ];
        uint steps = positionDirs[ 0 ];
        uint dirsCount = 0;

        uint freeDir = GetFreeDir( fe.DirBusy );
        if( freeDir != 0 )
            RotatePosition( freeDir, positionDirs );
        uint reversDir = freeDir + 3;
        if( reversDir > 5 )
            reversDir -= 6;

        // Get start point for group
        uint16[] pointX = { startX, startY };
        uint16[] pointY = { startX, startY };
        if( position != POSITION_NONE )
        {
            uint16 hx = pointX[ 0 ], hy = pointY[ 0 ];
            map.MoveHexByDir( pointX[ 0 ], pointY[ 0 ], freeDir, position != POSITION_SURROUNDING ? distance : spacing );
            map.GetHexCoord( hx, hy, pointX[ 0 ], pointY[ 0 ], 0.0f, 0 );  // Check for barrier
            pointX[ 1 ] = pointX[ 0 ];
            pointY[ 1 ] = pointY[ 0 ];
            MovePositionPoint( map, pointX[ 1 ], pointY[ 1 ], positionDirs, 1, 0, spacing );
        }

        for( uint k = 0, l = group.Objects.length(); k < l; k++ )
        {
            CEncounterObject@ obj = group.Objects[ k ];

            if( not CheckChecks( obj.Checks, critters ) )
                continue;

            uint otherDistance = obj.DistanceLength;
            uint count = obj.RatioValue * ratio / 100;
            if( count == 0 )
                count = 1;

            uint16 oldPosX = startX, oldPosY = startY;
            for( uint n = 0; n < count; n++ )
            {
                uint16 posX, posY;
                if( otherDistance > 0 || position == POSITION_NONE )
                {
                    posX = startX + Random( -5, 5 );
                    posY = startY + Random( -5, 5 );
                    map.MoveHexByDir( posX, posY, freeDir, otherDistance > 0 ? otherDistance : distance );
                }
                else
                {
                    uint pathIndex = dirsCount % 2;
                    posX = pointX[ pathIndex ] + ( position == POSITION_SURROUNDING ? Random( -3, 0 ) : 0 );
                    posY = pointY[ pathIndex ] + ( position == POSITION_SURROUNDING ? Random( -3, 0 ) : 0 );
                    MovePositionPoint( map, pointX[ pathIndex ], pointY[ pathIndex ], positionDirs, pathIndex, dirsCount, spacing );
                    dirsCount++;
                }

                map.GetHexCoord( oldPosX, oldPosY, posX, posY, 0.0f, 0 );          // Check for barrier
                oldPosX = posX;
                oldPosY = posY;
                ParseEncounterObject( obj, map, posX, posY, reversDir, crittersGrouops[ i ], teamId );
            }
        }
    }

    for( uint i = 0, j = encounter.Actions.length(); i < j; i += 3 )
    {
        uint fromGroup = encounter.Actions[ i ];
        uint toGroup = encounter.Actions[ i + 1 ];
        uint action = encounter.Actions[ i + 2 ];

        if( action == ACTION_FIGHTING && fromGroup < crittersGrouops.length() && toGroup < crittersGrouops.length() )
            ActionFighting( crittersGrouops[ fromGroup ], crittersGrouops[ toGroup ] );
    }

    fe.IsGenerated = true;
    return map;
}

//
// Imports
//
// void FindEncounter(Critter@[]@ critters, uint zx, uint zy) return foundedEncounterIndex
// bool InviteToEncounter(uint foundedEncounterIndex, Critter@[]@ critters) invite critters to encounter
// void WorldmapInit() call on start server

/*const int[] ScanOffsX={-1,0,1,-1,0,1,-1,0,1};
   const int[] ScanOffsY={-1,0,1,-1,0,1,-1,0,1};
   void ScanZone(Critter& cr, uint zx, uint zy)
   {
        uint zoneX=cr.WorldX/__GlobalMapZoneLength;
        uint zoneY=cr.WorldY/__GlobalMapZoneLength;

        cr.SetFog(zoneX,zoneY,FOG_NONE);
        cr.SetFog(zoneX-1,zoneY-1,FOG_SELF);
        cr.SetFog(zoneX  ,zoneY-1,FOG_SELF);
        cr.SetFog(zoneX+1,zoneY-1,FOG_SELF);
        cr.SetFog(zoneX-1,zoneY  ,FOG_SELF);
        cr.SetFog(zoneX+1,zoneY  ,FOG_SELF);
        cr.SetFog(zoneX-1,zoneY+1,FOG_SELF);
        cr.SetFog(zoneX  ,zoneY+1,FOG_SELF);
        cr.SetFog(zoneX+1,zoneY+1,FOG_SELF);

        for(int ox=-1;ox<2;ox++)
        {
                for(int oy=-1;oy<2;oy++)
                {

                }
        }
   }*/

void FindEncounter( Critter@[]& group, Item@ car, uint x, uint y, uint& encounterDescriptor, bool& waitForAnswer, bool empty )
{
    encounterDescriptor = 0;
    waitForAnswer = false;

    uint zx = x / ZONE_LENGTH;
    uint zy = y / ZONE_LENGTH;
    if( zx >= ZONE_COUNT_X || zy >= ZONE_COUNT_Y )
    {
        // Log("Invalid zones coordinates."); in faction mod size is greather than ZONE_COUNT_X, ZONE_COUNT_Y.
        return;
    }

    bool isWater = ( GetGlobalMapRelief( x, y ) == 0 );
    int  walkType = ( valid( car ) ? car.Car_MovementType : GM_WALK_GROUND );
    bool walkWaterOrFly = ( walkType == GM_WALK_WATER || walkType == GM_WALK_FLY );
    if( walkType == GM_WALK_GROUND && isWater )
        return;

    CZone@ zone = ( isWater ? WorldmapWater[ zy * ZONE_COUNT_X + zx ] : WorldmapGround[ zy * ZONE_COUNT_X + zx ] );
    if( not valid( zone ) )
        return;
    Critter@ leader = group[ 0 ];

    // Create empty map
    if( empty )
    {
        CFoundedEncounter@ fe = CreateFoundedEncounter( isWater, x, y, null, zone.Table.LocationPids, leader.Id, group.length() > 1 );
        if( not valid( fe ) )
            return;
        waitForAnswer = false;
        encounterDescriptor = fe.Index;
        return;
    }

    // Check chance
    uint chance;
    if( IS_MORNING( __Hour ) )
        chance = zone.MorningChance;
    if( IS_AFTERNOON( __Hour ) )
        chance = zone.AfternoonChance;
    else
        chance = zone.NightChance;
    if( uint( Random( 1, 100 ) ) > chance )
        return;

    // Try find already founded encounter
    CFoundedEncounter@ feAlready = GetNearFoundedEncounter( isWater, group, x, y, ZONE_LENGTH / 2 );
    if( valid( feAlready ) )
    {
        int outdoorsman = leader.SkillOutdoorsman + zone.Difficulty;
        outdoorsman = CLAMP( outdoorsman, 6, 95 );
        if( outdoorsman >= Random( 1, 100 ) || walkWaterOrFly )
        {
            if( valid( feAlready.Encounter ) )
            {
                leader.SayMsg( SAY_ENCOUNTER_RT, TEXTMSG_GM, feAlready.OwnerGroup ? STR_QUESTION_WITH_PLAYERS : STR_QUESTION_WITH_PLAYER,
                               "$who @msg gm " + feAlready.Encounter.StrNum + "@$player" + GetPlayerName( feAlready.OwnerId ) );
            }
            else
            {
                leader.SayMsg( SAY_ENCOUNTER_RT, TEXTMSG_GM, feAlready.OwnerGroup ? STR_QUESTION_ONLY_PLAYERS : STR_QUESTION_ONLY_PLAYER,
                               "$player" + GetPlayerName( feAlready.OwnerId ) );
            }
            waitForAnswer = true;

            if( not walkWaterOrFly )
            {
                if( leader.SkillOutdoorsman <= 95 )
                    leader.Experience += 100 - leader.SkillOutdoorsman - zone.Difficulty;
                else
                    leader.Experience += 5 - zone.Difficulty;
            }
        }

        for( uint i = 0, j = group.length(); i < j; i++ )
            group[ i ].Say( SAY_FLASH_WINDOW, "" );
        encounterDescriptor = feAlready.Index;
        return;
    }

    // Try find new encounter
    int luck = 0;
    for( uint i = 0, j = group.length(); i < j; i++ )
        luck += group[ i ].Luck;
    luck /= group.length();

    int roll = Random( 0, 100 ) + luck - 5 + 2 * leader.PerkExplorer + leader.PerkRanger + leader.PerkScout;
    if( roll < 0 )
        roll = 0;
    int maxRoll = 0;

    CEncounter[] @ encounters = zone.Table.Encounters;
    CEncounter@[] encountersThru( encounters.length() );
    for( uint i = 0, j = encounters.length(); i < j; i++ )
    {
        CEncounter@ enc = encounters[ i ];
        if( CheckChecks( enc.Checks, group ) )
        {
            maxRoll += enc.Chance;
            @encountersThru[ i ] = encounters[ i ];
        }
        else
        {
            @encountersThru[ i ] = null;
        }
    }

    roll = roll * maxRoll / 100;
    for( uint i = 0; i < encountersThru.length(); i++ )
    {
        CEncounter@ enc = encountersThru[ i ];

        if( not valid( enc ) )
            continue;
        if( uint( roll ) > enc.Chance && i < encountersThru.length() - 1 )
        {
            roll -= enc.Chance;
            continue;
        }

        CFoundedEncounter@ fe = CreateFoundedEncounter( isWater, x, y, enc, zone.Table.LocationPids, leader.Id, group.length() > 1 );
        if( not valid( fe ) )
            return;

        int outdoorsman = leader.SkillOutdoorsman + zone.Difficulty;
        outdoorsman = CLAMP( outdoorsman, 6, 95 );
        if( outdoorsman >= Random( 1, 100 ) || walkWaterOrFly )
        {
            leader.SayMsg( SAY_ENCOUNTER_ANY, TEXTMSG_GM, STR_QUESTION, "$who @msg gm " + enc.StrNum + "@" );
            waitForAnswer = true;

            if( not walkWaterOrFly )
            {
                if( leader.SkillOutdoorsman <= 95 )
                    leader.Experience += 100 - leader.SkillOutdoorsman - zone.Difficulty;
                else
                    leader.Experience += 5 - zone.Difficulty;
            }
        }

        for( uint j = 0; j < group.length(); j++ )
            group[ j ].Say( SAY_FLASH_WINDOW, "" );
        encounterDescriptor = fe.Index;
        break;
    }
}

void InviteToEncounter( Critter@[]& group, Item@ car, uint encounterDescriptor, int combatMode, uint& mapId, uint16& hexX, uint16& hexY, uint8& dir )
{
    mapId = 0;

    CFoundedEncounter@ fe = GetFoundedEncounter( encounterDescriptor );
    if( not valid( fe ) )
    {
        Log( "GetFoundedEncounter fail." );
        return;
    }

    bool isGenerated = fe.IsGenerated;
    Map@ map = null;
    if( isGenerated )
    {
        Location@ location = GetLocation( fe.LocationId );
        if( not valid( location ) )
        {
            // Log("Location not found.");
            return;
        }

        @map = location.GetMapByIndex( 0 );
    }
    else
    {
        @map = GenerateEncounter( fe, group );
    }

    if( not valid( map ) )
    {
        Log( "Map not found." );
        return;
    }

    Critter@ leader = group[ 0 ];
    mapId = map.Id;
    hexX = fe.StartHexX;
    hexY = fe.StartHexY;
    if( isGenerated )
    {
        if( valid( car ) )
        {
            // Place critters near his car
            hexX = uint16( -1 );
            hexY = uint16( -1 );
        }
        else
        {
            dir = GetFreeDir( fe.DirBusy );
            map.MoveHexByDir( hexX, hexY, dir, leader.Perception + leader.PerkCautiousNature * 3 );
            dir += 3;
            if( dir > 5 )
                dir -= 6;
        }
    }
    else
    {
        if( valid( car ) )
        {
            // Place critters near his car
            hexX = uint16( -1 );
            hexY = uint16( -1 );
        }

        dir = Random( 0, 5 );
    }

    if( isGenerated || valid( fe.Encounter ) )
    {
        for( uint i = 0, j = group.length(); i < j; i++ )
        {
            Critter@ cr = group[ i ];
            if( not isGenerated )
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GM, STR_VIEW, "$who @msg gm " + fe.Encounter.StrNum + "@" );
            else if( valid( fe.Encounter ) )
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GM, fe.OwnerGroup ? STR_VIEW_WITH_PLAYERS : STR_VIEW_WITH_PLAYER, "$who @msg gm " + fe.Encounter.StrNum + "@$player" + GetPlayerName( fe.OwnerId ) );
            else
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GM, fe.OwnerGroup ? STR_VIEW_ONLY_PLAYERS : STR_VIEW_ONLY_PLAYER, "$player" + GetPlayerName( fe.OwnerId ) );
        }
    }
    if( valid( fe.Encounter ) )
        AssignChecks( fe.Encounter.Checks, group );
}

uint GetGlobalMapRelief( uint x, uint y )
{
    // Used low four bits of image
    // Zero is water
    return GetImageColor( IMAGE_RELIEF, x, y ) & 0xF;
}

void WorldmapInit()
{
    LoadImage( IMAGE_RELIEF, "relief_tla.png", 1 );

    #include "WorldmapInit"
}
