namespace Lockers
{

// Author: cvet
// Doors and keys stuff.

// Lockers and doors
///@ Property Item Common bool Opened Mutable PublicSync Persistent
///@ Property Item Common bool IsCanOpen
///@ Property Item Common int64 LockerId Mutable OwnerSync Persistent
///@ Property Item Server int32 LockerComplexity Mutable Persistent
///@ Property Item Common bool Locker_Locked Mutable PublicSync Persistent
///@ Property Item Common bool Locker_Jammed Mutable PublicSync Persistent
///@ Property Item Common bool Locker_Broken Mutable PublicSync Persistent
///@ Property Item Common bool Locker_NoOpen Mutable PublicSync Persistent
///@ Property Item Common bool Locker_IsElectro Mutable PublicSync Persistent
///@ Property Item Common bool Door_NoBlockMove Mutable PublicSync Persistent
///@ Property Item Common bool Door_NoBlockShoot Mutable PublicSync Persistent
///@ Property Item Common bool Door_NoBlockLight Mutable PublicSync Persistent
///@ Property Item Common int32 Container_Volume Mutable PublicSync Persistent
///@ Property Item Common bool Container_Changeble Mutable PublicSync Persistent
///@ Property Item Common bool Container_CannotPickUp Mutable PublicSync Persistent

// MultihexDoors не используется нигде.
///@ Property Item Server bool Door_IsMultyHex Mutable Persistent
///@ Property Item Server uint8[] Door_MultyHexLine1 Mutable Persistent
///@ Property Item Server uint8[] Door_MultyHexLine2 Mutable Persistent
///@ Property Item Server int32[] Door_BlockerIds Mutable Persistent

// [[ModuleInit]]
void ModuleInit()
{
#if CLIENT
    Game.OnItemMapIn.Subscribe(OnItemMapIn);
    Game.AddPropertySetter(ItemProperty::Opened, ItemSetOpened);
#endif
}

#if SERVER

bool UseItemOnLocker(Critter cr, Item locker, Item item)
{
    return true;
}

bool UseSkillOnLocker(Critter cr, Item locker, CritterProperty skill)
{
    Map map = cr.GetMap();
    if (not valid(map)) {
        Messaging::Info(cr, TextPackName::Game, MsgStr::StrUseNothing);
        return true;
    }

    if (skill == CritterProperty::SpecialSkillPickOnGround) {
        if (locker.Type == ItemType::Door) {
            // NoOpen
            if (locker.Locker_NoOpen) {
                Messaging::Info(cr, TextPackName::Game, MsgStr::StrUseNothing);
                return true;
            }

            // Critter on hex
            if (locker.Opened && map.GetCritter(locker.Hex) !is null) {
                Messaging::Info(cr, TextPackName::Game, MsgStr::StrUseNothing);
                return true;
            }

            // Check key
            if (!locker.Opened && locker.LockerId != 0 && !locker.Locker_Broken && !IsKeyAvailable(cr, locker.LockerId)) {
                Messaging::Info(cr, TextPackName::Game, MsgStr::StrItemLockerNeedKey);
                return true;
            }

            // Change state
            SwitchLocker(locker, !locker.Opened);
        }
        else if (locker.Type == ItemType::Container) {
            // NoOpen
            if (locker.Locker_NoOpen) {
                Messaging::Info(cr, TextPackName::Game, MsgStr::StrUseNothing);
                return true;
            }

            // Check key
            if (!locker.Opened && locker.LockerId != 0 && !locker.Locker_Broken && !IsKeyAvailable(cr, locker.LockerId)) {
                Messaging::Info(cr, TextPackName::Game, MsgStr::StrItemLockerNeedKey);
                return true;
            }

            // Is changeble
            if (locker.Container_Changeble) {
                // Change state
                if (locker.Opened) {
                    SwitchLocker(locker, !locker.Opened);
                }
                else {
                    SwitchLocker(locker, !locker.Opened);
                    ShowContainer(cr, null, locker, locker.GroundLevel ? TransferTypes::HexContDown : TransferTypes::HexContUp);
                }
            }
            // No changeble
            else {
                ShowContainer(cr, null, locker, locker.GroundLevel ? TransferTypes::HexContDown : TransferTypes::HexContUp);
            }
        }
    }
    else if (skill == CritterProperty::SkillSteal) {
        if (locker.Type == ItemType::Container && locker.Opened) {
            ShowContainer(cr, null, locker, locker.GroundLevel ? TransferTypes::HexContDown : TransferTypes::HexContUp);
        }
        else {
            Messaging::Info(cr, TextPackName::Game, MsgStr::StrUseNothing);
        }
    }
    else if (skill == CritterProperty::SkillLockpick) {
        // NoOpen
        if (locker.Locker_NoOpen) {
            Messaging::Info(cr, TextPackName::Game, MsgStr::StrUseNothing);
            return true;
        }
        if (Time::IsTimeoutActive(cr.TimeoutSkLockpick)) {
            Messaging::Info(cr, TextPackName::Game, MsgStr::StrSkillWeariness);
            return true;
        }

        if (locker.LockerId == 0 || locker.Opened) {
            Messaging::Info(cr, TextPackName::Game, MsgStr::StrUseNothing);
            return true;
        }
        int base = cr.SkillLockpick - locker.LockerComplexity;
        Item itemLockpick = cr.GetItem(ItemProperty::CritterSlot, CritterItemSlot::Main);
        if (valid(itemLockpick)) {
            hstring activePid = itemLockpick.ProtoId;
            if (activePid == Content::Item::lockpicks) {
                base += 25;
                if (Game.Random(0, 30) == 0) {
                    cr.DestroyItem(Content::Item::lockpicks, 1);
                }
            }
            else if (activePid == Content::Item::exp_lockpick_set) {
                base += 50;
                if (Game.Random(0, 30) == 0) {
                    cr.DestroyItem(Content::Item::exp_lockpick_set, 1);
                }
            }
            // Todo: Content::Item::electronic_lockpicks, Content::Item::elec_lockpick_mkii
        }
        base = CLAMP(base, 0, 95);
        int value = Game.Random(1, 100);
        if (base >= value) {
            SwitchLocker(locker, true);
            if (locker.Type == ItemType::Container) {
                ShowContainer(cr, null, locker, locker.GroundLevel ? TransferTypes::HexContDown : TransferTypes::HexContUp);
            }
            cr.Experience += 50;
            Scores::AddScore(cr, EScores::Cracker, 1);
        }
        else {
            Messaging::Info(cr, TextPackName::Game, MsgStr::StrSkillLockpickFail);
        }

        cr.TimeoutSkLockpick = LOCKPICK_TIMEOUT(cr);
    }
    else if (skill == SKILL_TAKE_ALL_CONT) {
        return false;
    }
    else {
        Messaging::Info(cr, TextPackName::Game, MsgStr::StrUseNothing);
    }
    return true;
}

bool IsKeyAvailable(Critter cr, int lockerId)
{
    if (lockerId == 0) {
        return true;
    }

    if (_CritFingersDoorId(cr.Id) == lockerId || _CritEyesDoorId(cr.Id) == lockerId || cr.KnownLockerId.find(lockerId) >= 0) {
        return true;
    }

    Item[] keys = cr.GetItems(ItemProperty::Type, ItemType::Key);
    for (int i = 0; i < keys.length(); i++) {
        if (keys[i].LockerId == lockerId) {
            return true;
        }
    }

    return false;
}

ident GetKeyId(Critter cr, int lockerId)
{
    if (lockerId == 0 || _CritFingersDoorId(cr.Id) == lockerId || _CritEyesDoorId(cr.Id) == lockerId) {
        return ZERO_IDENT;
    }

    Item[] keys = cr.GetItems(ItemProperty::Type, ItemType::Key);
    for (int i = 0; i < keys.length(); i++) {
        if (keys[i].LockerId == lockerId) {
            return keys[i].Id;
        }
    }

    return ZERO_IDENT;
}

bool SwitchLocker(Item locker, bool toOpen)
{
    locker.Opened = toOpen;
    if (locker.Type == ItemType::Door) {
        locker.ShootThru = toOpen;
        locker.LightThru = toOpen;
        locker.NoBlock = toOpen;
        locker.IsGag = !toOpen;
    }
    return toOpen;
}

void ShowContainer(Critter cr, Critter crFrom, Item container, TransferTypes typeShow)
{
    /*	// Заглушка, требует реализации (просмотр контейнера или трупа)
                // Show open animation for all who view container
        Critter[] players = crTo.GetCritters( true, CritterFindType::Players );
        if( crTo.ControlledByPlayer )
            players.insertFirst( crTo );
        for( int i = 0; i < players.length(); i++ )
            players[ i ].PlayerClientCall.ShowOpenCloseAnimation( container.Id );
     */
    // Start container operation
    Item[] items = {};
    if (valid(crFrom) && (typeShow == TransferTypes::CritLoot || typeShow == TransferTypes::CritSteal)) {
        Map mapCrFrom = crFrom.GetMap();
        Map mapCr = cr.GetMap();
        if (valid(mapCr) && valid(mapCrFrom) && mapCr.Id == mapCrFrom.Id) {
            int dist = Game.GetDistance(cr.Hex, crFrom.Hex);
            int useDist = 1 + cr.Multihex;
            if (dist <= useDist) {
                items = crFrom.GetItems(ItemProperty::CritterSlot, CritterItemSlot::Inventory);
                cr.TransferType = typeShow;
                cr.TransferContainerId = crFrom.Id;
                cr.SendItems(items);
            }
        }
    }
    if (valid(container)) {
        items = container.GetItems(ROOT_CONTAINER_STACK);
        if (cr.ControlledByPlayer) {
            cr.TransferType = (container.GroundLevel ? TransferTypes::HexContDown : TransferTypes::HexContUp);
            cr.TransferContainerId = container.Id;
            cr.SendItems(items);
        }
        else {
            ItemMovement::MoveItems(items, cr);
        }
    }
}

#endif

#if CLIENT

// [[Event]]
void OnItemMapIn(Item item)
{
    if (item.Type != ItemType::Door && item.Type != ItemType::Container) {
        return;
    }

    item.StopAnim();

    if (item.IsCanOpen && item.Opened) {
        item.SetAnimTime(1.0);
    }
    else {
        item.SetAnimTime(0.0);
    }
}

// [[PropertySetter]]
void ItemSetOpened(Item item, bool& opened)
{
    item.PlayAnim(EMPTY_HSTRING, false, !opened);
}

#endif

}
