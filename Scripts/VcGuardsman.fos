namespace VcGuardsman // Sort 2
{

#if SERVER

// Система отдачи приказов, выполнения для нпц и контроля выполнения для игроков
// Приказы на перемещения по карте

///@ Property Critter Server ident[] SquadMarchSquads Mutable Persistent
///@ Property Critter Server uint8[] SquadMarchQueue Mutable Persistent

#define ORDER_TYPE_POS    (0)
#define ORDER_TYPE_MOVE   (1)
#define ORDER_TYPE_DIR    (2)
#define ORDER_TYPE_ARM    (3)
#define MAX_EXECUTE_TRIES (10)   // Максимальное число попыток выполнить приказ. Приказ не выполняется, если у нпц есть еще хоть какие-то планы
#define RECHECK_TICKS     (5000) // Время последующей проверки при провале выполнения приказа.

// #define DL #(s) (Game.Log(s))
#define DL        #(s)
#define STR_LOOSE (5917) // Вы что-то сделали не так. Задание провалено.

class MarchOrder // Вспомогательный класс. Приказ криттеру на выполнение некоторых действий
{
    int Type;      // Тип приказа
    mpos Hex;      // Точка, в которой должен стоять игрок.
    int Steps;     // Число шагов, которые нужно сделать
    int Dir;       // Направление, в котором должен смотреть игрок
    bool Armed;    // Вооружен
    bool Run;      // Бежать во время перемещения
    int TimeCheck; // Относительное время проверки, когда игрок должен выполнить приказ TODO: Удалить это время
    int TimeNext;  // Относительное время отдачи следующего приказа

    void Save(Serializator::Serializator save)
    {
        save.Set(Type);
        save.Set(Hex.x);
        save.Set(Hex.y);
        save.Set(Steps);
        save.Set(Dir);
        save.Set(Armed);
        save.Set(Run);
        save.Set(TimeCheck);
        save.Set(TimeNext);
    }

    void Load(Serializator::Serializator load)
    {
        load.Get(Type);
        mpos hex = mpos();
        load.Get(hex.x);
        load.Get(hex.y);
        Hex = hex;
        load.Get(Steps);
        load.Get(Dir);
        load.Get(Armed);
        load.Get(Run);
        load.Get(TimeCheck);
        load.Get(TimeNext);
    }

    string ToString()
    {
        string s = "MarchOrder";
        s += "\n type     : " + (Type == ORDER_TYPE_POS ?
                                     "ORDER_TYPE_POS" :
                                     (Type == ORDER_TYPE_MOVE ? "ORDER_TYPE_MOVE" : (Type == ORDER_TYPE_DIR ? "ORDER_TYPE_DIR" : "ORDER_TYPE_ARM")));
        s += "\n HexX     : " + Hex.x;
        s += "\n HexY     : " + Hex.y;
        s += "\n Steps    : " + Steps;
        s += "\n Dir      : " + Dir;
        s += "\n Armed    : " + (Armed ? "true" : "false");
        s += "\n Run      : " + (Run ? "true" : "false");
        s += "\n TimeCheck: " + TimeCheck;
        s += "\n TimeNext : " + TimeNext;
        return s;
    }
};

// Формулировки приказов
// Приказ ЗАНЯТЬ ПОЗИЦИЮ
MarchOrder DefineSetPosition(mpos hex, uint8 dir, bool run, int timeCheck, int timeNext)
{
    MarchOrder order = MarchOrder();
    order.Type = ORDER_TYPE_POS;
    order.Hex = hex;
    order.Dir = dir;
    order.Run = run;
    order.TimeCheck = timeCheck;
    order.TimeNext = timeNext;
    return order;
}

// Приказ ПЕРЕМЕСТИТЬСЯ
MarchOrder DefineMove(int steps, uint8 dir, bool run, int timeCheck, int timeNext)
{
    MarchOrder order = MarchOrder();
    order.Type = ORDER_TYPE_MOVE;
    order.Steps = steps;
    order.Dir = dir;
    order.Run = run;
    order.TimeCheck = timeCheck;
    order.TimeNext = timeNext;
    return order;
}

// Приказ ПОВОРОТ
MarchOrder DefineDirection(uint8 dir, int timeCheck, int timeNext)
{
    MarchOrder order = MarchOrder();
    order.Type = ORDER_TYPE_DIR;
    order.Dir = dir;
    order.TimeCheck = timeCheck;
    order.TimeNext = timeNext;
    return order;
}

// Приказ ВЗЯТЬ/УБРАТЬ ОРУЖИЕ
MarchOrder DefineArmWeapon(bool armed, int timeCheck, int timeNext)
{
    MarchOrder order = MarchOrder();
    order.Type = ORDER_TYPE_ARM;
    order.Armed = armed;
    order.TimeCheck = timeCheck;
    order.TimeNext = timeNext;
    return order;
}

// Класс для реализации строевой подготовки. Несколько последовательных приказов для каждого криттера.
// Определяющий параметр - Id криттера, у одного криттера - только одна очередь приказов
class MarchQueue
{
    MarchQueue(Critter cr)
    {
        OrderCurrent = -1;
        CritterId = cr.Id;
        Auto = false;
    }

    MarchQueue(ident crId)
    {
        OrderCurrent = -1;
        CritterId = crId;
        Auto = false;
    }

    bool Auto;                // Признак: все приказы назначаются автоматически, с помощью time_events
    ident CritterId;          // Исполнитель приказа
    int OrderCurrent;         // Текущий номер приказа
    MarchOrder[] Orders = {}; // Приказы в порядке выполнения

    void AddOrder(MarchOrder order)
    {
        if (valid(order)) {
            Orders.insertLast(order);
        }
    }

    void Save()
    {
        if (CritterId == ZERO_IDENT) {
            return;
        }

        Critter cr = Game.GetCritter(CritterId);
        int orders = Orders.length();
        DL("orders saved:" + orders);
        auto save = Serializator::Serializator();
        save.Set(Auto);
        save.Set(CritterId);
        save.Set(OrderCurrent);
        save.Set(orders);
        for (int i = 0; i < orders; i++) {
            Orders[i].Save(save);
        }
        cr.SquadMarchQueue = save.GetData();
    }

    void Load()
    {
        Critter cr = Game.GetCritter(CritterId);
        auto load = Serializator::Serializator();
        if (load.SetData(cr.SquadMarchQueue) == 0) {
            return;
        }
        int orders = 0;
        load.Get(Auto);
        load.Get(CritterId);
        load.Get(OrderCurrent);
        load.Get(orders);
        Orders.clear();
        for (int i = 0; i < orders; i++) {
            MarchOrder o = MarchOrder();
            o.Load(load);
            AddOrder(o);
        }
    }

    void Erase()
    {
        Critter cr = Game.GetCritter(CritterId);
        cr.SquadMarchQueue = array<uint8>();
        if (!cr.ControlledByPlayer) {
            cr.IsNoHome = false;
        }
    }

    // Подтверждает выполнение текущего приказа неким криттером. В результате подтверждения координаты
    //  предыдущего приказа приравниваются к текущему положению криттера
    void ConfirmOrder()
    {
        if (OrderCurrent < 0) {
            return;
        }
        Critter cr = Game.GetCritter(CritterId);
        if (!valid(cr)) {
            return;
        }
        MarchOrder order = Orders[OrderCurrent];
        if (!valid(order)) {
            return;
        }
        order.Hex = cr.Hex;
        order.Dir = cr.Dir;
        Save();
    }

    // Проверяет что все условия приказа выполнены
    bool CheckOrderCompleted()
    {
        if (OrderCurrent < 0) {
            return true;
        }
        Critter cr = Game.GetCritter(CritterId);
        if (!valid(cr)) {
            return false;
        }
        MarchOrder order = Orders[OrderCurrent];
        if (!valid(order)) {
            return false;
        }
        Item weapon;
        switch (order.Type) {
        case ORDER_TYPE_POS:
            return (cr.Hex == order.Hex);
        case ORDER_TYPE_MOVE:
            if (OrderCurrent == 0) // первый шаг, исходная координата неизвестна
            {
                return true;
            }
            else {
                MarchOrder orderPrev = Orders[OrderCurrent - 1];
                if (!valid(orderPrev)) {
                    return true;
                }
                mpos hex = orderPrev.Hex;
                Map map = cr.GetMap();
                if (!valid(map)) {
                    return true;
                }
                map.MoveHexByDir(hex, order.Dir, order.Steps);
                return (cr.Hex == hex);
            }
        case ORDER_TYPE_DIR:
            return (int(cr.Dir) == order.Dir);
        case ORDER_TYPE_ARM:
            weapon = _CritGetItemHand(cr);
            if (valid(weapon)) {
                if (order.Armed) {
                    return !weapon.Weapon_IsUnarmed;
                }
                else {
                    return weapon.Weapon_IsUnarmed;
                }
            }
            return !order.Armed;
        default:
            break;
        }
        return false;
    }

    void ExecuteOrder()
    {
        Critter cr = Game.GetCritter(CritterId);
        if (!valid(cr) || cr.ControlledByPlayer) {
            return; // Игроком выполнить приказ с помощью скрипта нельзя, разумеется
        }
        cr.IsNoHome = true;
        MarchOrder order = Orders[OrderCurrent];
        if (!valid(order)) {
            return;
        }
        Map map = cr.GetMap();
        if (!valid(map)) {
            return;
        }
        DL(order.ToString());

        Item weapon = null;
        ProtoItem proto = null;
        mpos hex;
        hstring pid1;
        hstring pid2;

        switch (order.Type) {
        case ORDER_TYPE_POS:
            NpcPlanes::AddWalkPlane(cr, 0, order.Hex, order.Dir, order.Run, 0);
            break;
        case ORDER_TYPE_MOVE:
            if (OrderCurrent == 0) // первый шаг, исходная координата неизвестна
            {
                break;
            }
            else {
                MarchOrder orderPrev = Orders[OrderCurrent - 1];
                if (!valid(orderPrev)) {
                    return;
                }
                hex = orderPrev.Hex;
                map.MoveHexByDir(hex, order.Dir, order.Steps);
                NpcPlanes::AddWalkPlane(cr, 0, hex, order.Dir, order.Run, 0);
                break;
            }
        case ORDER_TYPE_DIR:
            cr.SetDir(order.Dir);
            break;
        case ORDER_TYPE_ARM:
            weapon = _CritGetItemHand(cr);
            if (order.Armed) {
                if (valid(weapon) && !weapon.Weapon_IsUnarmed) {
                    break; // В руках оружие
                }
                pid1 = FavoriteItem::GetFavoriteItemPid(cr, CritterItemSlot::Main);
                // Проверяем, что у нпц в другом слоте
                pid2 = FavoriteItem::GetFavoriteItemPid(cr, CritterItemSlot::Secondary);
                proto = Game.GetProtoItem(pid2);
                if (!valid(proto) || proto.Type != ItemType::Weapon) {
                    Item[] weapons = cr.GetItems(ItemProperty::Type, ItemType::Weapon);
                    for (int i = 0; i < weapons.length(); i++) {
                        if (weapons[i].Type == ItemType::Weapon && !weapons[i].Weapon_IsUnarmed) {
                            pid2 = weapons[i].ProtoId;
                        }
                    }
                }
                FavoriteItem::SetFavoriteItemPid(cr, CritterItemSlot::Main, pid2);
                FavoriteItem::SetFavoriteItemPid(cr, CritterItemSlot::Secondary, pid1);
            }
            else {
                if (valid(weapon) && !weapon.Weapon_IsUnarmed) {
                    pid1 = weapon.ProtoId;
                    // Проверяем, что у нпц в другом слоте
                    pid2 = FavoriteItem::GetFavoriteItemPid(cr, CritterItemSlot::Secondary);
                    proto = Game.GetProtoItem(pid2);
                    if (!valid(proto) || proto.Type == ItemType::Weapon) {
                        pid2 = Content::Item::default_weapon; // Убирание оружия - имитируем с помощью выбора любимым оружием рукопашного удара
                    }
                    NpcPlanes::DropPlanes(cr);
                    FavoriteItem::SetFavoriteItemPid(cr, CritterItemSlot::Main, pid2);
                    FavoriteItem::SetFavoriteItemPid(cr, CritterItemSlot::Secondary, pid1);
                }
            }
            break;
        default:
            break;
        }
    }

    void NextOrder()
    {
        if (Orders.length() == 0) {
            return;
        }
        int newIndex = OrderCurrent + 1;
        MarchOrder order;
        if (newIndex >= Orders.length()) {
            order = Orders[OrderCurrent];
            if (order.TimeNext == 0) {
                Erase(); // Выполнение всех приказов закончено
                return;
            }
            else {
                newIndex = 0; // Повторяем заново
            }
        }
        OrderCurrent = newIndex;
        Save();
        if (Auto) {
            ExecuteOrder();
            order = Orders[OrderCurrent];
            if (valid(order)) {
                any[] values = {CritterId, 0};
                Game.StartTimeEvent(Tla::GameSeconds(order.TimeNext), DoNextOrder, values);
            }
        }
    }
};

// Атоматическая проверка, что приказ выполнен для НПЦ с очередью приказов с установленным флагом Auto
// Проверяется, что план выполнен, у НПЦ нет других планов, если это верно, отдается следующий приказ
// иначе делается MAX_EXECUTE_TRIES попыток выполнить приказ
// если приказ не выполним, очередь приказов отменяется
void DoNextOrder(any[] values)
{
    DL("next order");
    Critter cr = Game.GetCritter(values[0]);
    if (!valid(cr) || values[1] >= MAX_EXECUTE_TRIES || cr.ControlledByPlayer) {
        return;
    }

    MarchQueue march = MarchQueue(cr);
    values[1] = int(values[1]) + 1;
    if (NpcPlanes::IsNoPlanes(cr) && valid(march) && march.CheckOrderCompleted()) {
        march.ConfirmOrder();
        march.NextOrder();
        return;
    }

    Game.StartTimeEvent(Tla::GameSeconds(RECHECK_TICKS), DoNextOrder, values);
}

class SquadCommander
{
    ident CommanderId;
    ident[] Squad = {};

    SquadCommander(Critter cr)
    {
        CommanderId = cr.Id;
    }

    void Save()
    {
        Game.GetCritter(CommanderId).SquadMarchSquads = Squad;
    }

    void Load()
    {
        Squad = Game.GetCritter(CommanderId).SquadMarchSquads.clone();
    }

    void Erase()
    {
        for (int i = 0; i < Squad.length(); i++) {
            MarchQueue q = MarchQueue(Squad[i]);
            q.Load();
            q.Erase();
        }
        Critter cr = Game.GetCritter(CommanderId);
        cr.SquadMarchSquads = array<ident>();
    }

    bool CheckCommandExecuted() // Проверка только для игроков
    {
        for (int i = 0, l = Squad.length(); i < l; i++) {
            MarchQueue q = MarchQueue(Squad[i]);
            q.Load();
            Critter cr = Game.GetCritter(Squad[i]);
            if (!valid(cr) || !valid(q)) {
                return false;
            }
            if (cr.ControlledByPlayer && !q.CheckOrderCompleted()) {
                Messaging::Info(cr, TextPackName::Text, STR_LOOSE);
                return false;
            }
        }
        return true;
    }

    void Command(int strNum) // strNum - номер строки из диалога
    {
        Critter cr = Game.GetCritter(CommanderId);
        if (valid(cr) && strNum >= 0) {
            Messaging::SayShout(cr, TextPackName::Dialogs, DLGSTR(cr.DialogId, strNum));
        }
        for (int i = 0, l = Squad.length(); i < l; i++) {
            MarchQueue q = MarchQueue(Squad[i]);
            q.Load();
            if (valid(q)) {
                q.ConfirmOrder();
                q.Save();
                DL("ci = " + q.OrderCurrent);
                q.NextOrder();
                q.Save();
                Critter c = Game.GetCritter(q.CritterId);
                if (!valid(c)) {
                    return;
                }
                if (!c.ControlledByPlayer) {
                    q.ExecuteOrder();
                }
            }
        }
    }
};

// Author: rifleman17
// Скрипты для квестовой линии "Гвардеец Города-Убежища"

///@ Property Critter Common uint8 VCHartmanMarch Mutable OwnerSync Persistent Group = Quests Quest = 8823 Max = 4
///@ Property Critter Common uint8 VCHartmannClearCave Mutable OwnerSync Persistent Group = Quests Quest = 8832 Max = 4
///@ Property Critter Server uint8 VCDeadAllyCounter Mutable Persistent Max = 10
///@ Property Critter Server uint8 VCGuardRank Mutable Persistent Max = 4
///@ Property Critter Server ident VCReconCaveId Mutable Persistent
///@ Property Critter Server ident VCGuardsmanTriggerPlayerId Mutable Persistent
///@ Property Game Server bool VCHartmanMarchStatus Mutable Persistent

// Квест "Самоделкин":
//  Тренировка по надлежащему уходу за оружием
//  Выдача двух сломанных Штурмовых винтовок
void r_GiveWearItems(Critter player, Critter npc, int pidHash, int count, int deteriorationPercent)
{
    Item item;
    for (int i = 0; i < count; i++) {
        item = player.AddItem(hstring_fromHash(pidHash), 1);
        if (!valid(item)) {
            continue;
        }
        Repair::SetDeterioration(item, deteriorationPercent);
    }
}

bool d_CheckWear(Critter player, Critter npc, int pidHash, int count, int deteriorationPercent)
{
    if (count == 0) {
        return false;
    }

    int num = 0;
    Item[] items = player.GetItems();
    for (int i = 0; i < items.length(); i++) {
        Item item = items[i];
        if (item.ProtoId == hstring_fromHash(pidHash) && Repair::GetDeteriorationProcent(item) <= deteriorationPercent) {
            num++;
        }
    }

    return (num >= count);
}

// Квест "Строевая подготовка":
//  Персонаж должен встать в одну линию с НПЦ-гвардейцами и повторять их движения по команде капитана Хартманна
#define ROLE_MARCH          (91)   // Номер роли НПЦ, которые принимают участие в марше
#define ROLE_COMMANDER      (92)   // Хартманн
#define STR_RIGHT_POSITION  (5915) // Вы в правильной позиции. Оставайтесь на месте до первой команды. Равнение на середину!
#define STR_WRONG_POSITION  (5916) // Да сколько можно? Стать в строй, черт тебя дери! Иначе отправлю к мамочке!
#define STR_MARCH_FAILED    (9)    // Это чучело безнадеждно. Я так и думал.
#define STR_MARCH_COMPLETED (10)   // Неплохо... Неплохо. Не ожидал.
#define STR_LOOSE           (5917) // Вы что-то сделали не так. Задание провалено.
#define POS_X               (65)   // Позиция игрока в начале квеста
#define POS_Y               (132)
#define LAST_ORDER          (7) // Последний приказ

// Обработка наступания игроком на триггер перед началом тренировки
// Служит сигналом к началу
void t_Enter(Critter player, StaticItem trigger, bool entered, uint8 dir)
{
    if (!player.ControlledByPlayer || !entered) {
        return;
    }
    if (player.VCHartmanMarch != 1 || Game.VCHartmanMarchStatus) {
        return;
    }
    CritterState::Wait(player, 0);
    Messaging::Info(player, TextPackName::Text, STR_RIGHT_POSITION);
    Map map = player.GetMap();
    Critter cr = map.GetCritter(CritterProperty::NpcRole, ROLE_COMMANDER, CritterFindType::NonDeadNpc);
    if (!valid(cr) || cr.VCGuardsmanTriggerPlayerId != ZERO_IDENT) {
        return;
    }
    any[] values = {cr.Id, player.Id, 0};
    cr.VCGuardsmanTriggerPlayerId = player.Id; // Сохранение кода игрока, чтобы нпц не спамил свои реплики при многократных входах-выходах на гекс
    player.VCHartmanMarch = 2;
    Game.StartTimeEvent(Time::Seconds(3), TimeToStart, values);
    Game.StartTimeEvent(Time::GameMinutes(15), ResetCommander, values); //SavedDeferredCall
}

// Контрольная очистка переменных через 15 реальных минут, если что-то пошло не так, и все данные не удалились
void ResetCommander(any[] values)
{
    Critter cr = Game.GetCritter(values[0]);
    ident idPlayer = values[1];
    if (!valid(cr) || cr.VCGuardsmanTriggerPlayerId != idPlayer) {
        return; // Если уже другой персонаж занимается строевой подготовкой, для него будет персональный эвент
    }

    SquadCommander cmdr = SquadCommander(cr);
    if (valid(cmdr)) {
        cmdr.Load();
        cmdr.Erase();
    }

    ResetCommander(cr);
}

// Сброс глобальной переменной и переменных командира
void ResetCommander(Critter cr)
{
    cr.VCGuardsmanTriggerPlayerId = ZERO_IDENT;
    Game.VCHartmanMarchStatus = false;
}

// Проверка, что игрок в нужной позиции и запуск очереди приказов
void TimeToStart(any[] values)
{
    Critter npc = Game.GetCritter(values[0]);
    Critter player = Game.GetCritter(values[1]);
    if (!valid(npc) || !valid(player)) {
        return;
    }
    if (player.Hex.x != POS_X || player.Hex.y != POS_Y) // Игрок не находится в нужной позиции
    {
        if (values[2] > 5) // Максимум 5 проверок, потом заново
        {
            ResetCommander(npc);
            return;
        }
        values[2] = int(values[2]) + 1;
        Messaging::SayShoutOnHead(npc, TextPackName::Text, STR_WRONG_POSITION);
        Game.StartTimeEvent(Time::Seconds(5), TimeToStart, values);
        return;
    }
    if (Game.VCHartmanMarchStatus) {
        ResetCommander(npc);
        return;
    }
    Game.VCHartmanMarchStatus = true;
    Map map = npc.GetMap(); // Поиск нпц-гвардейцев
    Critter[] critters = map.GetCritters(CritterProperty::NpcRole, ROLE_MARCH, CritterFindType::NonDeadNpc);
    any[] valuesNew = {0, npc.Id, player.Id};
    SquadCommander cmdr = SquadCommander(npc);
    cmdr.Squad.insertLast(player.Id);
    for (int i = 0; i < critters.length(); i++) {
        Critter cr = critters[i];
        MarchQueue q = MarchQueue(cr);
        q.Erase();
        q.AddOrder(DefineDirection(5, 0, 0));
        q.AddOrder(DefineMove(3, 5, false, 0, 0));
        q.AddOrder(DefineDirection(2, 0, 0));
        q.AddOrder(DefineArmWeapon(true, 0, 0));
        q.AddOrder(DefineArmWeapon(false, 0, 0));
        q.AddOrder(DefineMove(5, 2, true, 0, 0));
        q.AddOrder(DefineDirection(5, 0, 0));
        q.AddOrder(DefineMove(2, 5, false, 0, 0));
        q.Save();
        cmdr.Squad.insertLast(cr.Id);
    }
    cmdr.Save();
    MarchQueue q = MarchQueue(player);
    q.Erase();
    q.AddOrder(DefineDirection(5, 0, 0));
    q.AddOrder(DefineMove(3, 5, false, 0, 0));
    q.AddOrder(DefineDirection(2, 0, 0));
    q.AddOrder(DefineArmWeapon(true, 0, 0));
    q.AddOrder(DefineArmWeapon(false, 0, 0));
    q.AddOrder(DefineMove(5, 2, true, 0, 0));
    q.AddOrder(DefineDirection(5, 0, 0));
    q.AddOrder(DefineMove(2, 5, false, 0, 0));
    q.Save();
    Game.StartTimeEvent(Time::Seconds(3), NextGuardOrder, valuesNew);
}

// Время отдавать новый приказ
void NextGuardOrder(any[] values)
{
    Critter cr = Game.GetCritter(values[1]);
    if (!valid(cr)) {
        return;
    }

    SquadCommander cmdr = SquadCommander(cr);
    cmdr.Load();
    if (cmdr.CheckCommandExecuted()) {
        cmdr.Command(values[0]);
        values[0] = int(values[0]) + 1;
    }
    else {
        Messaging::Say(cr, TextPackName::Dialogs, DLGSTR(cr.DialogId, STR_MARCH_FAILED));
        ResetCommander(cr);
        cmdr.Erase();
        return;
    }

    if (values[0] == LAST_ORDER) {
        Messaging::Say(cr, TextPackName::Dialogs, DLGSTR(cr.DialogId, STR_MARCH_COMPLETED));
        ResetCommander(cr);
        cmdr.Erase();
        Critter player = Game.GetCritter(values[2]);
        if (valid(player) && player.VCHartmanMarch == 2) {
            player.VCHartmanMarch = 3;
        }
        return;
    }

    Game.StartTimeEvent(Time::Seconds(6), NextGuardOrder, values);
}

// Бонусы Гвардии для игроков
#define CTE_ID_SALARY     (224)
#define PRIVATE_MONEY     (68)  // Жалование рядового
#define JSERGEANT_MONEY   (98)  // Жалование младшего сержанта
#define SSERGEANT_MONEY   (151) // Жалование старшего сержанта
#define LEUTENANT_MONEY   (360) // Жалование лейтенанта
#define RANK_NONE         (0)
#define RANK_PRIVATE      (1)
#define RANK_JUN_SERGEANT (2)
#define RANK_SEN_SERGEANT (3)
#define RANK_LEUTENANT    (4)

// Ежедневное жалование
void r_SetGuardSalary(Critter player, Critter npc)
{
    player.StartTimeEvent(Time::GameDays(1), cte_GuardsmanSalary);
}

int GetRank(Critter cr)
{
    return cr.VCGuardRank;
}

void cte_GuardsmanSalary(Critter cr)
{
    int rank = GetRank(cr);
    int money = 0;
    switch (rank) {
    case RANK_PRIVATE:
        money = PRIVATE_MONEY;
        break;
    case RANK_JUN_SERGEANT:
        money = JSERGEANT_MONEY;
        break;
    case RANK_SEN_SERGEANT:
        money = SSERGEANT_MONEY;
        break;
    case RANK_LEUTENANT:
        money = LEUTENANT_MONEY;
        break;
    default:
        break;
    }

    hstring[] mapPids = {Content::Map::repl_bank_den,
                         Content::Map::repl_bank_klamath,
                         Content::Map::repl_bank_redding,
                         Content::Map::repl_bank_modoc,
                         Content::Map::repl_bank_newreno,
                         Content::Map::repl_bank_gecko,
                         Content::Map::repl_bank_broken,
                         Content::Map::repl_bank_ncr,
                         Content::Map::repl_bank_sf,
                         Content::Map::repl_bank_vcity,
                         Content::Map::repl_ground,
                         Content::Map::repl1,
                         Content::Map::repl2,
                         Content::Map::repl3,
                         Content::Map::repl4,
                         Content::Map::repl_hell,
                         Content::Map::repl4a,
                         Content::Map::repl_ground4};

    Map map = cr.GetMap();
    if (valid(map) && mapPids.find(map.ProtoId) != -1) {
        timespan delayTicks = Time::GameDays(5);
        if (delayTicks != ZERO_TIMESPAN) {
            Game.RepeatCurrentTimeEvent(delayTicks);
        }
    }

    cr.ReplicationMoney += money;
    timespan delayTicks = Time::GameDays(1);
    if (delayTicks != ZERO_TIMESPAN) {
        Game.RepeatCurrentTimeEvent(delayTicks);
    }
}

// Квест Пойди туда - не знаю куда
void _MutantsCaveInit(Map map, bool firstTime)
{
    map.OnCritterIn.Subscribe(_CaveInCritter);
}

void _CaveInCritter(Map map, Critter cr)
{
    Location loc = map.GetLocation();
    if (valid(loc)) {
        loc.AutoGarbage = true;
    }
    Critter[] mutants = map.GetCritters(CritterFindType::NonDeadNpc);
    for (int i = 0; i < mutants.length(); i++) {
        Critter npc = mutants[i];
        if (!EnemyStack::CheckEnemyInStack(npc, cr.Id)) {
            EnemyStack::AddEnemyToStack(npc, cr.Id);
        }
    }
    if (cr.VCHartmannRecon == 2) {
        cr.VCHartmannRecon = 3;
    }
}

void _MutantsOutGroundInit(Map map, bool firstTime)
{
    map.OnCritterIn.Subscribe(_OutGroundInCritter);
    Location loc = map.GetLocation();
    if (valid(loc)) {
        Game.StartTimeEvent(Time::GameDays(3), DeleteQuestLocation, loc.Id); //SavedDeferredCall
    }
}

void DeleteQuestLocation(any value)
{
    Location loc = Game.GetLocation(ident(value));
    if (valid(loc)) {
        loc.AutoGarbage = true;
    }
}

void _OutGroundInCritter(Map map, Critter cr)
{
    if (!cr.ControlledByPlayer) {
        return;
    }
    if (cr.VCHartmannRecon != 2) {
        return;
    }
    Location loc = map.GetLocation();
    if (valid(loc) && cr.VCReconCaveId == ZERO_IDENT) {
        cr.VCReconCaveId = loc.Id;
        loc.AutoGarbage = false;
        Location::SetKnownLoc(cr, loc);
    }
}

// Опасная Охота

void r_ShowCave(Critter player, Critter npc)
{
    if (player.VCReconCaveId == ZERO_IDENT) {
        return;
    }

    Location loc = Game.GetLocation(player.VCReconCaveId);
    if (valid(loc) && loc.ProtoId == Content::Location::vc_recon_mutants) {
        int x = loc.WorldPos.x;
        int y = loc.WorldPos.y;
        Game.DestroyLocation(loc.Id);
        HostileLocationQuest::r_ShowLocation(player,
                                             npc,
                                             int(CritterProperty::VCHartmannClearCave),
                                             int(CritterProperty::VCDeadAllyCounter),
                                             Content::Location::vc_recon.hash,
                                             x,
                                             y);
    }
    else {
        int x = 1168;
        int y = 418;
        HostileLocationQuest::r_ShowLocation2(player,
                                              npc,
                                              int(CritterProperty::VCHartmannClearCave),
                                              int(CritterProperty::VCDeadAllyCounter),
                                              Content::Location::vc_recon.hash,
                                              x,
                                              y);
    }
}

// Нанимаемый мутант

void _CharleyInit(Critter cr, bool firstTime)
{
    cr.MaxLifeBase = 600;
    cr.CurrentHp = cr.MaxLife;
    cr.SkillBarter = 1;
    cr.ActionPointsBase = 12;
    cr.SkillBigGuns = 250;
}

#endif

}
