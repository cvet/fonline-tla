// FOS Server Client
// Author: cvet

void ModuleInit()
{
    __EventCritterGetUseApCost.Subscribe( get_use_ap_cost );
    __EventCritterGetAttackDistantion.Subscribe( get_attack_distantion );
}

#ifndef __CLIENT
void CritterSetExperience( const Critter cr, CritterProperty prop, int& newValue )
{
    if( cr.Level >= int(__LevelCap) && not __LevelCapAddExperience )
    {
        newValue = cr.Experience;
        return;
    }

    int exp = newValue - cr.Experience;
    if( exp > 0 )
    {
        // SwiftLearner perk
        exp += exp * ( cr.PerkSwiftLearner * 5 ) / 100; // SwiftLearner perk

        // Process new experience
        if( cr.Level < int(__LevelCap) )
            DeferredCall( 0, UpdateExperienceLevel, cr.Id );
    }
}

void UpdateExperienceLevel( uint crId )
{
    Critter cr = GetCritter( crId );
    if( cr is null )
        return;

    while( cr.Level < int(__LevelCap) && cr.Experience >= NextLevelNeedExp( cr ) )
    {
        cr.Level += 1;

        // Skill points
        cr.UnspentSkillPoints += 5 + cr.IntellectBase * 2;

        // Skilled trait
        if( cr.IsTraitSkilled )
            cr.UnspentSkillPoints += 5;

        // Educated perk
        cr.UnspentSkillPoints += cr.PerkEducated * 2;

        // Clamp skill points
        if( cr.UnspentSkillPoints > 99 )
            cr.UnspentSkillPoints = 99;

        // Add max hp
        if( __MaxLifeLevelSoftCap == 0 || uint( cr.Level ) <= __MaxLifeLevelSoftCap )
            cr.MaxLifeBase += 2 + cr.EnduranceBase / 2 + cr.PerkLifegiver * 4;

        // Add perk
        if( ( cr.Level % ( cr.IsTraitSkilled ? 4 : 3 ) ) == 0 )
            cr.UnspentPerks = 1;
    }
}

void CritterSetPerks( const Critter cr, CritterProperty perk, uint& newValue )
{
    uint8 curValue = cr.GetAsInt( perk );
    uint[] values = { cr.Id, perk, MAX( newValue, curValue ) - MIN( newValue, curValue ), newValue > curValue ? 1 : 0 };
    DoPerkUpDown( values );
    // DeferredCall( 0, DoPerkUpDown, array< uint > = { cr.Id, perk, MAX( newValue, curValue ) - MIN( newValue, curValue ), newValue > curValue ? 1 : 0 } );
}

void DoPerkUpDown( uint[] values )
{
    Critter cr = GetCritter( values[ 0 ] );
    if( cr is null )
        return;
    CritterProperty perk = CritterProperty( values[ 1 ] );
    // target.GetAsInt( CritterProperty( stat ) )
    uint            count = values[ 2 ];
    bool            up = values[ 3 ] != 0;
    for( uint i = 0; i < count; i++ )
    {
        if( up )
            Perks::PerkUp( cr, perk );
        else
            Perks::PerkDown( cr, perk );
    }
}

void CritterSetHide( Critter cr )
{
    cr.RefreshVisible();
}

void CritterSetFastShot( Critter cr )
{
    cr.IsNoAim = cr.IsTraitFastShot;
}

void CritterSetKnownLocations( Critter cr )
{
    uint[] knownLoc = cr.KnownLocations.clone();
    hash[] knownLocPid = {};
    for( uint i = 0; i < knownLoc.length(); i++ )
    {
        Location loc = GetLocation( knownLoc[ i ] );
        if( loc !is null )
            knownLocPid.insertLast( loc.ProtoId );
    }
    cr.KnownLocProtoId = knownLocPid;
}

int NextLevelNeedExp( Critter cr ) // Export
{
    int level = cr.Level;
    return NUMERICAL_NUMBER( level ) * 1000;
}
#endif

#ifdef __CLIENT
void CritterSetPropertyQuests( const Critter cr, CritterProperty prop )
{
    uint str = hash( prop ) + cr.GetAsInt( prop );
    if( IsMsgStr( TEXTMSG_QUEST, str ) )
        Message( GetMsgStr( TEXTMSG_QUEST, str ) );
}

void CritterSetLevel( const Critter cr, CritterProperty, int& newValue )
{
    if( newValue > cr.Level )
    {
        PlaySound( "LEVELUP.ACM" );
        Message( TEXTMSG_GAME, MsgStr::StrGainLevelup, FOMB_GAME );
        ChosenTabs::SetChosenTabLevelUp( true );
    }
}

void CritterSetExperience( const Critter cr, CritterProperty, int& newValue )
{
    if( newValue > cr.Experience )
        Message( ReplaceText( GetMsgStr( TEXTMSG_GAME, MsgStr::StrGainExperience ), "VALUE", newValue - cr.Experience ), FOMB_GAME );
}

void CritterSetUnspentPerks( Critter cr )
{
    if( cr.UnspentPerks > 0 && Gui::GetActiveScreen().Index == CLIENT_SCREEN_CHARACTER )
        ShowScreen( CLIENT_SCREEN_PERK );
}
#endif

// Parameters generation
// For server and client
// Both generation need be equal
// Input for player: 7 special, 3 tag skills, 2 traits, age, gender
// Imput for npc: data from prototype
void CritterGenerate( dict< CritterProperty, int > props )
{
    props.setIfNotExist( CritterProperty::StrengthBase, 0 );
    props.setIfNotExist( CritterProperty::PerceptionBase, 0 );
    props.setIfNotExist( CritterProperty::EnduranceBase, 0 );
    props.setIfNotExist( CritterProperty::CharismaBase, 0 );
    props.setIfNotExist( CritterProperty::IntellectBase, 0 );
    props.setIfNotExist( CritterProperty::AgilityBase, 0 );
    props.setIfNotExist( CritterProperty::LuckBase, 0 );
    props.setIfNotExist( CritterProperty::HealingRateBase, 0 );
    props.setIfNotExist( CritterProperty::ActionPointsBase, 0 );
    props.setIfNotExist( CritterProperty::ArmorClassBase, 0 );
    props.setIfNotExist( CritterProperty::SequenceBase, 0 );
    props.setIfNotExist( CritterProperty::MeleeDamageBase, 0 );
    props.setIfNotExist( CritterProperty::CriticalChanceBase, 0 );
    props.setIfNotExist( CritterProperty::MaxCriticalBase, 0 );
    props.setIfNotExist( CritterProperty::IsNoAim, 0 );
    props.setIfNotExist( CritterProperty::MaxLifeBase, 0 );
    props.setIfNotExist( CritterProperty::CarryWeightBase, 0 );
    props.setIfNotExist( CritterProperty::CurrentAp, 0 );
    props.setIfNotExist( CritterProperty::CurrentHp, 0 );
    props.setIfNotExist( CritterProperty::Level, 0 );
    props.setIfNotExist( CritterProperty::TagSkill1, CritterProperty::Invalid );
    props.setIfNotExist( CritterProperty::TagSkill2, CritterProperty::Invalid );
    props.setIfNotExist( CritterProperty::TagSkill3, CritterProperty::Invalid );
    for( uint i = 0; i < CritterPropertySkills.length(); i++ )
        props.setIfNotExist( CritterPropertySkills[ i ], 0 );
    for( uint i = 0; i < CritterPropertyPerks.length(); i++ )
        props.setIfNotExist( CritterPropertyPerks[ i ], 0 );
    for( uint i = 0; i < CritterPropertyTraits.length(); i++ )
        props.setIfNotExist( CritterPropertyTraits[ i ], 0 );
    for( uint i = 0; i < CritterPropertyResistsBase.length(); i++ )
        props.setIfNotExist( CritterPropertyResistsBase[ i ], 0 );
    for( uint i = 0; i < CritterPropertyThresholdsBase.length(); i++ )
        props.setIfNotExist( CritterPropertyThresholdsBase[ i ], 0 );

    if( props[ CritterProperty::Level ] <= 0 )
        props[ CritterProperty::Level ] = 1;

    if( props[ CritterProperty::IsTraitSmallFrame ] != 0 )
        props[ CritterProperty::AgilityBase ] = props[ CritterProperty::AgilityBase ] + 1;
    if( props[ CritterProperty::IsTraitBruiser ] != 0 )
        props[ CritterProperty::StrengthBase ] = props[ CritterProperty::StrengthBase ] + 2;
    if( props[ CritterProperty::IsTraitGoodNatured ] != 0 )
    {
        props[ CritterProperty::SkillFirstAid ] = props[ CritterProperty::SkillFirstAid ] + 15;
        props[ CritterProperty::SkillDoctor ] = props[ CritterProperty::SkillDoctor ] + 15;
        props[ CritterProperty::SkillSpeech ] = props[ CritterProperty::SkillSpeech ] + 15;
        props[ CritterProperty::SkillBarter ] = props[ CritterProperty::SkillBarter ] + 15;
        props[ CritterProperty::SkillSmallGuns ] = props[ CritterProperty::SkillSmallGuns ] - 10;
        props[ CritterProperty::SkillBigGuns ] = props[ CritterProperty::SkillBigGuns ] - 10;
        props[ CritterProperty::SkillEnergyWeapons ] = props[ CritterProperty::SkillEnergyWeapons ] - 10;
        props[ CritterProperty::SkillUnarmed ] = props[ CritterProperty::SkillUnarmed ] - 10;
        props[ CritterProperty::SkillMeleeWeapons ] = props[ CritterProperty::SkillMeleeWeapons ] - 10;
        props[ CritterProperty::SkillThrowing ] =  props[ CritterProperty::SkillThrowing ] - 10;
    }

    props[ CritterProperty::SkillSmallGuns ] = props[ CritterProperty::SkillSmallGuns ] + ( 5 + 4 * props[ CritterProperty::AgilityBase ] );
    props[ CritterProperty::SkillBigGuns ] = props[ CritterProperty::SkillBigGuns ] + ( 0 + 2 * props[ CritterProperty::AgilityBase ] );
    props[ CritterProperty::SkillEnergyWeapons ] = props[ CritterProperty::SkillEnergyWeapons ] + ( 0 + 2 * props[ CritterProperty::AgilityBase ] );
    props[ CritterProperty::SkillUnarmed ] = props[ CritterProperty::SkillUnarmed ] + ( 30 + 2 * ( props[ CritterProperty::AgilityBase ] + props[ CritterProperty::StrengthBase ] ) );
    props[ CritterProperty::SkillMeleeWeapons ] = props[ CritterProperty::SkillMeleeWeapons ] + ( 20 + 2 * ( props[ CritterProperty::AgilityBase ] + props[ CritterProperty::StrengthBase ] ) );
    props[ CritterProperty::SkillThrowing ] = props[ CritterProperty::SkillThrowing ] + ( 0 + 4 * props[ CritterProperty::AgilityBase ] );
    props[ CritterProperty::SkillFirstAid ] = props[ CritterProperty::SkillFirstAid ] + ( 0 + 2 * ( props[ CritterProperty::PerceptionBase ] + props[ CritterProperty::IntellectBase ] ) );
    props[ CritterProperty::SkillDoctor ] = props[ CritterProperty::SkillDoctor ] + ( 5 + props[ CritterProperty::PerceptionBase ] + props[ CritterProperty::IntellectBase ] );
    props[ CritterProperty::SkillSneak ] = props[ CritterProperty::SkillSneak ] + ( 5 + 3 * props[ CritterProperty::AgilityBase ] );
    props[ CritterProperty::SkillLockpick ] = props[ CritterProperty::SkillLockpick ] + ( 10 + props[ CritterProperty::PerceptionBase ] + props[ CritterProperty::AgilityBase ] );
    props[ CritterProperty::SkillSteal ] = props[ CritterProperty::SkillSteal ] + ( 0 + 3 * props[ CritterProperty::AgilityBase ] );
    props[ CritterProperty::SkillTraps ] = props[ CritterProperty::SkillTraps ] + ( 10 + props[ CritterProperty::PerceptionBase ] + props[ CritterProperty::AgilityBase ] );
    props[ CritterProperty::SkillScience ] = props[ CritterProperty::SkillScience ] + ( 0 + 4 * props[ CritterProperty::IntellectBase ] );
    props[ CritterProperty::SkillRepair ] = props[ CritterProperty::SkillRepair ] + ( 0 + 3 * props[ CritterProperty::IntellectBase ] );
    props[ CritterProperty::SkillSpeech ] = props[ CritterProperty::SkillSpeech ] + ( 0 + 5 * props[ CritterProperty::CharismaBase ] );
    props[ CritterProperty::SkillBarter ] = props[ CritterProperty::SkillBarter ] + ( 0 + 4 * props[ CritterProperty::CharismaBase ] );
    props[ CritterProperty::SkillGambling ] = props[ CritterProperty::SkillGambling ] + ( 0 + 5 * props[ CritterProperty::LuckBase ] );
    props[ CritterProperty::SkillOutdoorsman ] = props[ CritterProperty::SkillOutdoorsman ] + ( 0 + 2 * ( props[ CritterProperty::EnduranceBase ] + props[ CritterProperty::IntellectBase ] ) );

    if( props[ CritterProperty::TagSkill1 ] != CritterProperty::Invalid )
        props[ CritterProperty( props[ CritterProperty::TagSkill1 ] ) ] = props[ CritterProperty( props[ CritterProperty::TagSkill1 ] ) ] + 20;
    if( props[ CritterProperty::TagSkill2 ] != CritterProperty::Invalid )
        props[ CritterProperty( props[ CritterProperty::TagSkill2 ] ) ] = props[ CritterProperty( props[ CritterProperty::TagSkill2 ] ) ] + 20;
    if( props[ CritterProperty::TagSkill3 ] != CritterProperty::Invalid )
        props[ CritterProperty( props[ CritterProperty::TagSkill3 ] ) ] = props[ CritterProperty( props[ CritterProperty::TagSkill3 ] ) ] + 20;

    if( props[ CritterProperty::IsTraitFastMetabolism ] != 0 )
    {
        props[ CritterProperty::RadiationResistanceBase ] = props[ CritterProperty::RadiationResistanceBase ] - props[ CritterProperty::EnduranceBase ] * 2;
        props[ CritterProperty::PoisonResistanceBase ] = props[ CritterProperty::PoisonResistanceBase ] - props[ CritterProperty::EnduranceBase ] * 5;
        props[ CritterProperty::HealingRateBase ] = props[ CritterProperty::HealingRateBase ] + 2;
    }
    if( props[ CritterProperty::IsTraitBruiser ] != 0 )
        props[ CritterProperty::ActionPointsBase ] = props[ CritterProperty::ActionPointsBase ] - 2;
    if( props[ CritterProperty::IsTraitKamikaze ] != 0 )
    {
        props[ CritterProperty::ArmorClassBase ] = props[ CritterProperty::ArmorClassBase ] - props[ CritterProperty::AgilityBase ];
        props[ CritterProperty::SequenceBase ] = props[ CritterProperty::SequenceBase ] + 5;
    }
    if( props[ CritterProperty::IsTraitHeavyHanded ] != 0 )
        props[ CritterProperty::MeleeDamageBase ] = props[ CritterProperty::MeleeDamageBase ] + 4;
    if( props[ CritterProperty::IsTraitFinesse ] != 0 )
        props[ CritterProperty::CriticalChanceBase ] = props[ CritterProperty::CriticalChanceBase ] + 10;
    if( props[ CritterProperty::IsTraitHeavyHanded ] != 0 )
        props[ CritterProperty::MaxCriticalBase ] = props[ CritterProperty::MaxCriticalBase ] - 30;
    if( props[ CritterProperty::IsTraitFastShot ] != 0 )
        props[ CritterProperty::IsNoAim ] = 1;

    #ifdef __CLIENT
    // Runtime calculations, only for client registration
    props[ CritterProperty::ArmorClassBase ] = props[ CritterProperty::ArmorClassBase ] + ( props[ CritterProperty::AgilityBase ] );
    props[ CritterProperty::MaxLifeBase ] = props[ CritterProperty::MaxLifeBase ] + ( props[ CritterProperty::StrengthBase ] + props[ CritterProperty::EnduranceBase ] * 2 );
    props[ CritterProperty::ActionPointsBase ] = props[ CritterProperty::ActionPointsBase ] + ( props[ CritterProperty::AgilityBase ] / 2 );
    props[ CritterProperty::CarryWeightBase ] = props[ CritterProperty::CarryWeightBase ] + ( LBS_TO_GRAMM( 25 + props[ CritterProperty::StrengthBase ] * ( 25 - props[ CritterProperty::IsTraitSmallFrame ] * 10 ) ) );
    props[ CritterProperty::MeleeDamageBase ] = props[ CritterProperty::MeleeDamageBase ] + ( ( props[ CritterProperty::StrengthBase ] > 6 ? props[ CritterProperty::StrengthBase ] - 5 : 1 ) );
    props[ CritterProperty::PoisonResistanceBase ] = props[ CritterProperty::PoisonResistanceBase ] + ( props[ CritterProperty::EnduranceBase ] * 5 );
    props[ CritterProperty::RadiationResistanceBase ] = props[ CritterProperty::RadiationResistanceBase ] + ( props[ CritterProperty::EnduranceBase ] * 2 );
    props[ CritterProperty::SequenceBase ] = props[ CritterProperty::SequenceBase ] + ( props[ CritterProperty::PerceptionBase ] * 2 );
    props[ CritterProperty::HealingRateBase ] = props[ CritterProperty::HealingRateBase ] + ( MAX( 1, props[ CritterProperty::EnduranceBase ] / 3 ) );
    props[ CritterProperty::CriticalChanceBase ] = props[ CritterProperty::CriticalChanceBase ] + ( props[ CritterProperty::LuckBase ] );
    #endif

    props[ CritterProperty::MaxLifeBase ] = props[ CritterProperty::MaxLifeBase ] + 15;
    props[ CritterProperty::ActionPointsBase ] = props[ CritterProperty::ActionPointsBase ] + 5;
    props[ CritterProperty::CurrentHp ] = props[ CritterProperty::MaxLifeBase ];
    props[ CritterProperty::CurrentAp ] = props[ CritterProperty::ActionPointsBase ] * 100;
}

#ifdef __CLIENT

dict< CritterProperty, int > GenerateRegProps()
{
    dict< CritterProperty, int > regProps = {};
    regProps[ CritterProperty::StrengthBase ] = 5;
    regProps[ CritterProperty::PerceptionBase ] = 5;
    regProps[ CritterProperty::EnduranceBase ] = 5;
    regProps[ CritterProperty::CharismaBase ] = 5;
    regProps[ CritterProperty::IntellectBase ] = 5;
    regProps[ CritterProperty::AgilityBase ] = 5;
    regProps[ CritterProperty::LuckBase ] = 5;
    regProps[ CritterProperty::Age ] = Random( Tla::AgeMin, Tla::AgeMax );
    regProps[ CritterProperty::Gender ] = Gender::Male;
    regProps[ CritterProperty::TagSkill1 ] = CritterProperty::Invalid;
    regProps[ CritterProperty::TagSkill2 ] = CritterProperty::Invalid;
    regProps[ CritterProperty::TagSkill3 ] = CritterProperty::Invalid;
    for( uint i = 0; i < CritterPropertyTraits.length(); i++ )
        regProps.setIfNotExist( CritterPropertyTraits[ i ], 0 );
    return regProps;
}

// Check valid of input data
bool CritterGenerateCheck( dict< CritterProperty, int > props )
{
    // Check name
    uint nameError = CheckPlayerName( GetCacheDataStr( "RegName__" ) );
    if( nameError != 0 )
    {
        Message( GetMsgStr( TEXTMSG_GAME, nameError ) );
        return false;
    }

    // Check special
    int special = 0;
    for( uint i = 0; i < CritterPropertySpecialBase.length(); i++ )
    {
        if( props[ CritterPropertySpecialBase[ i ] ] < 1 || props[ CritterPropertySpecialBase[ i ] ] > 10 )
        {
            Log( "checking params" );
            Message( GetMsgStr( TEXTMSG_GAME, MsgStr::StrNetWrongSpecial ) );
            return false;
        }
        special += props[ CritterPropertySpecialBase[ i ] ];
    }
    if( special != __StartSpecialPoints )
    {
        Message( GetMsgStr( TEXTMSG_GAME, MsgStr::StrNetWrongSpecial ) );
        return false;
    }

    // Check choosed tag skills
    if( ( props[ CritterProperty::TagSkill1 ] != CritterProperty::Invalid && CritterPropertySkills.find( CritterProperty( props[ CritterProperty::TagSkill1 ] ) ) == -1 ) ||
        ( props[ CritterProperty::TagSkill2 ] != CritterProperty::Invalid && CritterPropertySkills.find( CritterProperty( props[ CritterProperty::TagSkill2 ] ) ) == -1 ) ||
        ( props[ CritterProperty::TagSkill3 ] != CritterProperty::Invalid && CritterPropertySkills.find( CritterProperty( props[ CritterProperty::TagSkill3 ] ) ) == -1 ) )
    {
        Message( GetMsgStr( TEXTMSG_GAME, MsgStr::StrNetWrongTagskill ) );
        return false;
    }
    return true;
}
#endif

#ifndef __CLIENT
void NpcProcessLevel( Critter npc ) // Export
{
    for( int i = 0, j = npc.Level; i < j; i++ )
    {
        // Todo: ...
        // npc.MaxLife += 10;
    }
}

int CritterGetSneakCoefficient( const Critter cr )
{
    return cr.SkillSneak;
}

int CritterGetBarterCoefficient( const Critter cr )
{
    return cr.SkillBarter;
}
#endif

uint CheckPlayerName( string name )
{
    // Length
    if( name.length() < __MinNameLength || name.length() > __MaxNameLength )
        return MsgStr::StrNetLoginpassWrong;

    // Valid letters
    string allLetters = __ValidNameLettersCommon + __ValidNameLettersCulture1 + __ValidNameLettersCulture2;

    for( uint i = 0, j = name.length(); i < j; i++ )
    {
        if( allLetters.findFirst( name[ i ]   ) == -1 )
        {
            return MsgStr::StrNetPassWrongChars;
        }
    }
    // Spaces
    if( name[ 0 ] == " " || name[ -1 ] == " " )
        return MsgStr::StrNetBeginEndSpaces;
    for( int i = 0, j = name.length() - 1; i < j; i++ )
        if( name[ i ] == " " && name[ i + 1 ] == " " )
            return MsgStr::StrNetTwoSpace;
    // Different cultures
    uint letters1 = 0;
    uint letters2 = 0;
    for( int i = 0, j = name.length() - 1; i < j; i++ )
    {
        if( __ValidNameLettersCulture1.findFirst( name[ i ] ) != -1 )
            letters1++;
        else if( __ValidNameLettersCulture2.findFirst( name[ i ] ) != -1 )
            letters2++;
    }

    if( letters1 > 0 && letters2 > 0 )
        return MsgStr::StrNetDifferentLang;
    // Too many common symbols
    if( ( letters1 + letters2 ) * 100 / name.length() < 70 )
        return MsgStr::StrNetManySymbols;

    // All fine, return zero
    return 0;
}

// Unarmed item
#pragma content Item unarmed_strong_punch
#pragma content Item unarmed_hammer_punch
#pragma content Item unarmed_haymaker
#pragma content Item unarmed_jab
#pragma content Item unarmed_palm_strike
#pragma content Item unarmed_piercing_strike
#pragma content Item unarmed_kick
#pragma content Item unarmed_strong_kick
#pragma content Item unarmed_snap_kick
#pragma content Item unarmed_power_kick
#pragma content Item unarmed_hip_kick
#pragma content Item unarmed_hook_kick
#pragma content Item unarmed_piercing_kick

hash[] UnarmedWeapons =
{
    0, // Content::Item::default_weapon,
    Content::Item::unarmed_strong_punch,
    Content::Item::unarmed_hammer_punch,
    Content::Item::unarmed_haymaker,
    Content::Item::unarmed_jab,
    Content::Item::unarmed_palm_strike,
    Content::Item::unarmed_piercing_strike,
    Content::Item::unarmed_kick,
    Content::Item::unarmed_strong_kick,
    Content::Item::unarmed_snap_kick,
    Content::Item::unarmed_power_kick,
    Content::Item::unarmed_hip_kick,
    Content::Item::unarmed_hook_kick,
    Content::Item::unarmed_piercing_kick,
};

bool VerifyUnarmedItem( const Critter cr, hash pid )
{
    if( pid == 0 )
        return true;
    if( !UnarmedWeapons.exists( pid ) )
        return false;
    const Item proto = GetProtoItem( pid );
    if( cr.Strength < proto.Weapon_MinStrength || cr.Agility < proto.Weapon_UnarmedMinAgility )
    {
        return false;
    }
    if( cr.Level < proto.Weapon_UnarmedMinLevel || cr.SkillUnarmed < proto.Weapon_UnarmedMinUnarmed )
    {
        return false;
    }
    return true;
}

#ifdef __CLIENT
void SwitchUnarmedWeapon( Critter cr, bool next )
{
    hash       curPid = cr.HandsItemProtoId;
    const Item proto = GetProtoItem( curPid != 0 ? curPid : Content::Item::default_weapon );
    uint8      mode = cr.HandsItemMode;
    uint8      use = mode & 0xF;
    uint8      aim = mode >> 4;
    if( next && aim == HitLocations::LocationNone && !cr.IsNoAim && _WeaponAim( proto, use ) )
    {
        aim = HitLocations::LocationTorso;
        cr.HandsItemMode = use | ( aim << 4 );
        return;
    }

    if( !next && aim != HitLocations::LocationNone )
    {
        aim = HitLocations::LocationNone;
        cr.HandsItemMode = use | ( aim << 4 );
        return;
    }

    int index = UnarmedWeapons.find( curPid );
    if( index != -1 )
    {
        int startIndex = index;
        while( true )
        {
            index += ( next ? 1 : -1 );
            if( index >= int( UnarmedWeapons.length() ) )
                index = 0;
            else if( index < 0 )
                index = UnarmedWeapons.length() - 1;

            if( index == startIndex )
                break;
            if( VerifyUnarmedItem( cr, UnarmedWeapons[ index ] ) )
                break;
        }
    }
    else
    {
        index = 0;
    }

    hash pid = UnarmedWeapons[ index ];
    if( pid != curPid  )
    {
        cr.HandsItemMode = 0;
        cr.HandsItemProtoId = pid;

        proto = GetProtoItem( pid != 0 ? pid : Content::Item::default_weapon );
        if( !next && !cr.IsNoAim && _WeaponAim( proto, 0 ) )
        {
            aim = HitLocations::LocationTorso;
            cr.HandsItemMode = aim << 4;
        }
    }
}

void UseMainItem()
{
    Critter chosen = GetChosen();
    if( chosen is null )
        return;

    const Item item = chosen.GetItemBySlot( SLOT_HAND1 );
    if( __Cursor == CursorType::UseWeapon )
    {
        __Cursor = CursorType::Default;
        return;
    }
    if( item is null )
    {
        __Cursor = CursorType::UseWeapon;
    }
    else
    {

        uint8 mode = item.Mode;
        uint8 use = _WeaponModeUse( mode );
        uint8 aim = _WeaponModeAim( mode );
        if( mode == USE_RELOAD )
        {
            ChosenActions::SetChosenActions( array< uint > = { TlaExtended::ChosenUseItem, item.Id, 0, TARGET_SELF_ITEM, 0, USE_RELOAD, 0 } );
        }
        else if( mode < MAX_USES && item.Type == ItemType::Weapon )
        {
            __Cursor = CursorType::UseWeapon;
        }
        else if( mode == USE_USE && item.IsCanUseOnSmth )
        {
            // Self->CurUseItem = 0;
            // Self->SetCurMode( CUR_USE_ITEM );
            __Cursor = CursorType::UseItem;
        }
        else if( mode == USE_USE && item.IsCanUse )
        {
            // Отдельная ветка на юз с таймером
            ShowScreen( CLIENT_SCREEN_TIMER, dictionary = { { "TargetItemId", item.Id } } );
        }
    }
}

void SwitchMainItemMode( bool next )
{
    Critter chosen = GetChosen();
    if( chosen is null )
        return;

    const Item item = chosen.GetItemBySlot( SLOT_HAND1 );
    if( item is null )
    {
        SwitchUnarmedWeapon( chosen, next );
    }
    else
    {
        if( item.Type != ItemType::Weapon )
        {
            if( item.IsCanUseOnSmth && item.IsCanUse )
            {
                SetWeaponMode( item, USE_USE );
            }
            else
            {
                SetWeaponMode( item, USE_NONE );
            }
        }
        else
        {
            uint8 use = _WeaponModeUse( item.Mode );
            uint8 aim = _WeaponModeAim( item.Mode );

            while( true )
            {
                if( next )
                {
                    if( _WeaponAim( item, use ) && aim == 0 && !chosen.IsNoAim )                     // && CritType::IsCanAim( GetCrType() )
                    {
                        aim = HitLocations::LocationTorso;
                        break;
                    }
                    else
                    {
                        use = use + 1;
                        aim = HitLocations::LocationNone;
                    }
                }
                else
                {
                    if( aim > 0 && _WeaponAim( item, use ) )
                    {
                        aim = HitLocations::LocationNone;
                        break;
                    }
                    if( use == 0 )
                        use = ( item.IsCanUseOnSmth ? USE_USE : USE_RELOAD );
                    else
                        use = use - 1;
                    if( _WeaponAim( item, use ) && aim == 0 && !chosen.IsNoAim )                     // && CritType::IsCanAim( GetCrType() )
                    {
                        aim = HitLocations::LocationTorso;
                        break;
                    }
                }

                switch( use )
                {
                case USE_PRIMARY:
                    if( _WeaponIsPrimaryAviable( item ) )
                        break;
                    continue;
                case USE_SECONDARY:
                    if( _WeaponIsSecondaryAviable( item ) )
                        break;
                    continue;
                case USE_THIRD:
                    if( _WeaponIsThirdAviable( item ) )
                        break;
                    continue;
                case USE_RELOAD:
                    if( item.Weapon_MaxAmmoCount > 0 )
                        break;
                    continue;
                case USE_USE:
                    if( item.IsCanUseOnSmth )
                        break;
                    continue;
                default:
                    use = USE_PRIMARY;
                    break;
                }
                break;
            }
            SetWeaponMode( item, _WeaponModeMake( use, aim ) );
        }
    }
}

#endif

void SetWeaponMode( const Item cItem, uint8 mode )
{
    Item  item = GetItem( cItem.Id );
    uint8 use = _WeaponModeUse( mode );
    uint8 aim = _WeaponModeAim( mode );
    if( item.Type != ItemType::Weapon )
    {
        if( use == USE_USE && !item.IsCanUse && !item.IsCanUseOnSmth )
            use = USE_NONE;
        else if( item.IsCanUse  || item.IsCanUseOnSmth )
            use = USE_USE;
        else
            use = USE_NONE;
    }
    else
    {
        switch( use )
        {
        case USE_PRIMARY:
            if( _WeaponIsPrimaryAviable( item ) )
                break;
            use = 0xF;
            aim = 0;
            break;
        case USE_SECONDARY:
            if( _WeaponIsSecondaryAviable( item ) )
                break;
            use = USE_PRIMARY;
            aim = 0;
            break;
        case USE_THIRD:
            if( _WeaponIsThirdAviable( item ) )
                break;
            use = USE_PRIMARY;
            aim = 0;
            break;
        case USE_RELOAD:
            aim = 0;
            if( item.Weapon_MaxAmmoCount > 0 )
                break;
            use = USE_PRIMARY;
            break;
        case USE_USE:
            aim = 0;
            if( item.IsCanUseOnSmth )
                break;
            use = USE_PRIMARY;
            break;
        default:
            use = USE_PRIMARY;
            aim = 0;
            break;
        }

        if( use < MAX_USES && aim > 0 && !_WeaponAim( item, use ) )
            aim = 0;
        // mode = ( aim << 4 ) | ( use & 0xF );
        mode = _WeaponModeMake( use, aim );
    }

    item.Mode = mode;
}

void CritterSetHandsItemProtoId( const Critter cr, CritterProperty prop, uint& newValue )
{
    if( !VerifyUnarmedItem( cr, newValue ) )
        newValue = cr.HandsItemProtoId;
}

void CritterSetHandsItemMode( const Critter cr, CritterProperty prop, uint8& newValue )
{
    // Check uses and aiming



}

#define CONVERT_GRAMM              # (x)               ( ( x ) * 453 )
#define TB_BATTLE_TIMEOUT_CHECK    # (to)    ( ( to ) > __FullSecond && ( to ) - __FullSecond > 10000000 )

int CritterGetStrength( const Critter cr )
{
    // Base value
    int val = cr.StrengthBase;

    // Adrenaline rush perk
    if( cr.PerkAdrenalineRush != 0 && IS_TIMEOUT( cr.TimeoutBattle ) &&
        cr.CurrentHp <= ( cr.MaxLifeBase + cr.StrengthBase + cr.EnduranceBase * 2 ) / 2 )
        val += 1;

    // Armor perk
    int armorPerk = cr.CurrentArmorPerk;
    if( armorPerk == ArmorPerks::Powered )
        val += 3;
    else if( armorPerk == ArmorPerks::AdvancedI || armorPerk == ArmorPerks::AdvancedII )
        val += 4;

    // Drug effect
    val += Drugs::GetDrugEffect( cr, CritterProperty::StrengthBase );

    return CLAMP( val, 1, 10 );
}

int CritterGetPerception( const Critter cr )
{
    // Base value
    int val = ( cr.IsDamagedEye ? 1 : cr.PerceptionBase );

    // Night person perk
    if( cr.IsTraitNightPerson )
        val += GetNightPersonBonus();

    // Drug effect
    val += Drugs::GetDrugEffect( cr, CritterProperty::PerceptionBase );

    return CLAMP( val, 1, 10 );
}

int CritterGetEndurance( const Critter cr )
{
    // Base value
    int val = cr.EnduranceBase;

    // Drug effect
    val += Drugs::GetDrugEffect( cr, CritterProperty::EnduranceBase );

    return CLAMP( val, 1, 10 );
}

int CritterGetCharisma( const Critter cr )
{
    // Base value
    int val = cr.CharismaBase;

    // Armor perk
    if( cr.CurrentArmorPerk == ArmorPerks::Charisma )
        val += 1;

    // Drug effect
    val += Drugs::GetDrugEffect( cr, CritterProperty::CharismaBase );

    return CLAMP( val, 1, 10 );
}

int CritterGetIntellegence( const Critter cr )
{
    // Base value
    int val = cr.IntellectBase;

    // Night person perk
    if( cr.IsTraitNightPerson )
        val += GetNightPersonBonus();

    // Drug effect
    val += Drugs::GetDrugEffect( cr, CritterProperty::IntellectBase );

    return CLAMP( val, 1, 10 );
}

int CritterGetAgility( const Critter cr )
{
    // Base value
    int val = cr.AgilityBase;

    // Drug effect
    val += Drugs::GetDrugEffect( cr, CritterProperty::AgilityBase );

    return CLAMP( val, 1, 10 );
}

int CritterGetLuck( const Critter cr )
{
    // Base value
    int val = cr.LuckBase;

    // Drug effect
    val += Drugs::GetDrugEffect( cr, CritterProperty::LuckBase );

    return CLAMP( val, 1, 10 );
}

int CritterGetMaxLife( const Critter cr )
{
    int val = cr.MaxLifeBase + cr.StrengthBase + cr.EnduranceBase * 2;
    val += Drugs::GetDrugEffect( cr, CritterProperty::MaxLifeBase );
    return CLAMP( val, 1, 9999 );
}

int CritterGetActionPoints( const Critter cr )
{
    int val = cr.ActionPointsBase + CritterGetAgility( cr ) / 2;
    val += Drugs::GetDrugEffect( cr, CritterProperty::ActionPointsBase );
    return CLAMP( val, 1, 9999 );
}

bool CritterGetIsOverweight( const Critter cr )
{
    return int(cr.ItemsWeight) > CritterGetCarryWeight( cr );
}

int CritterGetCarryWeight( const Critter cr )
{
    int val = MAX( cr.CarryWeightBase, 0 );
    val += Drugs::GetDrugEffect( cr, CritterProperty::CarryWeightBase );
    val += CONVERT_GRAMM( 25 + CritterGetStrength( cr ) * ( 25 - ( cr.IsTraitSmallFrame ? 10 : 0 ) ) );
    return CLAMP( val, 0, 2000000000 );
}

int CritterGetSequence( const Critter cr )
{
    int val = cr.SequenceBase + CritterGetPerception( cr ) * 2;
    val += Drugs::GetDrugEffect( cr, CritterProperty::SequenceBase );
    return CLAMP( val, 0, 9999 );
}

int CritterGetMeleeDamage( const Critter cr )
{
    int strength = CritterGetStrength( cr );
    int val = cr.MeleeDamageBase + ( strength > 6 ? strength - 5 : 1 );
    val += Drugs::GetDrugEffect( cr, CritterProperty::MeleeDamageBase );
    return CLAMP( val, 1, 9999 );
}

int CritterGetHealingRate( const Critter cr )
{
    int e = CritterGetEndurance( cr );
    int val = cr.HealingRateBase + MAX( 1, e / 3 );
    val += Drugs::GetDrugEffect( cr, CritterProperty::HealingRateBase );
    return CLAMP( val, 0, 9999 );
}

int CritterGetCriticalChance( const Critter cr )
{
    int val = cr.CriticalChanceBase + CritterGetLuck( cr );
    val += Drugs::GetDrugEffect( cr, CritterProperty::CriticalChanceBase );
    return CLAMP( val, 0, 100 );
}

int CritterGetMaxCritical( const Critter cr )
{
    int val = cr.MaxCriticalBase;
    val += Drugs::GetDrugEffect( cr, CritterProperty::MaxCriticalBase );
    return CLAMP( val, -100, 100 );
}

int GetDeteriorationProc( const Item item ) // Export
{
    if( not item.Deteriorable )
        return 0;
    if( item.IsBroken )
        return 100;
    int value = item.Deterioration * 100 / Tla::MaxDeterioration;
    return CLAMP( value, 0, 100 );
}

int CritterGetArmorClass( const Critter cr )
{
    int        val = cr.ArmorClassBase + CritterGetAgility( cr );
    val += Drugs::GetDrugEffect( cr, CritterProperty::ArmorClassBase );
    const Item armor = Obsolete::GetConstItemBySlot( cr,  SLOT_ARMOR );
    if( valid( armor ) && armor.Type == ItemType::Armor )
        val += armor.Armor_AC * ( 100 - GetDeteriorationProc( armor ) ) / 100;
    return CLAMP( val, 0, 90 );
}

int[] CritterGetDamageResistance( const Critter cr )
{
    const Item armor = Obsolete::GetConstItemBySlot( cr, SLOT_ARMOR );
    uint       dp = 0;
    if( armor.Id != 0 && armor.Type == ItemType::Armor )
        dp = 100 - GetDeteriorationProc( armor );

    int[] result =
    {
        0,
        cr.NormalResistanceBase + armor.Armor_DRNormal * dp / 100,
        cr.LaserResistanceBase + armor.Armor_DRLaser * dp / 100,
        cr.FireResistanceBase + armor.Armor_DRFire * dp / 100,
        cr.PlasmaResistanceBase + armor.Armor_DRPlasma * dp / 100,
        cr.ElectricityResistanceBase + armor.Armor_DRElectr * dp / 100,
        cr.EmpResistanceBase + armor.Armor_DREmp * dp / 100,
        cr.ExplodeResistanceBase + armor.Armor_DRExplode * dp / 100,
        cr.PoisonResistanceBase  + CritterGetEndurance( cr ) * 5,
        cr.RadiationResistanceBase + CritterGetEndurance( cr ) * 2,
    };

    // Armor perk
    int armorPerk = cr.CurrentArmorPerk;
    if( armorPerk == ArmorPerks::Powered )
        result[ DamageTypes::Radiation ] += 30;
    else if( armorPerk == ArmorPerks::Combat )
        result[ DamageTypes::Radiation ] += 20;
    else if( armorPerk == ArmorPerks::AdvancedI )
        result[ DamageTypes::Radiation ] += 60;
    else if( armorPerk == ArmorPerks::AdvancedII )
        result[ DamageTypes::Radiation ] += 75;

    // Drug effects
    for( uint i = 0; i < CritterPropertyResistsBase.length(); i++ )
        result[ i ] += Drugs::GetDrugEffect( cr, CritterPropertyResistsBase[ i ] );

    // Clamp
    for( uint i = 0; i < result.length(); i++ )
        result[ i ] = CLAMP( result[ i ], 0, i != DamageTypes::Emp ? 90 : 999 );
    return result;
}

int CritterGetNormalResistance( const Critter cr )
{
    return CritterGetDamageResistance( cr )[ DamageTypes::Normal ];
}

int CritterGetPoisonResistance( const Critter cr )
{
    return CritterGetDamageResistance( cr )[ DamageTypes::Poison ];
}

int CritterGetRadiationResistance( const Critter cr )
{
    return CritterGetDamageResistance( cr )[ DamageTypes::Radiation ];
}

int[] CritterGetDamageThreshold( const Critter cr )
{
    const Item armor = Obsolete::GetConstItemBySlot( cr, SLOT_ARMOR );
    uint       dp = 0;
    if( armor.Id != 0 && armor.Type == ItemType::Armor )
        dp = 100 - GetDeteriorationProc( armor );

    int[] result =
    {
        0,
        cr.NormalThresholdBase + armor.Armor_DTNormal * dp / 100,
        cr.LaserThresholdBase + armor.Armor_DTLaser * dp / 100,
        cr.FireThresholdBase + armor.Armor_DTFire * dp / 100,
        cr.PlasmaThresholdBase + armor.Armor_DTPlasma * dp / 100,
        cr.ElectricityThresholdBase + armor.Armor_DTElectr * dp / 100,
        cr.EmpThresholdBase + armor.Armor_DTEmp * dp / 100,
        cr.ExplodeThresholdBase + armor.Armor_DTExplode * dp / 100,
        0,
        0,
    };

    // Drug effects
    for( uint i = 0; i < CritterPropertyThresholdsBase.length(); i++ )
        result[ i ] += Drugs::GetDrugEffect( cr, CritterPropertyThresholdsBase[ i ] );

    // Clamp
    for( uint i = 0; i < result.length(); i++ )
        result[ DamageTypes::Emp ] = CLAMP( result[ DamageTypes::Emp ], 0, 999 );
    return result;
}

bool CritterGetIsInjured( const Critter cr )
{
    return cr.IsDamagedEye || cr.IsDamagedRightLeg || cr.IsDamagedLeftLeg || cr.IsDamagedRightArm || cr.IsDamagedLeftArm;
}

bool CritterGetIsAddicted( const Critter cr )
{
    bool[] addictions = cr.Addictions.clone();
    for( uint i = 0; i < addictions.length(); i++ )
        if( addictions[ i ] )
            return true;
    return false;
}

CritterProperty[] CritterGetTagSkills( const Critter cr )
{
    CritterProperty[] result = {};
    if( cr.TagSkill1 != CritterProperty::Invalid )
        result.insertLast( cr.TagSkill1 );
    if( cr.TagSkill2 != CritterProperty::Invalid )
        result.insertLast( cr.TagSkill2 );
    if( cr.TagSkill3 != CritterProperty::Invalid )
        result.insertLast( cr.TagSkill3 );
    return result;
}

uint CritterGetLookDistance( const Critter cr )
{
    int look = __LookNormal + cr.Perception * 3 + cr.BonusLook + cr.Multihex;
    if( look < int(__LookMinimum) )
        look = __LookMinimum;
    return look;
}

bool Item_Weapon_IsHtHAttack( const Item item, uint8 mode )
{
    uint8 use = mode & 0xF;
    if( item.Type != ItemType::Weapon || ( ( item.Weapon_ActiveUses >> use ) & 1 ) == 0 )
        return false;
    CritterProperty skill = _WeaponSkill( item, use );
    return skill == CritterProperty::SkillUnarmed || skill == CritterProperty::SkillMeleeWeapons;
}

bool Item_Weapon_IsGunAttack( const Item item, uint8 mode )
{
    uint8 use = mode & 0xF;
    if( item.Type != ItemType::Weapon || ( ( item.Weapon_ActiveUses >> use ) & 1 ) == 0 )
        return false;
    CritterProperty skill = _WeaponSkill( item, use );
    return skill == CritterProperty::SkillSmallGuns || skill == CritterProperty::SkillBigGuns || skill == CritterProperty::SkillEnergyWeapons;
}

bool Item_Weapon_IsRangedAttack( const Item item, uint8 mode )
{
    uint8 use = mode & 0xF;
    if( item.Type != ItemType::Weapon || ( ( item.Weapon_ActiveUses >> use ) & 1 ) == 0 )
        return false;
    CritterProperty skill = _WeaponSkill( item, use );
    return skill == CritterProperty::SkillSmallGuns || skill == CritterProperty::SkillBigGuns || skill == CritterProperty::SkillEnergyWeapons || skill == CritterProperty::SkillThrowing;
}

// Engine callbacks

uint GetItemUseApCost( const Critter cr, const Item item, uint8 mode )
{
    uint8 use = mode & 0xF;
    uint8 aim = mode >> 4;
    int   apCost = 1;

    if( use == USE_USE )
    {
        apCost = __RtApCostUseItem;
    }
    else if( use == USE_RELOAD )
    {
        apCost = __RtApCostReloadWeapon;

        if( item.Type == ItemType::Weapon && item.Weapon_Perk == ItemPerks::FastReload )
            apCost--;
    }
    else if( use >= USE_PRIMARY && use <= USE_THIRD && item.Type == ItemType::Weapon )
    {
        bool hthAttack = Item_Weapon_IsHtHAttack( item, use );
        bool rangedAttack = Item_Weapon_IsRangedAttack( item, use );

        apCost = _WeaponApCost( item, use );
        if( aim != 0 )
            apCost += GetAimApCost( aim );
        if( hthAttack && cr.PerkBonusHthAttacks != 0 )
            apCost--;
        if( rangedAttack && cr.PerkBonusRateOfFire != 0 )
            apCost--;
        if( cr.IsTraitFastShot && !hthAttack )
            apCost--;
    }

    if( apCost < 1 )
        apCost = 1;
    return apCost;
}

void get_use_ap_cost( const Critter cr, const Item item, uint8 mode, uint cost )
{
    cost = GetItemUseApCost( cr, item, mode );
}

uint GetItemAttackDistantion( const Critter cr, const Item proto, uint8 mode )
{
    if( proto.Type != ItemType::Weapon )
        return 0;

    uint8           use = mode & 0xF;
    CritterProperty skill = _WeaponSkill( proto, use );
    int             dist = _WeaponMaxDist( proto, use );
    int             strength = CritterGetStrength( cr );
    int             heaveHo = cr.PerkHeaveHo;
    if( skill == CritterProperty::SkillThrowing )
        dist = MIN( dist, int(3) * MIN( int(10), strength + 2 * heaveHo ) );
    if( Item_Weapon_IsHtHAttack( proto, mode ) && cr.IsRangeHth )
        dist++;
    dist += cr.Multihex;
    if( dist < 0 )
        dist = 0;
    return dist;
}

uint GetActiveItemAttackDistantion( Critter cr )
{
    const Item item = Obsolete::GetConstItemBySlot( cr, SLOT_HAND1 );
    if( valid( item ) )
    {
        return GetItemAttackDistantion( cr, item, item.Mode );
    }
    return 1;
}

void get_attack_distantion( const Critter cr, const Item item, uint8 mode, uint& dist )
{
    if( !valid( item ) && valid( cr ) )
    {
        item = Obsolete::GetConstItemBySlot( cr, SLOT_HAND1 );
        mode = item.Mode;
    }

    dist = GetItemAttackDistantion( cr, item, mode );
}

// Generic stuff

int GetNightPersonBonus()
{
    if( GameTime::GetHour() < 6 || GameTime::GetHour() > 18 )
        return 1;
    if( GameTime::GetHour() == 6 && GameTime::GetMinute() == 0 )
        return 1;
    if( GameTime::GetHour() == 18 && GameTime::GetMinute() > 0 )
        return 1;
    return -1;
}

uint GetAimApCost( int hitLocation )
{
    switch( hitLocation )
    {
    case HitLocations::LocationTorso:
        return __ApCostAimTorso;
    case HitLocations::LocationEyes:
        return __ApCostAimEyes;
    case HitLocations::LocationHead:
        return __ApCostAimHead;
    case HitLocations::LocationLeftArm:
    case HitLocations::LocationRightArm:
        return __ApCostAimArms;
    case HitLocations::LocationGroin:
        return __ApCostAimGroin;
    case HitLocations::LocationRightLeg:
    case HitLocations::LocationLeftLeg:
        return __ApCostAimLegs;
    case HitLocations::LocationNone:
    case HitLocations::LocationUncalled:
    default:
        break;
    }
    return 0;
}

uint CritterGetItemsWeight( Critter cr )
{
    #ifdef __CLIENT
    if( !cr.IsChosen() )
        return 0;  // TODO
    #endif
    Item[] items = cr.GetItems();
    uint result = 0;
    for( uint i = 0; i < items.length(); i++ )
        result += items[ i ].Weight * items[ i ].Count;
    return result;
}
