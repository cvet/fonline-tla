// FOS Server Client

// Author: cvet

///@ RemoteCall Client SetCurrentLocationEntrances(hstring locPid, hstring[] mapEntrances)
///@ RemoteCall Server ProcessGlobalMapCommand(uint8 command, any param1, any param2)

// GM Rule command
#define GM_CMD_SETMOVE     (1) // +r-a*x,y
#define GM_CMD_STOP        (2) // +r-a
#define GM_CMD_TOLOCAL     (3) // +r-a*num_city,num_map
#define GM_CMD_KICKCRIT    (4) // +r-a*cr_id
#define GM_CMD_FOLLOW_CRIT (5) // +r+a*cr_id
#define GM_CMD_FOLLOW      (6)
#define GM_CMD_GIVE_RULE   (7)
#define GM_CMD_ANSWER      (8)
#define GM_CMD_ENTRANCES   (9)
#define GM_CMD_VIEW_MAP    (10)

#ifdef __CLIENT

void ModuleInit()
{
    Game.OnLoop.Subscribe(OnLoop);
}

void OnLoop()
{
    auto group = GetCurrentGroup();
    if (valid(group) && group.IsMoving) {
        Critter chosen = Game.GetChosen();
        if (chosen == null || CurMap != null) {
            group.IsMoving = false;
            return;
        }

        group.StepCount++;
        if (group.StepCount % 167 == 1) {
            group.Points.insertLast(array<int> = {int(group.CurX), int(group.CurY), int(COLOR_RED)});
        }
    }
    else if (group.StepCount > 0) {
        group.Stop();
    }
}

class GlobalMapGroupClientInfo
{
    uint CarId;
    uint CurX, CurY;
    uint ToX, ToY;
    bool IsMoving;
    bool IsEncounter;
    uint StepCount;
    int[] Points;

    GlobalMapGroupClientInfo()
    {
        Points = array<int>();
        StepCount = 0;
        Clear();
    }

    void Stop()
    {
        Points.clear();
        StepCount = 0;
    }

    void Clear()
    {
        CurX = CurY = ToX = ToY = 0;
        CarId = 0;
        IsMoving = false;
        IsEncounter = false;
    }

    void Load(Serializator::Serializator load)
    {
        Clear();
        load.Get(CarId);
        load.Get(CurX);
        load.Get(CurY);
        load.Get(ToX);
        load.Get(ToY);
        load.Get(IsMoving);
        load.Get(IsEncounter);
    }
}

GlobalMapGroupClientInfo CurrentGroup = GlobalMapGroupClientInfo();

GlobalMapGroupClientInfo GetCurrentGroup()
{
    return CurrentGroup;
}

void RuleGlobalCommand(uint8 command, any param1, any param2)
{
    CurPlayer.ServerCall.ProcessGlobalMapCommand(command, param1, param2);
}

void SetCurrentLocationEntrances(hstring locPid, hstring[] mapEntrances)
{
}

void LoadGlobalMapGroupData(Serializator::Serializator load)
{
    CurrentGroup.Load(load);
}

#endif

#ifdef __SERVER

///@ Setting Common uint GlobalMapGroupMaxCount = 6                     // Макс размер группы
#define TIME_CAN_FOLLOW_GM (REAL_SECOND(5)) // Can less than Map timeout

///@ Property Game PrivateServer int LastGlobalMapTrip // Индекс последней группы на глобальной карте

// Global map
#define GM_MAXX                (Settings.GlobalMapWidth * Settings.GlobalMapZoneLength)
#define GM_MAXY                (Settings.GlobalMapHeight * Settings.GlobalMapZoneLength)
#define GM_ZONE_LEN            (Settings.GlobalMapZoneLength) // Can be multiple to GM_MAXX and GM_MAXY
#define GM__MAXZONEX           (100)
#define GM__MAXZONEY           (100)
#define GM_ZONES_FOG_SIZE      (((GM__MAXZONEX / 4) + ((GM__MAXZONEX % 4) ? 1 : 0)) * GM__MAXZONEY)
#define GM_FOG_FULL            (0)
#define GM_FOG_HALF            (1)
#define GM_FOG_HALF_EX         (2)
#define GM_FOG_NONE            (3)
#define GM_MAX_GROUP_COUNT     (Settings.GlobalMapGroupMaxCount)
#define GM_ANSWER_WAIT_TIME    (20000)
#define GM_LIGHT_TIME          (5000)
#define GM_ZONE(x)             ((x) / GM_ZONE_LEN)
#define GM_ENTRANCES_SEND_TIME (6000)
#define GM_TRACE_TIME          (1000)

// Follow
#define FOLLOW_DIST  (10)
#define FOLLOW_FORCE (1)
#define FOLLOW_PREP  (2)

// Global process types
#define GLOBAL_PROCESS_MOVE       (0)
#define GLOBAL_PROCESS_ENTER      (1)
#define GLOBAL_PROCESS_START_FAST (2)
#define GLOBAL_PROCESS_START      (3)
#define GLOBAL_PROCESS_SET_MOVE   (4)
#define GLOBAL_PROCESS_STOPPED    (5)
#define GLOBAL_PROCESS_NPC_IDLE   (6)
#define GLOBAL_PROCESS_KICK       (7)

// GM Info
#define GM_INFO_LOCATIONS   (0x01)
#define GM_INFO_CRITTERS    (0x02)
#define GM_INFO_GROUP_PARAM (0x04)
#define GM_INFO_ZONES_FOG   (0x08)
#define GM_INFO_ALL         (0x0F)
#define GM_INFO_FOG         (0x10)
#define GM_INFO_LOCATION    (0x20)

void ModuleInit()
{
    Game.OnGlobalMapCritterIn.Subscribe(OnGlobalMapCritterIn);
    Game.OnGlobalMapCritterOut.Subscribe(OnGlobalMapCritterOut);
    Game.OnCritterIdle.Subscribe(OnCritterIdle);
    Game.LoadImage(Tla::ImageRelief, "relief_tla.png");
}

void OnCritterIdle(Critter cr)
{
    // Global map
    if (!valid(cr.GetMap())) {
        auto group = GetGlobalMapGroupByRuler(cr);
        if (valid(group)) {
            GM_GroupMove(group);
        }
    }
}

void OnGlobalMapCritterIn(Critter cr)
{
    // Game.Log("OnGlobalMapCritterIn");
    if (valid(cr)) {
        GM_AddCritToGroup(cr, ZERO_IDENT);
    }
}

void OnGlobalMapCritterOut(Critter cr)
{
    // Game.Log("OnGlobalMapCritterOut");
    if (valid(cr)) {
        GM_LeaveGroup(cr);
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// int processType    - see in Global map events in _defines.fos;
// Critter cr        - who called this function, in most times is leader of group;
// Item car          - group car, can be null;
// float curX, curY - current position;
// float toX, toY   - destination position;
// float speed       - speed of group, must set in Tla::GlobalProcessSetMove,
//                      also you can type zero to stop group;
// uint encounterDescriptor - if encounterDescriptor != 0 than global_invite calls;
// bool waitForAnswer       - if waitForAnswer == false than global_invite calls after this function,
//                            else call after leader confirm invite;
void global_process(int processType, Critter cr, Item car, float& curX, float& curY, float& toX, float& toY, float& speed, uint& encounterDescriptor,
                    bool& waitForAnswer)
{
    int movementType = (valid(car) ? car.Car_MovementType : Tla::GmWalkGround);
    int curXi = int(curX);
    int curYi = int(curY);

    if (processType == Tla::GlobalProcessMove) {
        // Save current distantion to compare in the end
        float lastDist = DISTANCE(curX, curY, toX, toY);

        // Calcuate speed
        float speedPix = speed * float(Settings.GlobalMapMoveTime) / 1000.0f;
        float speedAngle = math::atan2(toY - curY, toX - curX);
        float speedX = math::cos(speedAngle) * speedPix;
        float speedY = math::sin(speedAngle) * speedPix;

        float speedMod = 1.0f;
        if (movementType == Tla::GmWalkGround) {
            // Speed modifiers
            //  F   E   D   C   B   A   9    8   7    6   5    4   3    2   1    0
            // 1.5 1.4 1.3 1.2 1.1 1.0 0.95 0.9 0.85 0.8 0.75 0.7 0.65 0.6 0.55 0.0
            switch (Worldmap::GetGlobalMapRelief(curXi, curYi)) {
            case 0x0:
                speedMod = 1.00f;
                break;
            case 0x1:
                speedMod = 0.55f;
                break;
            case 0x2:
                speedMod = 0.60f;
                break;
            case 0x3:
                speedMod = 0.65f;
                break;
            case 0x4:
                speedMod = 0.70f;
                break;
            case 0x5:
                speedMod = 0.75f;
                break;
            case 0x6:
                speedMod = 0.80f;
                break;
            case 0x7:
                speedMod = 0.85f;
                break;
            case 0x8:
                speedMod = 0.90f;
                break;
            case 0x9:
                speedMod = 0.95f;
                break;
            case 0xA:
                speedMod = 1.00f;
                break;
            case 0xB:
                speedMod = 1.10f;
                break;
            case 0xC:
                speedMod = 1.20f;
                break;
            case 0xD:
                speedMod = 1.30f;
                break;
            case 0xE:
                speedMod = 1.40f;
                break;
            case 0xF:
                speedMod = 1.50f;
                break;
            default:
                break;
            }
        }

        if (valid(car) && speedMod != 1.0f) {
            float pass = float(car.Car_Passability);
            if (pass > 100.0f && speedMod < 1.0f) {
                speedMod += (1.0f - speedMod) * (pass - 100.0f) / 100.0f;
            }
            else if (pass > 100.0f && speedMod > 1.0f) {
                speedMod -= (speedMod - 1.0f) * (pass - 100.0f) / 100.0f;
            }
            else if (pass < 100.0f && speedMod < 1.0f) {
                speedMod -= (1.0f - speedMod) * (100.0f - pass) / 100.0f;
            }
            else if (pass < 100.0f && speedMod > 1.0f) {
                speedMod += (speedMod - 1.0f) * (100.0f - pass) / 100.0f;
            }
        }

        // Apply step
        curX += speedX * speedMod;
        curY += speedY * speedMod;

        int oldXi = curXi;
        int oldYi = curYi;
        curXi = int(curX); // Round
        curYi = int(curY); // Round

        // Check new position
        if (oldXi != curXi || oldYi != curYi) {
            // Check borders
            int gmWidth = Settings.GlobalMapWidth * Settings.GlobalMapZoneLength;
            int gmHeight = Settings.GlobalMapHeight * Settings.GlobalMapZoneLength;
            if (curXi < 0 || curYi < 0 || curXi >= gmWidth || curYi >= gmHeight) {
                if (curXi < 0) {
                    curXi = 0;
                }
                if (curXi >= gmWidth) {
                    curXi = gmWidth - 1;
                }
                if (curYi < 0) {
                    curYi = 0;
                }
                if (curYi >= gmHeight) {
                    curYi = gmHeight - 1;
                }

                // Stop group
                curX = float(curXi);
                curY = float(curYi);
                speed = 0.0f;
                return;
            }

            // Move from old to new and find last correct position
            int relief = Worldmap::GetGlobalMapRelief(oldXi, oldYi);
            int steps = MAX(ABS(curXi - oldXi), ABS(curYi - oldYi));
            int newXi = oldXi;
            int newYi = oldYi;
            if (steps > 0) {
                float xx = float(oldXi);
                float yy = float(oldYi);
                float oxx = float(curXi - oldXi) / float(steps);
                float oyy = float(curYi - oldYi) / float(steps);

                for (int i = 0; i < steps; i++) {
                    xx += oxx;
                    yy += oyy;
                    int xxi = int(xx >= 0.0f ? xx + 0.5f : xx - 0.5f);
                    int yyi = int(yy >= 0.0f ? yy + 0.5f : yy - 0.5f);

                    uint relief_ = Worldmap::GetGlobalMapRelief(xxi, yyi);
                    if (movementType == Tla::GmWalkGround && relief != 0 && relief_ == 0) {
                        break;
                    }
                    if (movementType == Tla::GmWalkWater && relief_ != 0) {
                        break;
                    }

                    newXi = xxi;
                    newYi = yyi;
                }
            }

            if (newXi != curXi || newYi != curYi) {
                // Stop group
                curX = float(newXi);
                curY = float(newYi);
                speed = 0.0f;
                return;
            }

            // Zone
            int oldZoneX = oldXi / Settings.GlobalMapZoneLength;
            int oldZoneY = oldYi / Settings.GlobalMapZoneLength;
            int curZoneX = curXi / Settings.GlobalMapZoneLength;
            int curZoneY = curYi / Settings.GlobalMapZoneLength;

            // Change zone
            if (oldZoneX != curZoneX || oldZoneY != curZoneY) {
                Critter[] group = GlobalmapGroupExtended::GetGlobalGroup(cr);
                ScanZone(group, curZoneX, curZoneY);
            }

            // Check for complete travelling
            float curDist = DISTANCE(curX, curY, toX, toY);
            if (curDist <= 0.01f || curDist > lastDist) {
                curX = toX;
                curY = toY;
                speed = 0.0f;
                return;
            }
        }

        // Car processing
        if (valid(car)) {
            int fuel = car.Charge;
            int deterioration = car.Deterioration;

            if (fuel <= 0 || deterioration >= int(car.Car_MaxDeterioration)) {
                uint str = (fuel <= 0 ? MsgStr::StrCarFuelEmpty : MsgStr::StrCarBroken);
                cr.SayMsg(SAY_NETMSG, TEXTMSG_GAME, str);
                speed = 0.0f;
                return;
            }

            // Car values created for the call every 500 ms
            fuel -= car.Car_FuelConsumption * Settings.GlobalMapMoveTime / 500;
            deterioration += car.Car_DeteriorationRate * Settings.GlobalMapMoveTime / 500;
            if (fuel < 0) {
                fuel = 0;
            }
            if (deterioration > int(car.Car_MaxDeterioration)) {
                deterioration = int(car.Car_MaxDeterioration);
            }

            if (fuel != int(car.Charge) || deterioration != int(car.Deterioration)) {
                car.Charge = fuel;
                car.Deterioration = deterioration;
            }
        }

        cr.GlobalMapMoveCounter += 1;
        if (cr.GlobalMapMoveCounter % (Settings.EncounterTime / Settings.GlobalMapMoveTime) == 0) {
            Critter[] group = GlobalmapGroupExtended::GetGlobalGroup(cr);

            // Validate charisma
            Critter leader = group[0];
            if (int(group.length()) > leader.Charisma + leader.PerkMagneticPersonality) {
                leader.SayMsg(SAY_NETMSG, TEXTMSG_GAME, MsgStr::StrCritBadCharisma);
                speed = 0.0f; // Stop
                return;
            }

            // Try find encounter
            if (Game.GetVisibleLocations(curXi, curYi, 0, cr).length() == 0) {
                Worldmap::FindEncounter(group, car, curXi, curYi, encounterDescriptor, waitForAnswer, false);
            }
        }
    }
    else if (processType == Tla::GlobalProcessEnter) {
        // Enter to empty encounter
        if (movementType == Tla::GmWalkWater && Worldmap::GetGlobalMapRelief(curXi, curYi) == 0) {
            // Find land
            bool landFounded = false;
            const int maxx = Settings.GlobalMapWidth * Settings.GlobalMapZoneLength;
            const int maxy = Settings.GlobalMapHeight * Settings.GlobalMapZoneLength;
            for (int ox = -1; ox <= 1; ox++) {
                for (int oy = -1; oy <= 1; oy++) {
                    int xx = curXi + ox;
                    int yy = curYi + oy;
                    if (xx >= 0 && xx < maxx && yy >= 0 && yy < maxy && Worldmap::GetGlobalMapRelief(xx, yy) != 0) {
                        Worldmap::FindEncounter(GlobalmapGroupExtended::GetGlobalGroup(cr), car, xx, yy, encounterDescriptor, waitForAnswer, true);
                        ox = oy = 2; // Exit from loop
                        landFounded = true;
                    }
                }
            }

            if (!landFounded) {
                Worldmap::FindEncounter(GlobalmapGroupExtended::GetGlobalGroup(cr), car, curXi, curYi, encounterDescriptor, waitForAnswer, true);
            }
        }
        else {
            Worldmap::FindEncounter(GlobalmapGroupExtended::GetGlobalGroup(cr), car, curXi, curYi, encounterDescriptor, waitForAnswer, true);
        }
    }
    else if (processType == Tla::GlobalProcessSetMove) {
        Critter[] group = GlobalmapGroupExtended::GetGlobalGroup(cr);

        // Validate charisma
        Critter leader = group[0];
        if (int(group.length()) > leader.Charisma + leader.PerkMagneticPersonality) {
            leader.SayMsg(SAY_NETMSG, TEXTMSG_GAME, MsgStr::StrCritBadCharisma);
            if (valid(car)) {
                CheckForLocationWithoutParking(cr, car, curX, curY);
            }
            return;
        }

        // Calculate speed
        speed = GLOBAL_MAP_BASE_SPEED;
        if (cr.IsOwnedByPlayer() && cr.GetOwner().GetAccess() >= ACCESS_TESTER) {
            speed *= 20.0f; // All, exclude clients have highly speed
        }

        if (valid(car)) {
            // Validate car
            uint strNum = 0;
            if (group.length() > car.Car_CrittersCapacity) {
                strNum = MsgStr::StrCarCritOverload;
            }
            else if (car.Charge == 0) {
                strNum = MsgStr::StrCarFuelEmpty;
            }
            else if (car.Deterioration >= car.Car_MaxDeterioration) {
                strNum = MsgStr::StrCarBroken;
            }
            if (strNum != 0) {
                leader.SayMsg(SAY_NETMSG, TEXTMSG_GAME, strNum);
                speed = 0.0f;
                CheckForLocationWithoutParking(cr, car, curX, curY);
                return;
            }

            speed = car.Car_Speed * GLOBAL_MAP_BASE_SPEED / 20.0f;

            // Find near water for boats
            // In radius of one zone (left, top, right, bottom)
            if (car.Car_MovementType == Tla::GmWalkWater) {
                if (Worldmap::GetGlobalMapRelief(curXi, curYi) != 0) {
                    const int maxx = Settings.GlobalMapWidth * Settings.GlobalMapZoneLength;
                    const int maxy = Settings.GlobalMapHeight * Settings.GlobalMapZoneLength;
                    const int[] ox = {-1, 0, 1, 0};
                    const int[] oy = {0, -1, 0, 1};
                    for (int i = 1, ii = Settings.GlobalMapZoneLength; i <= ii; i++) {
                        for (int j = 0; j < 4; j++) {
                            int xx = curXi + ox[j] * i;
                            int yy = curYi + oy[j] * i;
                            if (xx >= 0 && xx < maxx && yy >= 0 && yy < maxy && Worldmap::GetGlobalMapRelief(xx, yy) == 0) {
                                curX = float(xx);
                                curY = float(yy);
                                // Exit from loop
                                j = 4;
                                i = ii;
                            }
                        }
                    }
                }
            }
        }
        else {
            // Pathfinder perk bonus
            int speedDiv = 100 - cr.PerkPathfinder * 25;
            if (speedDiv <= 0) {
                speedDiv = 1;
            }
            speed = speed * 100.0f / float(speedDiv);
        }
    }
    else if (processType == Tla::GlobalProcessNpcIdle) {
        // Critter cr - is npc who call idle
        // Process npc group on global map
        if (curX == toX && curY == toY) // Stopped
        {
            // If you want enter to location under group than type
            // encounterDescriptor = uint(-1);
            // waitForAnswer = false;
        }
    }
    else if (processType == Tla::GlobalProcessKick) {
        if (Worldmap::GetGlobalMapRelief(curXi, curYi) == 0) {
            // Say to leader
            Critter[] group = GlobalmapGroupExtended::GetGlobalGroup(cr);
            group[0].SayMsg(SAY_NETMSG, TEXTMSG_GAME, MsgStr::StrCantKickOnWater);
            return;
        }

        GlobalmapGroupExtended::LeaveGlobalGroup(cr);
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on invite to encaunter.
// If mapId != 0 than group enter to it.
void global_invite(Critter leader, Item car, uint encounterDescriptor, int combatMode, ident& mapId, uint16& hexX, uint16& hexY, uint8& dir)
{
    // Enter to map under group
    if (encounterDescriptor == uint(-1)) {
        Location[] locations = Game.GetLocations(leader.WorldX, leader.WorldY, 0);
        if (locations.length() != 0) {
            Location loc = locations[0];
            Map map = loc.GetMapByIndex(0);
            if (valid(map) && Entrance::MapGetEntryCoords(map, 0, 0, hexX, hexY)) {
                mapId = map.Id;
                dir = 0xFF;
            }
        }
        return;
    }

    // Find encounter
    Worldmap::InviteToEncounter(GlobalmapGroupExtended::GetGlobalGroup(leader), car, encounterDescriptor, combatMode, mapId, hexX, hexY, dir);
}

void ScanZone(Critter[] group, int zx, int zy)
{
    Location[] locs1, locs2;
    bool loc2Founded = false;

    locs1 = Game.GetZoneLocations(zx, zy, 1);

    for (uint i = 0; i < group.length(); i++) {
        Critter cr = group[i];
        if (!cr.IsOwnedByPlayer()) {
            continue;
        }

        int lookLen = cr.PerkScout != 0 ? 2 : 1;

        if (lookLen == 2 && !loc2Founded) {
            locs2 = Game.GetZoneLocations(zx, zy, 2);
            loc2Founded = true;
        }

        // Open fog
        int mapw = Settings.GlobalMapWidth;
        int maph = Settings.GlobalMapHeight;
        for (int x = -lookLen; x <= lookLen; x++) {
            for (int y = -lookLen; y <= lookLen; y++) {
                int zx_ = zx + x;
                int zy_ = zy + y;
                if (zx_ >= 0 && zx_ < mapw && zy_ >= 0 && zy_ < maph) {
                    int fog = (zx == zx_ && zy == zy_ ? FOG_NONE : FOG_HALF);
                    if (cr.GetFog(zx_, zy_) < fog) {
                        cr.SetFog(zx_, zy_, fog);
                    }
                }
            }
        }

        // Find new locations
        Location[] locs = lookLen == 1 ? locs1 : locs2;
        for (uint j = 0; j < locs.length(); j++) {
            Location loc = locs[j];
            if (!Location::IsKnownLoc(cr, loc.Id)) {
                Location::SetKnownLoc(cr, loc.Id);
            }
        }
    }
}

void CheckForLocationWithoutParking(Critter cr, Item car, float& curX, float& curY)
{
    Location[] locations = {};
    locations = Game.GetVisibleLocations(int(curX), int(curY), 0, cr);
    if (locations.length() != 0) {
        Location loc = locations[0];
        Map map = loc.GetMapByIndex(0);

        bool placeFounded = false;
        Entrance::Entry[] entries = Entrance::ParseEntries(map, car.Car_Entrance);
        for (uint i = 0; i < entries.length(); i++) {
            if (map.CheckPlaceForItem(entries[i].HexX, entries[i].HexY, car.ProtoId)) {
                placeFounded = true;
                break;
            }
        }

        if (!placeFounded) {
            curX = loc.WorldX + int(loc.Radius) * (Game.Random(0, 1) == 0 ? int(1) : int(-1));
            curY = loc.WorldY + int(loc.Radius) * (Game.Random(0, 1) == 0 ? int(1) : int(-1));
        }
    }
}

int GetGlobalMapTripId()
{
    Game.LastGlobalMapTrip = Game.LastGlobalMapTrip + 1;
    return Game.LastGlobalMapTrip;
}

class GlobalMapGroup
{
    Critter[] CritMove = {};
    Critter Rule;

    ident CarId;
    float CurX, CurY;
    float ToX, ToY;
    float Speed;
    bool IsSetMove;
    uint TimeCanFollow;
    uint ProcessLastTick;
    uint EncounterDescriptor;
    uint EncounterTick;
    bool EncounterForce;

    void Stop()
    {
        Speed = 0.0f;
        ToX = CurX;
        ToY = CurY;
    }

    // Critter can follow leader on GM trip start
    bool CheckForFollow(Critter cr)
    {
        if (IsSetMove) { // ?? уже началось движение
            return false;
        }
        if (Game.GetFullSecond() >= TimeCanFollow) { // прошло время, пока криттер мог присоединиться в группу
            return false;
        }
        if (valid(Game.GetCritter(cr.Id))) { // криттер уже в группе
            return false;
        }
        if (CritMove.length() >= Settings.GlobalMapGroupMaxCount) {
            return false;
        }
        return true;
    }

    GlobalMapGroup()
    {
        Clear();
    }

    GlobalMapGroup(Critter rule)
    {
        Rule = rule;
        Clear();
        CritMove.insertLast(rule);
    }

    Item GetCar()
    {
        if (CarId != ZERO_IDENT) {
            Item car = Game.GetItem(CarId);
            if (valid(car)) {
                return car;
            }
            else {
                CarId = ZERO_IDENT;
            }
        }
        return null;
    }

    void AddCrit(Critter cr)
    {
        for (uint i = 0, l = CritMove.length(); i < l; i++) {
            if (valid(CritMove[i]) && CritMove[i].Id == cr.Id) {
                return;
            }
        }
        CritMove.insertLast(cr);
    }

    bool IsValid()
    {
        return CritMove.length() > 0;
    }

    Critter GetCritter(ident crid)
    {
        for (uint i = 0; i < CritMove.length(); i++) {
            if (valid(CritMove[i]) && CritMove[i].Id == crid) {
                return CritMove[i];
            }
        }
        return null;
    }

    bool IsMoving()
    {
        return Speed > 0.0f && (CurX != ToX || CurY != ToY);
    }

    bool IsEncounter()
    {
        return EncounterDescriptor > 0;
    }

    uint GetSize()
    {
        return CritMove.length();
    }

    void EraseCrit(Critter cr)
    {
        for (uint i = 0, l = CritMove.length(); i < l; i++) {
            if (valid(CritMove[i]) && CritMove[i].Id == cr.Id) {
                CritMove.removeAt(i);
                return;
            }
        }
    }

    void Clear()
    {
        CritMove.clear();
        CurX = CurY = ToX = ToY = 0.0f;
        CarId = ZERO_IDENT;
        IsSetMove = false;
        TimeCanFollow = 0;
        ProcessLastTick = Game.GetTick();
        EncounterDescriptor = 0;
        EncounterTick = 0;
        EncounterForce = false;
    }

    void SendGlobalData(int type)
    {
        for (uint i = 0, l = CritMove.length(); i < l; i++) {
            Critter cr = CritMove[i];
            if (valid(cr)) {
                GlobalMapLocations::SetGlobalMapData(type, cr);
            }
        }
    }

    void Save(Serializator::Serializator save)
    {
        save.Set(CarId);
        save.Set(int(CurX));
        save.Set(int(CurY));
        save.Set(int(ToX));
        save.Set(int(ToY));
        save.Set(IsMoving());
        save.Set(IsEncounter());
    }
};

dict<ident, GlobalMapGroup> AllGlobalGroups = {};

GlobalMapGroup GetGlobalMapGroupByRuler(Critter cr)
{
    // AllGlobalGroups.getIfNotExist( cr.Id, GlobalMapGroup( cr ) );

    return (AllGlobalGroups[cr.Id]);
}

GlobalMapGroup GetOrCreateGlobalMapGroupByRuler(Critter cr)
{
    AllGlobalGroups.setIfNotExist(cr.Id, GlobalMapGroup(cr));

    return (AllGlobalGroups[cr.Id]);
}

GlobalMapGroup GetGlobalMapGroup(Critter cr)
{
    // Для лидера группы
    auto group = AllGlobalGroups[cr.Id];
    if (valid(group)) {
        return group;
    }
    if (cr.GlobalMapLeaderId != ZERO_IDENT) {
        return AllGlobalGroups[cr.GlobalMapLeaderId];
    }
    return null;
}

// Добавить криттера в группу на глобале к лидеру с id = rule_id
void GM_AddCritToGroup(Critter cr, ident rule_id)
{
    if (!valid(cr)) {
        ThrowException("Critter is null");
        return;
    }

    if (rule_id == ZERO_IDENT) {
        GM_GroupStartMove(cr);
        return;
    }

    Critter rule = Game.GetCritter(rule_id);
    auto group = GetGlobalMapGroupByRuler(rule);
    if (!valid(rule) || valid(rule.GetMap()) || !valid(group) || rule.Id != group.Rule.Id) {
        if (cr.IsNpc()) {
            Game.Log(" - Invalid rule on global map. Start move alone.\n");
        }
        GM_GroupStartMove(cr);
        return;
    }

    cr.WorldX = int(group.CurX);
    cr.WorldY = int(group.CurY);

    // for( auto it = group->CritMove.begin(), end = group->CritMove.end(); it != end; ++it )
    //    ( *it )->Send_AddCritter( cr );
    group.AddCrit(cr);

    // cr.GlobalMapLeaderId = rule.Id; //TODO: Свойство только для чтения. Устанавливается в момент выхода игрока на глобальную карту (TrnsitTopGroup(leader)
    // cr.GlobalMapTripId = rule.GlobalMapTripId;//и это тоже

    // cr->GroupMove = group;
    // cr->Data.GlobalGroupUid = rule->Data.GlobalGroupUid;
}

// Начало движения группы на глобальной карте для лидера группы. Он может быть одним криттером в составе группы.
void GM_GroupStartMove(Critter cr)
{
    if (valid(cr.GetMap())) {
        cr.TransitToGlobal();
        return;
    }

    // cr.HexX = 0; //TODO: проверить readonly
    // cr.HexY = 0;
    auto group = GetOrCreateGlobalMapGroupByRuler(cr);

    group.Clear();
    group.CurX = cr.WorldX;
    group.CurY = cr.WorldY;
    group.ToX = group.CurX;
    group.ToY = group.CurY;
    group.Speed = 0.0f;
    // cr.GlobalMapTripId = GetGlobalMapTripId(); // TODO: check readonly

    Item[] items = cr.GetItems(ItemProperty::Type, ItemType::Car);
    if (items.length() > 0) {
        group.CarId = items[0].Id;
    }

    group.TimeCanFollow = Game.GetFullSecond() + TIME_CAN_FOLLOW_GM;
    // SETFLAG( cr->Flags, FCRIT_RULEGROUP );

    group.AddCrit(cr);
    GlobalMapLocations::SetGlobalMapData(GM_INFO_ALL, cr);

    GM_GlobalProcess(cr, group, GLOBAL_PROCESS_START_FAST);
}

void GM_GlobalProcess(Critter cr, GlobalMapGroup group, int type) // 13 hits
{
    if (!valid(group)) {
        return;
    }

    // Catchers
    uint encounter_descriptor = 0;
    bool wait_for_answer = false;
    Critter rule = group.Rule;
    float cur_wx = group.CurX;
    float cur_wy = group.CurY;
    float to_wx = group.ToX;
    float to_wy = group.ToY;
    float speed = group.Speed;
    float base_speed = group.Speed;
    bool callGlobalProcess = true;

    if (!cr.OnGlobalMapProcess.Fire(type, group.GetCar(), cur_wx, cur_wy, to_wx, to_wy, speed, encounter_descriptor, wait_for_answer)) {
        callGlobalProcess = false;
    }
    else {
        encounter_descriptor = 0;
        wait_for_answer = false;
        cur_wx = group.CurX;
        cur_wy = group.CurY;
        to_wx = group.ToX;
        to_wy = group.ToY;
        speed = group.Speed;
    }

    if (!group.IsValid()) {
        return;
    }

    if (callGlobalProcess) {
        GlobalmapGroup::global_process(type, cr, group.GetCar(), cur_wx, cur_wy, to_wx, to_wy, speed, encounter_descriptor, wait_for_answer);
    }

    if (!group.IsValid()) {
        return;
    }

    // Check ranges
    float max_wx = float(GM_MAXX);
    float max_wy = float(GM_MAXY);
    if (cur_wx < 0.0f) {
        cur_wx = 0.0f;
    }
    if (cur_wy < 0.0f) {
        cur_wy = 0.0f;
    }
    if (cur_wx >= max_wx) {
        cur_wx = max_wx - 1;
    }
    if (cur_wy >= max_wy) {
        cur_wy = max_wy - 1;
    }
    if (to_wx < 0.0f) {
        to_wx = 0.0f;
    }
    if (to_wy < 0.0f) {
        to_wy = 0.0f;
    }
    if (to_wx >= max_wx) {
        to_wx = max_wx - 1;
    }
    if (to_wy >= max_wy) {
        to_wy = max_wy - 1;
    }
    if (speed < 0.0f) {
        speed = 0.0f;
    }
    if (cur_wx == to_wx && cur_wy == to_wy) {
        speed = 0.0f;
    }
    if (speed == 0.0f) {
        to_wx = cur_wx;
        to_wy = cur_wy;
    }

    // Current position
    if (cur_wx != group.CurX || cur_wy != group.CurY || speed != group.Speed) {
        group.CurX = cur_wx;
        group.CurY = cur_wy;
        group.Speed = speed;

        int cur_wxi = int(cur_wx);
        int cur_wyi = int(cur_wy);

        for (uint i = 0, l = group.CritMove.length(); i < l; i++) {
            Critter cr1 = group.CritMove[i];
            if (valid(cr1)) {
                cr.WorldX = cur_wxi;
                cr.WorldY = cur_wyi;
                GlobalMapLocations::SetGlobalMapData(GM_INFO_GROUP_PARAM, cr1);
            }
        }
    }

    // New target
    if (type == GLOBAL_PROCESS_SET_MOVE || to_wx != group.ToX || to_wy != group.ToY) {
        GM_GroupSetMove(group, to_wx, to_wy, speed);
        return;
    }

    // Stop
    if (base_speed > 0.0f && speed <= 0.0f) {
        group.Stop();
        GM_GlobalProcess(rule, group, GLOBAL_PROCESS_STOPPED);
        return;
    }

    if (type == GLOBAL_PROCESS_STOPPED) {
        group.SendGlobalData(GM_INFO_GROUP_PARAM);
    }

    // Encounter
    if (encounter_descriptor > 0) {
        group.EncounterDescriptor = encounter_descriptor;
        if (type == GLOBAL_PROCESS_ENTER) {
            GM_GlobalInvite(group, 0);
            // GM_GlobalInvite( group, rule->GetDefaultCombat() );
        }
        else {
            if (wait_for_answer) {
                group.EncounterTick = Game.GetTick() + GM_ANSWER_WAIT_TIME;
                group.EncounterForce = false;
            }
            else {
                group.EncounterTick = Game.GetTick() + GM_LIGHT_TIME;
                group.EncounterForce = true;
            }
            group.SendGlobalData(GM_INFO_GROUP_PARAM);
        }
    }
}

void GM_LeaveGroup(Critter critter) // 6 hits
{
    Critter cr = Game.GetCritter(critter.Id);

    auto group = GetGlobalMapGroup(cr);
    // if( valid( cr.GetMap() ) || !valid( group ) || group.CritMove.length() < 2 )
    if (!valid(group)) {
        return;
    }

    if (group.CritMove.length() < 2) {
        AllGlobalGroups.remove(cr.Id);
        return;
    }

    if (cr.Id != group.Rule.Id) {
        group.EraseCrit(cr);
        // TODO: уведомления для игроков в составе группы, один из покинул группу
        // for( auto it = group->CritMove.begin(), end = group->CritMove.end(); it != end; ++it )
        //    ( *it )->Send_RemoveCritter( cr );

        Item car = cr.GetItem(ItemProperty::Type, ItemType::Car);
        if (car != null && car.Id == group.CarId) {
            group.CarId = ZERO_IDENT;
            GM_GroupSetMove(group, group.ToX, group.ToY, 0.0f);
        }

        GM_GroupStartMove(cr);
    }
    else {
        // Give rule to critter with highest charisma
        Critter newRule;
        int maxCharisma = 0;
        for (uint i = 0; i < group.CritMove.length(); i++) {
            Critter cr1 = group.CritMove[i];
            if (cr1.Id == group.Rule.Id) {
                continue;
            }
            int charisma = cr1.Charisma;
            if (maxCharisma == 0 || charisma > maxCharisma) {
                newRule = cr1;
                maxCharisma = charisma;
            }
        }
        GM_GiveRule(cr, newRule);

        // Call again
        if (cr.Id != group.Rule.Id) {
            GM_LeaveGroup(cr);
        }
    }
}

void GM_GiveRule(Critter cr, Critter newRule) // 5 hits
{
    auto group = GetGlobalMapGroup(cr);
    if (valid(cr.GetMap()) || !valid(group) || group.CritMove.length() < 2 || group.Rule.Id != cr.Id || cr.Id == newRule.Id) {
        return;
    }

    group.Rule = newRule;
    /*
        for( auto it = newRule->GroupSelf->CritMove.begin(), end = newRule->GroupSelf->CritMove.end(); it != end; ++it )
        {
            Critter* cr_ = *it;
            cr_->GroupMove = newRule->GroupSelf;
            cr_->Send_CustomCommand( cr, OTHER_FLAGS, cr->Flags );
            cr_->Send_CustomCommand( newRule, OTHER_FLAGS, newRule->Flags );
        }*/
}

void GM_StopGroup(Critter cr) // 3hits
{
    auto group = GetGlobalMapGroup(cr);
    if (!valid(group) || valid(cr.GetMap())) {
        return;
    }

    group.ToX = group.CurX;
    group.ToY = group.CurY;
    group.Speed = 0.0f;

    GM_GlobalProcess(cr, group, GLOBAL_PROCESS_STOPPED);
}

bool GM_GroupToMap(GlobalMapGroup group, Map map, hstring entry, uint16 mx, uint16 my, uint8 mdir) // 6hits
{
    if (!valid(map)) {
        Game.Log("Map null ptr");
        return false;
    }

    Critter rule = group.Rule;
    uint16 hx, hy;
    uint8 dir;
    uint16 car_hx = 0, car_hy = 0;
    Item car = group.GetCar();
    Critter car_owner;

    if (valid(car)) {
        car_owner = group.GetCritter(car.CritterId);
        if (!valid(car_owner)) {
            Game.Log(" - Car owner not found");
        }
    }

    if (mx >= map.Width || my >= map.Height || mdir >= 6) {
        if (valid(car)) {
            uint entries = Entrance::MapCountEntry(map, ENTRY_CAR);
            uint entriesPass = Entrance::MapCountEntry(map, ENTRY_CAR_CRITTERS);
            int entryNum = -1;

            for (uint i = 0; i < entries && i < entriesPass; i++) {
                Entrance::MapGetEntryCoords(map, ENTRY_CAR, i, car_hx, car_hy);
                if (map.CheckPlaceForItem(car_hx, car_hy, car.ProtoId)) {
                    Entrance::MapGetEntryCoords(map, ENTRY_CAR_CRITTERS, i, hx, hx);
                    entryNum = i;
                    break;
                }
            }

            if (entryNum < 0) {
                rule.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_GLOBAL_CAR_PLACE_NOT_FOUND);
                return false;
            }

            Entrance::MapGetEntryCoords(map, ENTRY_CAR, entryNum, hx, hy);
            if (!map.CheckPlaceForItem(car_hx, car_hy, car.ProtoId)) {
                rule.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_GLOBAL_CAR_PLACE_NOT_FOUND);
                return false;
            }
            if (mdir < 6) {
                dir = mdir;
            }
        }
        else {
            if (!Entrance::GetEntryFreeHex(map, ENTRY_DEFAULT, hx, hy)) {
                rule.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_GLOBAL_PLACE_NOT_FOUND);
                return false;
            }
        }
    }
    else {
        hx = mx;
        hy = my;
        dir = mdir;
        if (valid(car)) {
            uint entries = Entrance::MapCountEntry(map, ENTRY_CAR);
            uint entriesPass = Entrance::MapCountEntry(map, ENTRY_CAR_CRITTERS);
            int entryNum = -1;

            for (uint i = 0; i < entries && i < entriesPass; i++) {
                Entrance::MapGetEntryCoords(map, ENTRY_CAR, i, car_hx, car_hy);
                if (map.CheckPlaceForItem(car_hx, car_hy, car.ProtoId)) {
                    Entrance::MapGetEntryCoords(map, ENTRY_CAR_CRITTERS, i, hx, hx);
                    entryNum = i;
                    break;
                }
            }

            if (entryNum < 0) {
                rule.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_GLOBAL_CAR_PLACE_NOT_FOUND);
                return false;
            }
        }
    }

    auto transitCr = group.CritMove;

    // Transit rule
    rule.WorldX = uint16(group.CurX);
    rule.WorldY = uint16(group.CurY);
    if (valid(car)) {
        Game.MoveItem(car, 1, map, car_hx, car_hy);
    }
    rule.TransitToMap(map, hx, hy, Game.Random(0, 5));
    // Transit other
    for (int i = 0, l = transitCr.length(); i < l; i++) {
        Critter cr1 = transitCr[i];
        if (!valid(cr1) || cr1.Id == rule.Id) {
            continue;
        }

        cr1.WorldX = uint16(group.CurX);
        cr1.WorldY = uint16(group.CurY);

        cr1.TransitToMap(map, hx, hy, Game.Random(0, 5));
        if (!valid(cr1.GetMap())) // Проверить, что криттер успеет сюда попасть
        // if( !Transit( cr, map, hx, hy, dir, valid( car ) ? 3 : 2, true ) )
        {
            GM_GroupStartMove(cr1);
            continue;
        }
    }

    group.Clear();
    return true;
}

bool GM_GroupToLoc(Critter rule, ident locId, uint8 entrance, bool force = false) // 3 hits
{
    if (valid(rule.GetMap())) {
        return false;
    }
    auto group = GetGlobalMapGroupByRuler(rule);
    if (!valid(group)) {
        return false;
    }
    // if( rule.IsOwnedByPlayer() )//&& rule.IsOffline() )
    //     return false;                                                      // Offline on encounter
    if (locId == ZERO_IDENT) {
        return false;
    }

    if (rule.Id != group.Rule.Id) {
        Game.Log(" - Critter is not rule.\n");
        return false;
    }

    if (!force && !Location::IsKnownLoc(rule, locId) && rule.IsOwnedByPlayer()) {
        Game.Log(" - Critter '%s' is not known location. CriterId: " + rule.Id);
        return false;
    }

    Location loc = Game.GetLocation(locId);
    if (!valid(loc)) {
        if (rule.IsOwnedByPlayer()) {
            Location::UnsetKnownLoc(rule, locId);
        }
        GlobalMapLocations::SetGlobalMapData(GM_INFO_LOCATIONS, rule);
        // rule->Send_GlobalInfo( GM_INFO_LOCATIONS );
        rule.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_GLOBAL_LOCATION_NOT_FOUND);
        return false;
    }

    // force позволяет избежать проверки расстояния до локи
    if (!force && uint(math::sqrt(float(Math::Pow2(uint16(group.CurX) - loc.WorldX) + Math::Pow2(uint16(group.CurY) - loc.WorldY)))) > loc.Radius) {
        if (rule.IsOwnedByPlayer()) {
            GlobalMapLocations::SetGlobalMapData(GM_INFO_LOCATIONS, rule);
        }
        rule.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_GLOBAL_LOCATION_REMOVED);
        return false;
    }

    if (!force && !Location::IsCanEnter(loc, group.CritMove.length())) {
        rule.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_GLOBAL_PLAYERS_OVERFLOW);
        return false;
    }

    if (loc.GetMapCount() == 0) {
        if (rule.IsOwnedByPlayer()) {
            Location::UnsetKnownLoc(rule, locId);
        }
        Game.Log(" - Location is empty.");
        return false;
    }

    if (entrance >= loc.MapEntrances.length()) {
        Game.Log(" - Invalid entrance.");
        return false;
    }

    bool result = GM_CheckEntrance(loc, group.CritMove, entrance);
    if (!result) {
        Game.Log(" - Can't enter in entrance " + entrance);
        return false;
    }

    if (!Game.OnLocationEnter.Fire(loc, group.CritMove, entrance)) {
        return false;
    }

    /*hstring mapProto = loc.MapEntrances[ entrance * 2 ];
       hstring entry = loc.MapEntrances[ entrance * 2 + 1 ];

       Map map = loc.GetMap( mapProto );*/

    hstring entry;
    uint mapIndex = 0;
    loc.GetEntrance(entrance, mapIndex, entry);

    Map map = loc.GetMapByIndex(mapIndex);
    if (!valid(map)) {
        if (rule.IsOwnedByPlayer()) {
            Location::UnsetKnownLoc(rule, locId);
        }
        Game.Log(" - Map " + mapIndex + " not found in location " + locId);
        return false;
    }

    return GM_GroupToMap(group, map, entry, uint16(-1), uint16(-1), uint8(-1));
}

uint DistSqrt(int x1, int y1, int x2, int y2)
{
    int dx = x1 - x2;
    int dy = y1 - y2;
    return uint(math::sqrt(double(dx * dx + dy * dy)));
}

void GM_GroupSetMove(GlobalMapGroup group, float to_x, float to_y, float speed) // 6 hits
{
    int dist = DistSqrt(int(to_x), int(to_y), int(group.CurX), int(group.CurY));

    if (speed <= 0.0f || dist == 0) {
        group.Speed = 0.0f;
        group.ToX = group.CurX;
        group.ToY = group.CurY;
    }
    else {
        group.Speed = speed;
        group.ToX = to_x;
        group.ToY = to_y;
    }

    GlobalMapLocations::SetGlobalMapData(GM_INFO_GROUP_PARAM, group.Rule);
    // group->Rule->SendA_GlobalInfo( group, GM_INFO_GROUP_PARAM );
    if (Game.GetTick() - group.ProcessLastTick > Settings.GlobalMapMoveTime) {
        group.ProcessLastTick = Game.GetTick();
    }
    if (!group.IsSetMove) {
        group.IsSetMove = true;
        GM_GlobalProcess(group.Rule, group, GLOBAL_PROCESS_START);
    }
}

void GM_GroupMove(GlobalMapGroup group) // 3hits
{
    uint tick = Game.GetTick();
    Critter rule = group.Rule;

    // Encounter
    if (group.EncounterDescriptor > 0) {
        if (tick < group.EncounterTick) {
            return;
        }

        // Force invite
        if (group.EncounterForce) {
            GM_GlobalInvite(group, 0); // TODO: turnbasedrule->GetDefaultCombat() );
            return;
        }

        // Continue walk
        group.EncounterDescriptor = 0;
        GlobalMapLocations::SetGlobalMapData(GM_INFO_GROUP_PARAM, rule);
        group.ProcessLastTick = tick;
    }

    // Start callback
    if (!group.IsSetMove && tick >= group.TimeCanFollow) {
        group.IsSetMove = true;
        GM_GlobalProcess(rule, group, GLOBAL_PROCESS_START);
        return;
    }

    // Move
    if (group.IsMoving()) {
        uint dtime = tick - group.ProcessLastTick;
        if (dtime >= Settings.GlobalMapMoveTime) {
            if (dtime >= Settings.GlobalMapMoveTime * 2) {
                dtime = 0;
            }
            group.ProcessLastTick = tick - dtime % Settings.GlobalMapMoveTime;

            if (rule.IsOwnedByPlayer() && rule.IsDead()) // && rule.IsOffline() )
            {
                group.Stop();
                GM_GlobalProcess(rule, group, GLOBAL_PROCESS_STOPPED);
                return;
            }

            GM_GlobalProcess(rule, group, GLOBAL_PROCESS_MOVE);
        }
    }
}

void GM_GlobalInvite(GlobalMapGroup group, int combat_mode) // 5hits
{
    uint encounter_descriptor = group.EncounterDescriptor;
    group.EncounterDescriptor = 0;

    ident map_id;
    uint16 hx = 0;
    uint16 hy = 0;
    uint8 dir = 0;
    Critter rule = group.Rule;
    bool global_invite = true;

    if (rule.OnGlobalMapInvite.Fire(group.GetCar(), encounter_descriptor, combat_mode, map_id, hx, hy, dir)) {
        global_invite = false;
    }
    else {
        map_id = ZERO_IDENT;
        hx = 0;
        hy = 0;
        dir = 0;
    }

    if (!group.IsValid()) {
        return;
    }

    GlobalmapGroup::global_invite(rule, group.GetCar(), encounter_descriptor, combat_mode, map_id, hx, hy, dir);

    if (!group.IsValid()) {
        return;
    }
    if (map_id != ZERO_IDENT) {
        Map map = Game.GetMap(map_id);
        if (valid(map)) {
            GM_GroupToMap(group, map, hstring("0"), hx, hy, dir < 6 ? dir : rule.Dir);
        }
    }
    else {
        group.SendGlobalData(GM_INFO_GROUP_PARAM);
    }
}

bool GM_CheckEntrance(Location loc, Critter[] arr, uint8 entrance) // 5 hits
{
    return Game.OnGlobalMapCheckEntranceAllowed.Fire(loc, arr, entrance);
}

void ProcessGlobalMapCommand(Player player, uint8 command, any param1, any param2) // Process_RuleGlobal
{
    Critter cl = player.GetOwnedCritter();

    switch (command) {
    case GM_CMD_FOLLOW_CRIT: {
        if (param1 == 0) {
            break;
        }

        Critter cr = Game.GetCritter(param1);
        if (!valid(cr)) {
            break;
        }

        if (cl.FollowLeaderId == cr.Id) {
            cl.FollowLeaderId = ZERO_IDENT; // unfollow
        }
        else {
            cl.FollowLeaderId = cr.Id;
        }
    } break;
    case GM_CMD_SETMOVE: {
        auto group = GetGlobalMapGroupByRuler(cl);

        if (valid(cl.GetMap()) || !valid(group) || cl.Id != group.Rule.Id) {
            break;
        }
        if (float(param1) >= float(GM_MAXX) || float(param2) >= float(GM_MAXY)) {
            break;
        }
        if (group.EncounterDescriptor > 0) {
            break;
        }
        group.ToX = float(param1);
        group.ToY = float(param2);
        GM_GlobalProcess(cl, group, GLOBAL_PROCESS_SET_MOVE);
    } break;
    case GM_CMD_STOP:
        break;
    case GM_CMD_TOLOCAL: {
        auto group = GetGlobalMapGroupByRuler(cl);
        if (valid(cl.GetMap()) || !valid(group) || cl.Id != group.Rule.Id) {
            break;
        }
        if (group.EncounterDescriptor > 0) {
            break;
        }
        if (IS_TIMEOUT(cl.TimeoutTransfer)) {
            cl.SayMsg(SAY_NETMSG, TEXTMSG_GAME, MsgStr::StrTimeoutTransferWait);
            break;
        }

        if (param1 == 0) {
            if (valid(cl.GetMap()) || !valid(group) || cl.Id != group.Rule.Id) {
                break;
            }
            group.EncounterDescriptor = 0;
            GM_GlobalProcess(cl, group, GLOBAL_PROCESS_ENTER);
        }
        else {
            GM_GroupToLoc(cl, param1, param2);
        }
    }
        return;
    case GM_CMD_ANSWER: {
        auto group = GetGlobalMapGroupByRuler(cl);
        if (valid(cl.GetMap()) || !valid(group) || cl.Id != group.Rule.Id) {
            break;
        }
        if (group.EncounterDescriptor == 0 || group.EncounterForce) {
            break;
        }

        if (int(param1) >= 0) // Yes
        {
            GM_GlobalInvite(group, param1);
            return;
        }
        else if (group.EncounterDescriptor > 0) // No
        {
            group.EncounterDescriptor = 0;
            group.SendGlobalData(GM_INFO_GROUP_PARAM);
        }
    } break;
    case GM_CMD_FOLLOW: {
        // Find rule
        Critter rule = Game.GetCritter(param1);
        if (!valid(rule) || valid(rule.GetMap())) {
            break;
        }
        auto group = GetGlobalMapGroupByRuler(rule);
        if (!valid(group) || rule.Id != group.Rule.Id) {
            break;
        }

        // Check for follow
        if (!group.CheckForFollow(cl)) {
            break;
        }
        if (Game.GetDistance(rule.MapLeaveHexX, rule.MapLeaveHexY, cl.HexX, cl.HexX) > FOLLOW_DIST + rule.Multihex + cl.Multihex) {
            break;
        }

        cl.TransitToGlobalGroup(rule);
        if (!valid(cl.GetMap())) { // TODO: проверить, что успевает покинуть карту
            break;
        }
    }
        return;
    case GM_CMD_KICKCRIT: {
        auto group = GetGlobalMapGroup(cl);
        if (valid(cl.GetMap()) || !valid(group) || group.CritMove.length() < 2 || group.EncounterDescriptor > 0) {
            break;
        }

        Critter kick_cr;

        if (cl.Id == param1) // Kick self
        {
            if (cl.Id == group.Rule.Id) {
                break;
            }
            kick_cr = cl;
        }
        else // Kick other
        {
            if (cl.Id != group.Rule.Id) {
                break;
            }
            kick_cr = group.GetCritter(param1);
            if (!valid(kick_cr)) {
                break;
            }
        }

        GM_GlobalProcess(kick_cr, group, GLOBAL_PROCESS_KICK);
    } break;
    case GM_CMD_GIVE_RULE: {
        auto group = GetGlobalMapGroupByRuler(cl);
        // Check
        if (cl.Id == param1 || valid(cl.GetMap()) || !valid(group) || cl.Id != group.Rule.Id || group.EncounterDescriptor > 0) {
            break;
        }
        Critter newRule = group.GetCritter(param1);
        if (!valid(newRule) || !newRule.IsOwnedByPlayer() || !newRule.IsOnline()) {
            break;
        }

        GM_GiveRule(cl, newRule);
        GM_StopGroup(cl);
    } break;
    case GM_CMD_ENTRANCES: {
        auto group = GetGlobalMapGroupByRuler(cl);
        if (valid(cl.GetMap()) || !valid(group) || group.EncounterDescriptor > 0) {
            break;
        }

        ident locId = param1;
        if (locId == ZERO_IDENT) {
            break;
        }

        Location loc = Game.GetLocation(locId);
        if (!valid(loc) || DistSqrt(int(group.CurX), int(group.CurY), loc.WorldX, loc.WorldY) > loc.Radius) {
            break;
        }

        uint tick = Game.GetTick();
        if (cl.LastSendEntrancesLocId == locId && tick < cl.LastSendEntrancesTick + GM_ENTRANCES_SEND_TIME) {
            Game.Log(" Client '%s' ignore send entrances timeout." + cl.Id);
            break;
        }
        cl.LastSendEntrancesLocId = locId;
        cl.LastSendEntrancesTick = tick;

        int[] allowedEntrances = {};

        for (uint i = 0, l = loc.MapEntrances.length(); i < l; i += 2) {
            if (GM_CheckEntrance(loc, group.CritMove, i)) {
                allowedEntrances.insertLast(i / 2);
            }
        }

        // cl.GetOwner().ClientCall.SetCurrentLocationEntrances( loc.ProtoId, allowedEntrances );
        cl.GetOwner().ClientCall.ShowGMTown(loc.Id, loc.ProtoId, allowedEntrances);
    } break;
    case GM_CMD_VIEW_MAP: {
        auto group = GetGlobalMapGroupByRuler(cl);

        if (valid(cl.GetMap()) || !valid(group) || group.EncounterDescriptor > 0) {
            break;
        }

        ident locId = param1;
        if (locId == ZERO_IDENT) {
            break;
        }

        Location loc = Game.GetLocation(locId);
        if (!valid(loc) || DistSqrt(int(group.CurX), int(group.CurY), loc.WorldX, loc.WorldY) > loc.Radius) {
            break;
        }

        uint entrance = param2;

        if (entrance >= loc.MapEntrances.length()) {
            break;
        }

        if (!GM_CheckEntrance(loc, group.CritMove, entrance)) {
            break;
        }

        // hstring mapProto = loc.MapEntrances[ entrance * 2 ];
        // hstring entry = loc.MapEntrances[ entrance * 2 + 1 ];
        // Map map = loc.GetMap( mapProto );
        hstring entry;
        uint mapIndex = 0;
        loc.GetEntrance(entrance, mapIndex, entry);

        Map map = loc.GetMapByIndex(mapIndex);
        if (!valid(map)) {
            break;
        }

        uint8 dir;
        uint16 hx = 0, hy = 0;
        // if( !map->GetStartCoord( hx, hy, dir, loc->Proto->Entrance[ entrance ].second ) )
        if (!Entrance::GetEntryFreeHex(map, entry, hx, hy)) {
            break;
        }

        uint look = 0; // 0? cr.LookDistance

        cl.ViewMap(map, 0, hx, hy, 0);
        cl.GetOwner().ClientCall.ShowTownView(locId, entrance);

    } break;
    default:
        Game.Log(" - Unknown command " + command + "; from critter:   " + cl.Id);
        break;
    }

    cl.Wait(Settings.Breaktime);
}

#endif
