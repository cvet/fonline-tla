namespace NpcPlanes // Sort -8
{

#if SERVER

// TODO:: void FOServer::ProcessAI( Npc* npc ) from ServerNpc.cpp engine 1519

///@ Property Critter PrivateServer int32[] Planes

///@ Event Server Game OnNpcPlaneBegin(Critter critter, int32 planeId, int32 reason, Critter someCr, Item someItem)
///@ Event Server Game OnNpcPlaneEnd(Critter critter, int32 planeId, int32 reason, Critter someCr, Item someItem)
///@ Event Server Game OnNpcPlaneRun(Critter critter, int32 planeId, int32 reason, any& result0, any& result1, any& result2)
///@ Event Server Critter OnNpcPlaneBegin(int32 planeId, int32 reason, Critter someCr, Item someItem)
///@ Event Server Critter OnNpcPlaneEnd(int32 planeId, int32 reason, Critter someCr, Item someItem)
///@ Event Server Critter OnNpcPlaneRun(int32 planeId, int32 reason, any& result0, any& result1, any& result2)

#define MAX_PLANES_PER_CRITTER (10)

// Planes types
#define AI_PLANE_MISC    (0)
#define AI_PLANE_ATTACK  (1)
#define AI_PLANE_WALK    (2)
#define AI_PLANE_PICK    (3)
#define AI_PLANE_PATROL  (4) // WIP
#define AI_PLANE_COURIER (5) // WIP

// Planes deault priority
#define AI_PLANE_MISC_PRIORITY    (10)
#define AI_PLANE_ATTACK_PRIORITY  (50)
#define AI_PLANE_WALK_PRIORITY    (20)
#define AI_PLANE_PICK_PRIORITY    (35)
#define AI_PLANE_PATROL_PRIORITY  (25)
#define AI_PLANE_COURIER_PRIORITY (30)

// Plane begin/end/run reasons
// Begin
#define REASON_GO_HOME              (10)
#define REASON_FOUND_IN_ENEMY_STACK (11)
#define REASON_FROM_DIALOG          (12)
#define REASON_FROM_SCRIPT          (13)
#define REASON_RUN_AWAY             (14)
// End
#define REASON_SUCCESS            (30)
#define REASON_HEX_TOO_FAR        (31)
#define REASON_HEX_BUSY           (32)
#define REASON_HEX_BUSY_RING      (33)
#define REASON_DEADLOCK           (34)
#define REASON_TRACE_FAIL         (35)
#define REASON_POSITION_NOT_FOUND (36)
#define REASON_FIND_PATH_ERROR    (37)
#define REASON_CANT_WALK          (38)
#define REASON_TARGET_DISAPPEARED (39)
#define REASON_USE_ITEM_NOT_FOUND (40)
#define REASON_GAG_CRITTER        (41)
#define REASON_GAG_ITEM           (42)
#define REASON_NO_UNARMED         (43)
#define REASON_CANT_SEE_TARGET    (44)
// Run
#define REASON_ATTACK_TARGET     (50)
#define REASON_ATTACK_WEAPON     (51)
#define REASON_ATTACK_DISTANTION (52)
#define REASON_ATTACK_USE_AIM    (53)

void NL(Critter npc, string str)
{
    Game.Log("id=" + npc.Id + " " + npc.Name + " - " + str);
    Messaging::SayOnHead(npc, str);
}

funcdef void NpcPlaneMiscFunc(Critter cr);

void ModuleInit()
{
    Game.OnCritterInit.Subscribe(OnCritterInit);
    Game.OnMapCritterOut.Subscribe(OnMapCritterOut);
}

void OnCritterInit(Critter cr, bool firstTime)
{
    if (!cr.ControlledByPlayer) {
        cr.StartTimeEvent(Time::Milliseconds(Game.Random(0, 1000)), Time::Milliseconds(1000), OnCritterIdle);
    }
}

void OnCritterIdle(Critter npc)
{
    if (npc.ControlledByPlayer || CritterState::IsBusy(npc)) {
        return;
    }

    if (npc.IsAlive()) {
        const int wait = ProcessAi(npc);
        if (wait != 0) {
            CritterState::Wait(npc, wait);
        }
    }
}

void OnMapCritterOut(Map map, Critter cr)
{
    DropPlanes(cr);
}

bool CheckHasEnoughAP(Critter cr, int ap)
{
    return cr.CurrentAp >= int(ap);
}

int ProcessAi(Critter npc)
{
    // Check busy
    if (CritterState::IsBusy(npc)) {
        return 1000;
    }

    // Global map
    if (npc.MapId == ZERO_IDENT) {
        // TODO: global and groups
        /*if( !npc->GroupMove )
            return;
           MapMngr.GM_GlobalProcess( npc, npc->GroupMove, GLOBAL_PROCESS_NPC_IDLE );
           if( !npc->GetMapId() && !npc->IsWait() )
            npc->SetWait( GameOpt.CritterIdleTick );*/
        return 5000;
    }

    // Get map
    Map map = Game.GetMap(npc.MapId);
    if (map == null) {
        return 5000;
    }

    // Check turn based
    // TODO: turnbased
    // if( map->IsTurnBasedOn && !map->IsCritterTurn( npc ) )
    //    return;

    // Check wait
    // r17:
    /*if( npc->IsWait() )
       {
        if( map->IsTurnBasedOn )
            map->EndCritterTurn();
        return;
       }*/

    // Get current plane
    NpcPlane plane = GetCurPlane(npc);
    // Begin
    if (plane == null) {
        // Check talking
        if (Dialogs::IsTalking(npc)) {
            return 2000;
        }

        // Enemy stack
        Critter enemy = EnemyStack::ScanEnemyStack(npc);
        if (enemy != null) {
            if (AddAttackPlane(npc, 0, REASON_FOUND_IN_ENEMY_STACK, enemy)) {
                return 0;
            }
        }

        // Go home
        if (!npc.IsNoHome && map.Id == npc.HomeMapId && (npc.Hex != npc.HomeHex)) {
            if (!npc.IsNoMove) {
                AddWalkPlane(npc, 0, 0, 0, npc.HomeHex, npc.HomeDir == 0 ? 1 : 0, false, 0, REASON_GO_HOME);
            }
            else if (map.IsHexesMovable(npc.HomeHex, npc.Multihex)) {
                npc.TransitToMap(map, npc.HomeHex, npc.HomeDir);
                return 0;
            }
        }
        // Set home direction
        else if (!npc.IsNoHome && map.Id == npc.HomeMapId && npc.Dir != npc.HomeDir) {
            npc.SetDir(npc.HomeDir);
        }
        return 0;
    }
    else {
        // Process move
        if (plane.IsMove) {
            // Check run availability
            if (plane.Run) {
                if (npc.IsDamagedRightLeg || npc.IsDamagedLeftLeg || npc.IsOverweight) {
                    plane.Run = false;
                    SavePlan(npc, plane);
                }
            }

            // Check ap availability
            int ap_move = (plane.Run ? Settings.RtApCostCritterRun : Settings.RtApCostCritterWalk);

            // TODO:tb
            /*
               if( map->IsTurnBasedOn )
                    ap_move += npc->GetMoveAp();
             */
            plane.IsMove = false;
            SavePlan(npc, plane);
            if (!CheckHasEnoughAP(npc, ap_move)) {
                int wait = Settings.ApRegeneration / npc.ActionPoints * (ap_move - npc.CurrentAp) / AP_DIVIDER;
                // npc->SetWait( GameOpt.ApRegeneration / npc->GetActionPoints() * ( (int) ( need_ap ) - npc->GetRealAp() ) / AP_DIVIDER );
                return wait;
            }
            plane.IsMove = true;
            SavePlan(npc, plane);

            MovingState state = npc.GetMovingState();
            if (state != MovingState::InProgress && state != MovingState::Success) {
                ident gagId;
                npc.GetMovingState(gagId);
                npc.StopMoving();

                int reason = REASON_TRACE_FAIL;
                switch (state) {
                case MovingState::GagCritter:
                    reason = REASON_GAG_CRITTER;
                    break;
                case MovingState::GagItem:
                    reason = REASON_GAG_ITEM;
                    break;
                }

                Critter gagCr = (gagId == ZERO_IDENT ? null : Game.GetCritter(gagId));
                Item gagItem = (gagId == ZERO_IDENT ? null : Game.GetItem(gagId));
                if (Game.OnNpcPlaneEnd.Fire(npc, plane.PlaneId, reason, gagCr, gagItem)) {
                    ErasePlane(npc, 0); // TODO: возможно, здесь нужночто-то другое, не удалять план
                }
                return 0;
            }
            plane.IsMove = false;
        }

        bool is_busy = (plane.IsMove || CritterState::IsBusy(npc)); // || CritterState::IsWait(npc);

        // Process planes
        switch (plane.Type) {
        /************************************************************************/
        /* ==================================================================== */
        /* ========================   Misc   ================================== */
        /* ==================================================================== */
        /************************************************************************/
        case AI_PLANE_MISC: {
            if (is_busy) {
                break;
            }

            synctime wait = plane.Misc_WaitSecond;
            NpcPlaneMiscFunc func = plane.Misc_Script;

            if (wait > Game.SynchronizedTime) {
                return (wait - Game.SynchronizedTime).seconds;
            }
            else if (func !is null) {
                func(npc);
            }
            else {
                NextPlane(npc, REASON_SUCCESS);
            }
        } break;
        /************************************************************************/
        /* ==================================================================== */
        /* ========================   Attack   ================================ */
        /* ==================================================================== */
        /************************************************************************/
        case AI_PLANE_ATTACK: {
            // TODO: tb
            // if( map->Data.IsTurnBasedAvailable && !map->IsTurnBasedOn )
            //	map->BeginTurnBased( npc );

            /************************************************************************/
            /* Target is visible                                                    */
            /************************************************************************/
            Critter targ = Game.GetCritter(plane.Attack_TargId);

            if (valid(targ) && npc.IsSee(targ)) {
                /************************************************************************/
                /* Step 0: Check for success plane and continue target timeout          */
                /************************************************************************/

                if (plane.Attack_IsGag && (targ.Hex != plane.Attack_GagHex)) {
                    NextPlane(npc, REASON_SUCCESS);
                    break;
                }

                bool attack_to_dead = (plane.Attack_MinHp <= Settings.DeadHitPoints);
                if (!plane.Attack_IsGag && (!attack_to_dead && targ.CurrentHp <= plane.Attack_MinHp) || (attack_to_dead && targ.IsDead())) {
                    NextPlane(npc, REASON_SUCCESS);
                    break;
                }

                if (plane.IsMove && plane.Attack_LastHex == mpos()) {
                    plane.IsMove = false;
                    SavePlan(npc, plane);
                }

                plane.Attack_LastHex = targ.Hex;
                SavePlan(npc, plane);

                if (is_busy) {
                    break;
                }

                // Is moving
                if (npc.GetMovingState() == MovingState::InProgress) {
                    return 1000;
                }
                /************************************************************************/
                /* Step 1: Choose weapon                                                */
                /************************************************************************/
                // Get battle weapon
                int use;
                AbstractItem weap;
                any r0 = targ.Id;
                any r1 = 0;
                any r2 = 0;
                if (!Game.OnNpcPlaneRun.Fire(npc, plane.PlaneId, REASON_ATTACK_WEAPON, r0, r1, r2)) {
                    Game.Log("REASON_ATTACK_WEAPON fail. Skip attack.\n");
                    break;
                }
                if (plane.PlaneId != plane.GetCurPlane().PlaneId) { // TODO: проверить, что тут нет ошибки
                    break;                                          // Validate plane
                }

                if (ident(r0) != ZERO_IDENT) {
                    weap = npc.GetItem(ident(r0)); // TODO: проверить, что оружие найдено
                }
                else {
                    if (npc.IsNoUnarmed) {
                        NextPlane(npc, REASON_NO_UNARMED);
                        break;
                    }

                    ProtoItem unarmed = Game.GetProtoItem(hstring_fromHash(r2));
                    if (!valid(unarmed) || !unarmed.Weapon_IsUnarmed) {
                        unarmed = Game.GetProtoItem(hstring("default_weapon"));
                    }

                    weap = unarmed;
                }
                use = r1;

                if (!valid(weap) || weap.Type != ItemType::Weapon || weap.Weapon_ActiveUses <= use) {
                    Game.Log("REASON_ATTACK_WEAPON fail");
                    break;
                }

                AbstractItem mainItem = CritterItem::GetActive(npc);
                Item realMainItem = cast<Item>(mainItem);
                Item realWeapon = cast<Item>(weap);

                // Hide cur, show new
                if (realMainItem != null && realWeapon != null && realWeapon.Id != realMainItem.Id) {
                    CritterActions::MoveInvItem(npc, realMainItem.Id, CritterItemSlot::Inventory);
                    break; // TODO: проверить, не слишком ли долго будет думать нпц при замене оружия
                }

                if (realMainItem == null && realWeapon != null) {
                    CritterActions::MoveInvItem(npc, realWeapon.Id, CritterItemSlot::Main);
                    break;
                }

                if (realWeapon != null) {
                    Parameters::SetWeaponMode(realWeapon, _WeaponModeMake(use, 0));
                }
                else {
                    npc.HandsItemMode = _WeaponModeMake(use, 0);
                }

                // Load weapon
                if (realWeapon != null) {
                    if (!npc.IsUnlimitedAmmo && realWeapon.Weapon_MaxAmmoCount > 0 && realWeapon.AmmoCount == 0) {
                        Item ammo = Obsolete::FindAmmoForWeapon(npc, realWeapon);
                        if (ammo != null) {
                            if (realWeapon.AmmoPid == EMPTY_HSTRING) {
                                realWeapon.AmmoPid = realWeapon.Weapon_DefaultAmmoPid;
                            }
                            realWeapon.AmmoCount = realWeapon.Weapon_MaxAmmoCount;
                        }
                        else {
                            CritterActions::ReloadWeapon(npc, realWeapon.Id, ammo.Id);
                            break;
                        }
                    }
                    else if (npc.IsUnlimitedAmmo && realWeapon.Weapon_MaxAmmoCount > 0) {
                        if (realWeapon.AmmoPid == EMPTY_HSTRING) {
                            realWeapon.AmmoPid = realWeapon.Weapon_DefaultAmmoPid;
                        }
                        realWeapon.AmmoCount = realWeapon.Weapon_MaxAmmoCount;
                    }
                }

                /************************************************************************/
                /* Step 2: Move to target                                               */
                /************************************************************************/
                bool is_can_walk = !npc.IsNoMove;
                int best_dist = 0, min_dist = 0, maxDist = 0;
                r0 = targ.Id;
                r1 = 0;
                r2 = 0;
                if (!Game.OnNpcPlaneRun.Fire(npc, plane.PlaneId, REASON_ATTACK_DISTANTION, r0, r1, r2)) {
                    Game.Log("REASON_ATTACK_DISTANTION fail. Skip attack.\n");
                    break;
                }
                if (plane.PlaneId != plane.GetCurPlane().PlaneId) {
                    break; // Validate plane
                }

                best_dist = r0;
                min_dist = r1;
                maxDist = r2;

                if (r2 <= 0) // Run away
                {
                    NextPlane(npc, REASON_RUN_AWAY);
                    break;
                }

                if (maxDist <= 0) {
                    int look = npc.LookDistance;
                    maxDist = Parameters::GetItemAttackDistance(npc, weap, use);
                    if (maxDist > look) {
                        maxDist = look;
                    }
                }
                if (min_dist <= 0) {
                    min_dist = 1;
                }

                if (min_dist > maxDist) {
                    min_dist = maxDist;
                }
                best_dist = CLAMP(best_dist, min_dist, maxDist);
                int actualDist = Game.GetDistance(npc.Hex, targ.Hex);

                if (actualDist > maxDist) {
                    if (!npc.IsNoMove) {
                        plane.IsMove = true;
                        SavePlan(npc, plane);
                        npc.MoveToCritter(targ, best_dist, plane.Run && !npc.IsNoRun ? npc.WalkSpeed * 2 : npc.WalkSpeed);
                        break;
                    }
                    NextPlane(npc, REASON_CANT_WALK);
                    break;
                }

                // Find better position
                mpos hex = npc.Hex;
                mpos targetHex = targ.Hex;
                mpos resHex = targetHex;

                bool is_range = (maxDist > 2);
                if (is_range && !npc.IsNoMove) {
                    // Check target reachability
                    auto tracer = AttackCritterTracer(targ);
                    LineTracer::LineTracerHex(hex, targetHex, map, maxDist, tracer);
                    if (!tracer.Success) {
                        float angleDir = (Game.Random(0, 1) == 0 ? 1 : -1);
                        float baseAngle = LineTracer::GetDirectionF(targetHex, hex);
                        for (int i = 0; i < 17; i++) {
                            float angle = baseAngle * 20.0 * float(i / 2 + 1) * (i % 2 == 0 ? angleDir : -angleDir);
                            mpos thex = hex;
                            map.GetWallHexInPath(targetHex, thex, angle, best_dist);
                            int dist = Game.GetDistance(targetHex, thex);
                            if (dist >= min_dist) {
                                LineTracer::LineTracerHex(thex, targetHex, map, maxDist, tracer);
                                if (tracer.Success) {
                                    plane.IsMove = true;
                                    SavePlan(npc, plane);
                                    npc.MoveToHex(thex, 0, plane.Run && !npc.IsNoRun ? npc.WalkSpeed * 2 : npc.WalkSpeed);
                                    break;
                                }
                            }
                        }

                        // Better position not found
                        NextPlane(npc, REASON_POSITION_NOT_FOUND);
                        break;
                    }
                }
                // Find precision HtH attack
                else if (!is_range) {
                    if (Game.GetDistance(npc.Hex, targ.Hex) > maxDist) {
                        if (!is_can_walk) {
                            NextPlane(npc, REASON_CANT_WALK);
                        }
                        else if (maxDist > 1 && best_dist == 1) {
                            plane.IsMove = true;
                            SavePlan(npc, plane);
                            npc.MoveToCritter(targ, best_dist, plane.Run && !npc.IsNoRun ? npc.WalkSpeed * 2 : npc.WalkSpeed);
                        }

                        break;
                    }
                }

                /************************************************************************/
                /* Step 3: Attack                                                       */
                /************************************************************************/

                r0 = targ.Id;
                r1 = 0;
                r2 = 0;
                if (!Game.OnNpcPlaneRun.Fire(npc, plane.PlaneId, REASON_ATTACK_USE_AIM, r0, r1, r2)) {
                    Game.Log("REASON_ATTACK_USE_AIM fail. Skip attack.\n");
                    break;
                }

                if (r2 > 0) {
                    return r2;
                }

                if (r0 != int(use) && weap.Weapon_ActiveUses > int(r0)) {
                    use = r0;
                }

                int aim = r1;
                if (npc.IsNoAim || !_WeaponAim(weap, use)) {
                    aim = 0;
                }
                if (realWeapon != null) {
                    Parameters::SetWeaponMode(realWeapon, _WeaponModeMake(use, aim));
                }
                else {
                    npc.HandsItemMode = _WeaponModeMake(use, 0);
                }
                CritterActions::Attack(npc, targ.Id, _WeaponModeMake(use, aim));
            }
            /************************************************************************/
            /* Target not visible, try find by last stored position                 */
            /************************************************************************/
            else {
                if (is_busy) {
                    break;
                }

                if (plane.Attack_LastHex == mpos() || npc.IsNoMove) {
                    // Critter targ_ = Game.GetCritter( plane.Attack_TargId );
                    NextPlane(npc, REASON_TARGET_DISAPPEARED);
                    break;
                }
                // AttackPlan Is moving last pos"
                if (npc.GetMovingState() == MovingState::InProgress) {
                    break;
                }
                //AddWalkPlane(npc, 0, 0, 0, plane.Attack_LastHexX, plane.Attack_LastHexY, 1, plane.Run, npc.LookDistance / 2, REASON_CANT_SEE_TARGET);
                //plane.Attack_LastHexX = 0;
                //plane.Attack_LastHexY = 0;
                //SavePlan(npc, plane);
                NextPlane(npc, REASON_CANT_SEE_TARGET);
                break;
            }
        } break;
        /************************************************************************/
        /* ==================================================================== */
        /* ========================   Walk   ================================== */
        /* ==================================================================== */
        /************************************************************************/
        case AI_PLANE_WALK: {
            if (is_busy) {
                break;
            }

            if (Game.GetDistance(npc.Hex, plane.Walk_Hex) <= plane.Walk_Cut) {
                if (plane.Walk_Dir < 6) {
                    npc.SetDir(plane.Walk_Dir);
                }
                else if (plane.Walk_Cut > 0) {
                    npc.SetDir(Game.GetDirection(npc.Hex, plane.Walk_Hex));
                }

                NextPlane(npc, REASON_SUCCESS);
            }
            else {
                if (npc.IsNoMove) {
                    NextPlane(npc, REASON_CANT_WALK);
                    break;
                }
                npc.MoveToHex(plane.Walk_Hex, plane.Walk_Cut, plane.Run && !npc.IsNoRun ? npc.WalkSpeed * 2 : npc.WalkSpeed);
                plane.IsMove = true;
                SavePlan(npc, plane);
            }
        } break;
        /************************************************************************/
        /* ==================================================================== */
        /* ========================   Pick   ================================== */
        /* ==================================================================== */
        /************************************************************************/
        case AI_PLANE_PICK: {
            mpos hex = plane.Pick_Hex;
            hstring pid = plane.Pick_Pid;
            ident use_item_id = plane.Pick_UseItemId;
            bool to_open = plane.Pick_ToOpen;
            bool is_run = plane.Pick_IsRun;

            Item item = map.GetItem(hex, pid);
            if (!valid(item) || (item.Type == ItemType::Door && (to_open ? item.Opened : !item.Opened))) {
                NextPlane(npc, REASON_SUCCESS);
                break;
            }

            if (use_item_id != ZERO_IDENT && !valid(npc.GetItem(use_item_id))) {
                NextPlane(npc, REASON_USE_ITEM_NOT_FOUND);
                break;
            }

            if (is_busy) {
                break;
            }

            ProtoItem proto_item = Game.GetProtoItem(pid);
            if (!valid(proto_item)) {
                NextPlane(npc, REASON_SUCCESS);
                break;
            }

            if (Game.GetDistance(npc.Hex, hex) > 1 + npc.Multihex) {
                npc.MoveToHex(hex, 1 + npc.Multihex, is_run && !npc.IsNoRun ? npc.WalkSpeed * 2 : npc.WalkSpeed);
                plane.IsMove = true;
                SavePlan(npc, plane);
            }
            else {
                npc.SetDir(Game.GetDirection(npc.Hex, hex));
                CritterActions::PickItem(npc, hex, pid);
                NextPlane(npc, REASON_SUCCESS);
                break;
            }
        } break;
        /************************************************************************/
        /* ==================================================================== */
        /* ==================================================================== */
        /* ==================================================================== */
        /************************************************************************/
        default: {
            NextPlane(npc, REASON_SUCCESS);
        } break;
        }

        //	if(map->IsTurnBasedOn && map->IsCritterTurn(npc) && !is_busy && (npc->IsNoPlanes() || !npc->GetCurPlane()->IsMove) && !npc->IsBusy() &&
        //! npc->IsWait()) map->EndCritterTurn();
    }
    return 0;
}

NpcPlane CreatePlane()
{
    return NpcPlane(0, 0);
}

dict<ident, NpcPlane[]> AllNpcPlanes = {};
int LastPlaneId = 0;

class AttackCritterTracer : LineTracer::ITraceContext
{
    Critter Target;
    bool Success;

    AttackCritterTracer(Critter target)
    {
        Target = target;
    }

    void StartExec(Map map, mpos hexFrom, mpos hexTo, int maxDist) override
    {
        Success = false;
    }

    void FinishExec(Map map, int resultDist) override
    {
        // Nothing
    }

    bool Exec(Map map, mpos hex) override
    {
        if (!map.IsHexShootable(hex)) {
            return true;
        }

        Critter cr = map.GetCritter(hex);
        if (cr != null && cr.Condition != CritterCondition::Dead) {
            Success = (cr.Id == Target.Id);
            return true;
        }

        return false;
    }
};

class NpcPlane
{
    int PlaneId;
    int Type;
    int Priority;
    any Identifier;
    any IdentifierExt;
    bool Run;
    bool IsMove;
    synctime Misc_WaitSecond;
    NpcPlaneMiscFunc Misc_Script;
    ident Attack_TargId;
    int Attack_MinHp;
    bool Attack_IsGag;
    mpos Attack_GagHex;
    mpos Attack_LastHex;
    mpos Walk_Hex;
    int Walk_Dir;
    int Walk_Cut;
    mpos Pick_Hex;
    hstring Pick_Pid;
    ident Pick_UseItemId;
    bool Pick_ToOpen;
    bool Pick_IsRun;
    // private
    NpcPlane ChildPlane;
    bool Assigned;
    int RefCounter;

    string ToString()
    {
        return "PlaneId = " + PlaneId + ";Type = " + Type + ";Priority = " + Priority + ";Identifier = " + Identifier + ";IdentifierExt = " + IdentifierExt +
               "; coords pick = " + Pick_Hex.x + ":" + Pick_Hex.y + "; coords walk x=" + Walk_Hex.x + "; y = " + Walk_Hex.y;
    }

    NpcPlane(int type, int priority)
    {
        Type = type;
        Priority = priority;
        RefCounter = 1;
        Identifier = 0;
        IdentifierExt = 0;
        ChildPlane = null;
        IsMove = false;
        Assigned = false;
        PlaneId = LastPlaneId + 1;
        LastPlaneId = PlaneId;
    }

    void AddRef()
    {
        RefCounter++;
    }

    void Misc_SetupScript(NpcPlaneMiscFunc func)
    {
        @Misc_Script = func;
    }

    NpcPlane GetCopy()
    {
        NpcPlane copy = NpcPlane(Type, Priority);
        NpcPlane result = copy;
        NpcPlane planeChild = ChildPlane;
        while (planeChild != null) {
            copy.ChildPlane = NpcPlane(planeChild.Type, planeChild.Priority);
            if (copy.ChildPlane == null) {
                return null;
            }
            copy.ChildPlane.Assigned = true;
            planeChild = planeChild.ChildPlane;
            copy = copy.ChildPlane;
        }
        return result;
    }

    NpcPlane SetChild(NpcPlane child_plane)
    {
        if (child_plane.Assigned) {
            child_plane = child_plane.GetCopy();
        }
        else {
            child_plane.AddRef();
        }

        ChildPlane = child_plane;
        return child_plane;
    }

    NpcPlane GetChild(int index)
    {
        NpcPlane result = ChildPlane;
        for (int i = 0; i < index && result != null; i++) {
            result = result.ChildPlane;
        }
        return result;
    }

    NpcPlane GetCurPlane()
    {
        return (ChildPlane == null ? this : ChildPlane.GetCurPlane());
    }
};

NpcPlane GetCritterPlane(Critter cr, int planeId)
{
    if (valid(cr)) {
        NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
        if (planes != null && !planes.isEmpty()) {
            for (int i = 0, l = planes.length(); i < l; i++) {
                if (planes[i].PlaneId == planeId) {
                    return planes[i];
                }
            }
        }
    }
    return null;
}

// Remove one or more planes from critter pool. all - remove all of the planeType, planeType = -1 => remove any type.
int ErasePlane(Critter cr, int planeType, bool all)
{
    int erased = 0;

    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes != null && !planes.isEmpty()) {
        for (int i = 0, l = planes.length(); i < l; i++) {
            NpcPlane plane = planes[i];
            if (plane != null) {
                if (plane.Type == planeType || planeType == -1) {
                    planes.remove(plane);
                    erased++;
                    if (!all) {
                        break;
                    }
                }
            }
            else {
                planes.removeAt(i);
                erased++;
            }
        }
    }
    AllNpcPlanes.set(cr.Id, planes);
    return erased;
}

bool ErasePlane(Critter cr, int index)
{
    if (!valid(cr)) {
        ThrowException("Attempt to call method on destroyed object.");
    }
    if (cr.ControlledByPlayer) {
        ThrowException("Critter is not npc.");
    }

    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes != null && !planes.isEmpty()) {
        for (int i = 0, l = planes.length(); i < l; i++) {
            if (index >= l) {
                ThrowException("Invalid index arg.");
            }
            if (i == index) {
                NpcPlane plane = planes[i];
                if (plane != null) {
                    planes.removeAt(i);
                    AllNpcPlanes.set(cr.Id, planes);
                    return true;
                }
            }
        }
    }
    return false;
}

void DropPlanes(Critter cr)
{
    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes != null && !planes.isEmpty()) {
        planes.clear();
        AllNpcPlanes.set(cr.Id, null);
    }
}

bool IsNoPlanes(Critter cr)
{
    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes == null || planes.isEmpty()) {
        return true;
    }
    return false;
}

bool IsCurPlane(Critter cr, int planeType)
{
    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes != null && !planes.isEmpty()) {
        NpcPlane plane = planes[0].GetCurPlane();
        return planeType == plane.Type;
    }
    return false;
}

// Returns first plan for the critter. Deepest child plane returned first.
NpcPlane GetCurPlane(Critter cr)
{
    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes != null && !planes.isEmpty()) {
        NpcPlane plane = planes[0];
        if (plane != null) {
            return plane.GetCurPlane();
        }
    }
    return null;
}

void SavePlan(Critter npc, NpcPlane planeS)
{
    NpcPlane[] planes = AllNpcPlanes.get(npc.Id, null);
    if (planes != null && !planes.isEmpty()) {
        NpcPlane plane = planes[0];
        if (plane != null && plane.PlaneId == planeS.PlaneId) {
            planes.removeFirst();
            planes.insertFirst(planeS);
        }
    }
}

NpcPlane[] GetPlanes(Critter cr)
{
    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes != null && !planes.isEmpty()) {
        return planes;
    }
    return null;
}

int GetPlanes(Critter cr, NpcPlane[] planes)
{
    NpcPlane[] crPlanes = GetPlanes(cr);
    if (crPlanes == null) {
        return 0;
    }
    if (valid(planes)) {
        planes = crPlanes;
    }
    return crPlanes.length();
}

NpcPlane[] GetPlanes(Critter cr, any identifier)
{
    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes != null && !planes.isEmpty()) {
        NpcPlane[] result = {};
        for (int i = 0, l = planes.length(); i < l; i++) {
            NpcPlane plane = planes[i];
            if (plane != null) {
                if (plane.Identifier == identifier) {
                    result.insertLast(plane);
                }
            }
        }
        if (result.length() > 0) {
            return result;
        }
    }
    return null;
}

int GetPlanes(Critter cr, any identifier, NpcPlane[] planes)
{
    NpcPlane[] crPlanes = GetPlanes(cr, identifier);
    if (crPlanes == null) {
        return 0;
    }
    if (valid(planes)) {
        planes = crPlanes;
    }
    return crPlanes.length();
}

NpcPlane[] GetPlanes(Critter cr, any identifier, any identifierExt)
{
    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes != null && !planes.isEmpty()) {
        NpcPlane[] result = {};
        for (int i = 0, l = planes.length(); i < l; i++) {
            NpcPlane plane = planes[i];
            if (plane != null) {
                if (plane.Identifier == identifier && plane.IdentifierExt == identifierExt) {
                    result.insertLast(plane);
                }
            }
        }
        if (result.length() > 0) {
            return result;
        }
    }
    return null;
}

int GetPlanes(Critter cr, any identifier, any identifierExt, NpcPlane[] planes)
{
    NpcPlane[] crPlanes = GetPlanes(cr, identifier, identifierExt);
    if (crPlanes == null) {
        return 0;
    }
    if (valid(planes)) {
        planes = crPlanes;
    }
    return crPlanes.length();
}

bool AddPlane(Critter cr, NpcPlane plane)
{
    return AddPlane(cr, plane, REASON_FROM_SCRIPT);
}

bool AddPlane(Critter cr, NpcPlane plane, int reason)
{
    if (valid(cr) && !cr.ControlledByPlayer) {
        NpcPlane[] planes = {};
        if (!valid(AllNpcPlanes)) {
            Game.Log("invalid AllNpcPlanes");
            return false;
        }
        if (AllNpcPlanes.exists(cr.Id)) {
            planes = AllNpcPlanes.get(cr.Id, planes);
        }
        // AllNpcPlanes.setIfNotExist( cr.Id, array< NpcPlane >() );
        if (!valid(planes)) {
            planes = array<NpcPlane>();
        }
        if (planes.length() >= MAX_PLANES_PER_CRITTER) {
            return false;
        }

        for (int i = 0, l = planes.length(); i < l; i++) {
            NpcPlane existingPlane = planes[i];
            if (valid(existingPlane)) {
                if (existingPlane.Type == plane.Type) {
                    if (plane.Type == AI_PLANE_ATTACK && plane.Attack_TargId == existingPlane.Attack_TargId) {
                        planes.removeAt(i);
                        i--;
                        l--;
                    }
                }
            }
        }
        int index = 0;

        if (planes.length() == 0) {
            planes.insertFirst(plane);
        }
        else {
            int i = 0;
            for (int l = planes.length(); i < l; i++) {
                NpcPlane p = planes[i];
                if (valid(p) && p.Priority < plane.Priority) {
                    break;
                }
            }
            planes.insertAt(i, plane);
            index = i;
        }

        // void insertAt(int, const array<T>&in)
        AllNpcPlanes.set(cr.Id, planes);

        Critter someCr = (plane.Attack_TargId == ZERO_IDENT ? null : Game.GetCritter(plane.Attack_TargId));
        Item someItem = (plane.Pick_UseItemId == ZERO_IDENT ? null : Game.GetItem(plane.Pick_UseItemId));
        if (!Game.OnNpcPlaneBegin.Fire(cr, plane.PlaneId, reason, someCr, someItem) || !cr.OnNpcPlaneBegin.Fire(plane.PlaneId, reason, someCr, someItem)) {
            ErasePlane(cr, index);
            return false;
        }
        return true;
    }
    return false;
}

void NextPlane(Critter cr, int reason)
{
    NpcPlane[] planes = AllNpcPlanes.get(cr.Id, null);
    if (planes != null && !planes.isEmpty()) {
        // Remove first plane and notify about
        NpcPlane plane = planes[0];
        if (valid(plane)) {
            if (Game.OnNpcPlaneEnd.Fire(cr, plane.PlaneId, reason, null, null)) {
                planes.removeFirst();
                if (plane.GetCurPlane().PlaneId == plane.PlaneId) {
                    //Нет дочерних планов.
                    return;
                }
                NpcPlane cur = plane;
                NpcPlane child = plane.ChildPlane;
                while (child.ChildPlane != null) {
                    cur = child;
                    child = cur.ChildPlane;
                }
                cur.ChildPlane = null;
                planes.insertFirst(plane);
            }
            else {
                // поменять приоритет
                planes.removeFirst();
                int position = 0;
                if (planes.length() > 0) {
                    for (int l = planes.length(); position < l; position++) {
                        if (plane.Priority > planes[position].Priority) {
                            break;
                        }
                    }
                }
                planes.insertAt(position, plane);
            }
        }
    }
}

bool AddMiscPlane(Critter npc, int priority, timespan wait, NpcPlaneMiscFunc func)
{
    return AddMiscPlane(npc, priority, Game.SynchronizedTime + wait, func);
}

bool AddMiscPlane(Critter npc, int priority, synctime waitSecond, NpcPlaneMiscFunc func)
{
    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_MISC;
    plane.Priority = (priority == 0 ? AI_PLANE_MISC_PRIORITY : priority);
    plane.Misc_WaitSecond = waitSecond;
    if (func !is null) {
        plane.Misc_SetupScript(func);
    }
    return AddPlane(npc, plane);
}

bool AddWalkPlane(Critter npc, hstring entry, int cut, bool run)
{
    mpos hex;
    Map map = npc.GetMap();
    if (map !is null && Entrance::MapGetEntryCoords(map, entry, 0, hex)) {
        return AddWalkPlane(npc, 0, hex, 6, run, cut);
    }
    return false;
}

bool AddWalkPlane(Critter npc, int entry, int cut, bool run)
{
    return AddWalkPlane(npc, hstring("" + entry), cut, run);
}

bool AddWalkPlane(Critter npc, int priority, mpos hex, uint8 dir, bool run, int cut)
{
    if (npc.IsNoMove) {
        return false;
    }

    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_WALK;
    plane.Priority = (priority == 0 ? AI_PLANE_WALK_PRIORITY : priority);
    plane.Walk_Hex = hex;
    plane.Walk_Dir = dir;
    plane.Run = run;
    plane.Walk_Cut = cut;
    return AddPlane(npc, plane);
}

bool AddWalkPlane(Critter npc, int priority, any identifier, any identifierExt, mpos hex, uint8 dir, bool run, int cut)
{
    return AddWalkPlane(npc, priority, identifier, identifierExt, hex, dir, run, REASON_FROM_SCRIPT);
}

bool AddWalkPlane(Critter npc, int priority, any identifier, any identifierExt, mpos hex, uint8 dir, bool run, int cut, int reason)
{
    if (npc.IsNoMove) {
        return false;
    }

    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_WALK;
    plane.Priority = (priority == 0 ? AI_PLANE_WALK_PRIORITY : priority);
    plane.Identifier = identifier;
    plane.IdentifierExt = identifierExt;
    plane.Walk_Hex = hex;
    plane.Walk_Dir = dir;
    plane.Run = run;
    plane.Walk_Cut = cut;
    return AddPlane(npc, plane, reason);
}

bool AddAttackPlane(Critter npc, int priority, Critter target)
{
    return AddAttackPlane(npc, priority, REASON_FROM_SCRIPT, target);
}

bool AddAttackPlane(Critter npc, int priority, int reason, Critter target)
{
    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_ATTACK;
    plane.Priority = (priority == 0 ? AI_PLANE_ATTACK_PRIORITY : priority);
    plane.Attack_TargId = target.Id;
    plane.Attack_MinHp = Settings.DeadHitPoints;
    plane.Attack_IsGag = false;
    plane.Attack_GagHex = mpos();
    plane.Attack_LastHex = mpos();
    plane.Run = false;
    return AddPlane(npc, plane, reason);
}

bool AddAttackPlane(Critter npc, int priority, ident critId)
{
    Critter target = Game.GetCritter(critId);
    if (target is null) {
        Game.Log("Target not found.");
        return false;
    }

    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_ATTACK;
    plane.Priority = (priority == 0 ? AI_PLANE_ATTACK_PRIORITY : priority);
    plane.Attack_TargId = target.Id;
    plane.Attack_MinHp = Settings.DeadHitPoints;
    plane.Attack_IsGag = false;
    plane.Attack_GagHex = mpos();
    plane.Attack_LastHex = mpos();
    plane.Run = false;
    return AddPlane(npc, plane);
}

bool AddAttackPlane(Critter npc, int priority, Critter target, int minHp)
{
    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_ATTACK;
    plane.Priority = (priority == 0 ? AI_PLANE_ATTACK_PRIORITY : priority);
    plane.Attack_TargId = target.Id;
    plane.Attack_MinHp = minHp;
    plane.Attack_IsGag = false;
    plane.Attack_GagHex = mpos();
    plane.Attack_LastHex = target.Hex;
    plane.Run = false;
    return AddPlane(npc, plane);
}

bool AddAttackPlane(Critter npc, int priority, ident critId, int minHp)
{
    Critter target = Game.GetCritter(critId);
    if (target is null) {
        Game.Log("Target not found.");
        return false;
    }

    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_ATTACK;
    plane.Priority = (priority == 0 ? AI_PLANE_ATTACK_PRIORITY : priority);
    plane.Attack_TargId = target.Id;
    plane.Attack_MinHp = minHp;
    plane.Attack_IsGag = false;
    plane.Attack_GagHex = mpos();
    plane.Attack_LastHex = mpos();
    plane.Run = false;
    return AddPlane(npc, plane);
}

bool AddAttackPlane(Critter npc, int priority, Critter target, bool run)
{
    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_ATTACK;
    plane.Priority = (priority == 0 ? AI_PLANE_ATTACK_PRIORITY : priority);
    plane.Attack_TargId = target.Id;
    plane.Attack_MinHp = Settings.DeadHitPoints;
    plane.Attack_IsGag = false;
    plane.Attack_GagHex = mpos();
    plane.Attack_LastHex = mpos();
    plane.Run = run;
    return AddPlane(npc, plane);
}

bool AddAttackPlane(Critter npc, int priority, ident critId, bool run)
{
    Critter target = Game.GetCritter(critId);
    if (target is null) {
        Game.Log("Target not found.");
        return false;
    }

    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_ATTACK;
    plane.Priority = (priority == 0 ? AI_PLANE_ATTACK_PRIORITY : priority);
    plane.Attack_TargId = target.Id;
    plane.Attack_MinHp = Settings.DeadHitPoints;
    plane.Attack_IsGag = false;
    plane.Attack_GagHex = mpos();
    plane.Attack_LastHex = mpos();
    plane.Run = run;
    return AddPlane(npc, plane);
}

bool AddAttackPlane(Critter npc, int priority, Critter target, int minHp, bool run)
{
    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_ATTACK;
    plane.Priority = (priority == 0 ? AI_PLANE_ATTACK_PRIORITY : priority);
    plane.Attack_TargId = target.Id;
    plane.Attack_MinHp = minHp;
    plane.Attack_IsGag = false;
    plane.Attack_GagHex = mpos();
    plane.Attack_LastHex = mpos();
    plane.Run = run;
    return AddPlane(npc, plane);
}

bool AddAttackPlane(Critter npc, int priority, ident critId, int minHp, bool run)
{
    Critter target = Game.GetCritter(critId);
    if (target is null) {
        Game.Log("Target not found.");
        return false;
    }

    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_ATTACK;
    plane.Priority = (priority == 0 ? AI_PLANE_ATTACK_PRIORITY : priority);
    plane.Attack_TargId = target.Id;
    plane.Attack_MinHp = minHp;
    plane.Attack_IsGag = false;
    plane.Attack_GagHex = mpos();
    plane.Attack_LastHex = mpos();
    plane.Run = run;
    return AddPlane(npc, plane);
}

bool AddPickPlane(Critter npc, int priority, mpos hex, hstring protoId, ident useItemId, bool toOpen)
{
    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_PICK;
    plane.Priority = (priority == 0 ? AI_PLANE_PICK_PRIORITY : priority);
    plane.Pick_Hex = hex;
    plane.Pick_Pid = protoId;
    plane.Pick_UseItemId = useItemId;
    plane.Pick_ToOpen = toOpen;
    plane.Run = false;
    return AddPlane(npc, plane);
}

bool AddPickPlane(Critter npc, int priority, Item item, ident useItemId, bool toOpen)
{
    NpcPlane plane = CreatePlane();
    plane.Type = AI_PLANE_PICK;
    plane.Priority = (priority == 0 ? AI_PLANE_PICK_PRIORITY : priority);
    plane.Pick_Hex = item.Hex;
    plane.Pick_Pid = item.ProtoId;
    plane.Pick_UseItemId = useItemId;
    plane.Pick_ToOpen = toOpen;
    plane.Run = false;
    return AddPlane(npc, plane);
}

int EraseAttackPlane(Critter npc, Critter target)
{
    return EraseAttackPlane(npc, target.Id);
}

int EraseAttackPlane(Critter npc, ident critId)
{
    NpcPlane[] planes = GetPlanes(npc);

    int erased = 0;
    if (planes != null) {
        for (int i = 0; i < planes.length(); i++) {
            if (planes[i].Attack_TargId == critId && ErasePlane(npc, i - erased)) {
                erased++;
            }
        }
    }

    return erased;
}

#endif

}
