// FOS Server Sort 2
// Author: rifleman17
// Квест "Проблемы мистера Райта: Заложник."

///@ Property Critter Protected     uint8 NRWriKidnap     Group = Quests Quest = 3707 Max = 12
///@ Property Critter Protected     uint8 NRSalvatoreKill Group = Quests Quest = 3710 Max = 3
///@ Property Critter PrivateServer int   NRWriKidnapNotifyTime
///@ Property Critter PrivateServer int   NRKidnapKillsCounter
///@ Property Critter PrivateServer uint  QNrWriKidnapInvokeId
///@ Property Location PrivateServer bool LocDefendersHostile
///@ Property Location PrivateServer uint NRWriGuardDead
///@ Property Location PrivateServer bool NRKidnapAllMarodeursDead

#define NEXT_KIDNAP_TIME (60 * 60 * 24 * 30 * Random(1, 3))
#define KIDNAP_LOC_PROTO (Content::Location::kidnappers_hideout)
#define KINDAP_GLOBAL_X  (Random(1229, 1359))
#define KINDAP_GLOBAL_Y  (Random(847, 942))

// Статусы квеста
#define Q_QUEST_TAKEN          (1) // Взят квест
#define Q_PAY_RAMIREZ          (2) // Игрок заплатил за освобождение Райта

#define ENT_DEADZONE_1         (100) // Начало мертвой зоны
#define ENT_DEADZONE_2         (112) // конец мертвой зоны

#define NPC_ROLE_MARODEUR      (1) // Роль НПЦ - рядовой бандит
#define NPC_ROLE_GUARD         (2) // Охранник пленного Райта
#define NPC_ROLE_WRIGHT        (3)

#define CTE_ATTACK             (17)

#define RADIUS_SEARCH_MARODEUR (15) // Радиус в гексах, в котором нужно искать мародера, который начнет диалог с игроком

#define STR_MAP_IN_HOSTILE     (3350) // Вы на месте. Бандиты настороже и с оружием в руках. Мирным путем договориться не получится.
#define STR_MAP_IN_SNEAK_OK \
    (3351) // Вы на месте. Бандиты выглядят достаточно беспечно. Палатку с сыном Райта охраняет один часовой. Если убрать часового без лишнего шума, вы получите
           // шанс решить все проблемы по-тихому.
#define STR_MAP_IN_LOWSNEAK \
    (3352) // Вы на месте. Бандиты выглядят достаточно беспечно. Главарь банды - в центре лагеря. Возможно, у вас получится заплатить выкуп и обойтись без
           // кровопролития.
#define STR_MARODEUR_ATTACK (1) // Строка из диалога мародера, которую он произносит при атаке в специальных случаях.
#define STR_GUARD_SHOUT     (3353) // На помощь!Все сюда, Райт может сбежать!Подкрепление! Подкрепление!

// #define DL #(s) (Log("kidnap: " + s))
#define DL #(s)

// ************************ Выдача квеста. *****************************************************************

uint KidnapLocationId = 0;

void _OliverInit(Critter cr, bool firstTime)
{
    if (cr.QNrWriKidnapInvokeId == 0)
        cr.QNrWriKidnapInvokeId = SavedDeferredCall(GAME_SECOND_TO_TICK(NEXT_KIDNAP_TIME), Kidnap, cr.Id);
    // __EventCritterFinish.SubscribeToCritter( cr, _OliverFinish );
}

void Kidnap(uint value)
{
    Critter cr = GetCritter(value);
    if (cr is null)
        return;

    if (!KidnapLocationExist()) {
        uint locId = CreateLocation(KIDNAP_LOC_PROTO, KINDAP_GLOBAL_X, KINDAP_GLOBAL_Y, null).Id;
        if (locId > 0) {
            KidnapLocationId = locId;
            DL("Location:" + locId);
        }
    }

    cr.QNrWriKidnapInvokeId = SavedDeferredCall(GAME_SECOND_TO_TICK(NEXT_KIDNAP_TIME), Kidnap, value);
}

bool KidnapLocationExist()
{
    if (KidnapLocationId == 0)
        return false;
    Location loc = GetLocation(KidnapLocationId);
    return valid(loc);
}

bool d_QuestActive(Critter player, Critter npc)
{
    return KidnapLocationExist();
}

bool d_NotQuestActive(Critter player, Critter npc)
{
    return !KidnapLocationExist();
}

void r_ShowLocation(Critter player, Critter npc)
{
    Location loc = GetLocation(KidnapLocationId);
    if (valid(loc)) {
        if (!Location::IsKnownLoc(player, true, loc.Id))
            Location::SetKnownLoc(player, true, loc.Id);
    }
}

// ************************ Скрипт карты. ******************************************************************
void _MapInit(Map map, bool firstTime)
{
    DL("Map init");
    Location loc = map.GetLocation();
    KidnapLocationId = loc.Id;
    __EventMapLoop1.SubscribeToMap(map, _MapLoop0);
    __EventMapCritterIn.SubscribeToMap(map, _MapInCritter);
    __EventMapCritterDead.SubscribeToMap(map, _MapCritterDead);

    __EventMapCritterOutEx.SubscribeToMap(map, _MapOutCritter);
    map.LoopTime1 = 6000;
}

void _MapInCritter(Map map, Critter cr)
{
    DL("Map in critter");
    Location loc = map.GetLocation();
    if (!valid(loc))
        return;

    if (cr.NRWriKidnap == Q_QUEST_TAKEN) {
        if (loc.LocDefendersHostile) {
            cr.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_MAP_IN_HOSTILE);
            return;
        }

        if (cr.SkillSneak > 50)
            cr.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_MAP_IN_SNEAK_OK);
        else
            cr.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_MAP_IN_LOWSNEAK);
    }
}

void _MapOutCritter(Map map, Critter cr)
{
    UpdateQuestStatus(map, cr);
    Location loc = map.GetLocation();
    if (valid(loc))
        ResetHostileIfNoPlayers(loc);
}

void ResetHostileIfNoPlayers(Location loc)
{
    if (not loc.LocDefendersHostile)
        return;

    Critter[] players = {};
    for (uint i = 0; i < loc.GetMapCount(); i++) {
        Map map = loc.GetMapByIndex(i);
        if (valid(map))
            Obsolete::GetCritters(map, 0, FIND_ALL | FIND_ONLY_PLAYERS, players);
    }

    if (players.length() == 0) {
        loc.LocDefendersHostile = false;

        // Если убит охранник, возрождаем его
        if (loc.NRWriGuardDead > 0) {
            Critter cr = GetCritter(loc.NRWriGuardDead);
            if (valid(cr) && cr.IsNpc() && cr.IsDead()) {
                loc.NRWriGuardDead = 0;
                CritterState::ToLife(cr);
            }
        }
    }
}

// ************************ На карте кто-то убит. **********************************************************
void _MapCritterDead(Map map, Critter cr, Critter killer)
{
    Location loc = map.GetLocation();
    if (valid(loc))
        ResetHostileIfNoPlayers(loc);
    UpdateQuestStatus(map, null);
}

// ************************ Атака рейдеров. ****************************************************************
// Признак: нпц на карте враждебны
bool IsHostile(Map map)
{
    Location loc = map.GetLocation();
    if (not valid(loc))
        return false;

    return loc.LocDefendersHostile;
}

void SetHostile(Location loc, bool hostileOn)
{
    if (valid(loc))
        loc.LocDefendersHostile = hostileOn;
}

void AcceptAttack(Map map)
{
    DL("accept attack");
    if (!IsHostile(map))
        SetHostile(map.GetLocation(), true);
    uint marodeurs = map.GetNpcCount(NPC_ROLE_MARODEUR, FIND_LIFE | FIND_ONLY_NPC);
    Critter marodeur;
    Critter[] players = {};
    Critter player;
    Obsolete::GetCritters(map, 0, FIND_LIFE_AND_KO | FIND_ONLY_PLAYERS, players);
    for (uint i = 0; i < marodeurs; i++) {
        DL("marodeurs" + marodeurs);
        marodeur = map.GetNpc(NPC_ROLE_MARODEUR, FIND_LIFE | FIND_ONLY_NPC, i);
        if (valid(marodeur)) {
            for (uint j = 0, l = players.length(); j < l; j++) {
                player = players[j];
                if (valid(player)) {
                    DL("target found");
                    EnemyStack::AddEnemyToStack(marodeur, player.Id);
                    if (GetCrittersDistantion(marodeur, player) < 15) {
                        NpcPlanes::AddAttackPlane(marodeur, 0, player);
                    }
                }
            }
        }
    }
}

void r_Attack(Critter cr, Critter npc)
{
    AcceptAttack(cr.GetMap());
}

void dlg_Attack(Critter cr, Critter npc, string lexems)
{
    AcceptAttack(cr.GetMap());
}

// ************************ Игрок в мертвой зоне. **********************************************************
// Мертвая зона. Если игрок в мертвой зоне, рейдеры будут обращаться к нему с вопросами "кто такой", с возможностью атаки
void _MapLoop0(Map map)
{
    if (IsHostile(map))
        return;
    Critter[] players = {};
    Critter[] marodeurs = {};
    Critter player;
    Critter npc;
    if (Obsolete::GetCritters(map, 0, FIND_LIFE | FIND_ONLY_PLAYERS, players) > 0) {
        for (uint i = 0, l = players.length(); i < l; i++) {
            player = players[i];
            if (!valid(player))
                return;
            marodeurs.clear();
            if (Obsolete::GetCrittersHex(map, player.HexX, player.HexY, RADIUS_SEARCH_MARODEUR, FIND_LIFE | FIND_ONLY_NPC, marodeurs) > 0) {
                npc = marodeurs[0];
                if (valid(npc) && npc.NpcRole == NPC_ROLE_MARODEUR) {
                    TryMarodeurDialog(player, npc, map);
                }
            }
        }
    }
}

void TryMarodeurDialog(Critter player, Critter marodeur, Map map)
{
    if (marodeur.GetTalkedPlayers().length() > 0)
        return;                                                                      // НПЦ уже говорит с кем-то
    if (player.NRWriKidnapNotifyTime + __TimeMultiplier * 20 > int(GetFullSecond())) // запросы к игрокам не реже раз в 20 сек
        return;
    player.Wait(0);
    Critter cr;
    Critter[] players = {};
    // проверка, что с игроком еще никто не разговаривает
    uint npcCount = map.GetNpcCount(NPC_ROLE_MARODEUR, FIND_LIFE | FIND_ONLY_NPC);
    if (npcCount > 0) {
        for (uint i = 0; i < npcCount; i++) {
            cr = map.GetNpc(NPC_ROLE_MARODEUR, FIND_LIFE | FIND_ONLY_NPC, i);
            if (valid(cr))
                players = cr.GetTalkedPlayers(); // собираем всех говорящих игроков с нпц
        }
    }
    for (uint i = 0, l = players.length(); i < l; i++) {
        cr = players[i];
        if (valid(cr) && cr.Id == player.Id) // С этим игроком кто-то уже заговорил
            return;
    }
    // Все проверки пройдены, с игроком никто не говорит, время разрешения находиться на локации прошло. Запускаем еще один диалог
    player.NRWriKidnapNotifyTime = GetFullSecond();
    RunDialog(player, marodeur, true);
}

// ************************ Мародеры. **********************************************************************
void _HostileInit(Critter cr, bool firstTime)
{
    __EventCritterAttack.SubscribeToCritter(cr, _HostileAttack);
    __EventCritterDead.SubscribeToCritter(cr, _HostileDead);
    cr.SkillSmallGuns = 250;
    cr.MaxLifeBase = Random(400, 600);
    cr.ActionPointsBase = Random(8, 12);
    cr.CurrentHp = cr.MaxLife;
    cr.PerkBetterCriticals = 1;
    cr.PerkSniper = 1;
}

bool _HostileAttack(Critter cr, Critter target, Item weapon, uint8 weaponMode, const Item ammo)
{
    if (target.IsPlayer() && !target.IsDead() && !IsHostile(cr.GetMap())) {
        if (Random(1, 2) == 1) {
            AcceptAttack(cr.GetMap());
            cr.SayMsg(SAY_SHOUT, TEXTMSG_TEXT, STR_GUARD_SHOUT);
        }
    }
    return false;
}

void _HostileDead(Critter cr, Critter killer)
{
    if (valid(killer) && killer.IsPlayer())
        killer.NRKidnapKillsCounter += 1;
}

// ************************ Охранник пленного Райта. *******************************************************
void _GuardInit(Critter cr, bool firstTime)
{
    __EventCritterDead.SubscribeToCritter(cr, _GuardDead);
    __EventCritterAttacked.SubscribeToCritter(cr, _GuardAttacked);
    __EventCritterRespawn.SubscribeToCritter(cr, _GuardRespawn);
}

void _GuardDead(Critter cr, Critter killer)
{
    Map map = cr.GetMap();
    if (not valid(map))
        return;

    Location loc = map.GetLocation();
    if (not valid(loc))
        return;

    loc.NRWriGuardDead = cr.Id;
    if (valid(killer) && !IsHostile(map))
        if (killer.NRWriKidnap == 1 || killer.NRWriKidnap == 2)
            killer.NRWriKidnap = 3;
}

void _GuardRespawn(Critter cr)
{
    Map map = cr.GetMap();
    if (not valid(map))
        return;

    Location loc = map.GetLocation();
    if (not valid(loc))
        return;

    if (loc.NRWriGuardDead == cr.Id)
        loc.NRWriGuardDead = 0;
}

bool _GuardAttacked(Critter cr, Critter attacker)
{
    Item wpn = _CritGetItemHand(attacker);
    if (valid(wpn) && wpn.Type == ItemType::Weapon && wpn.Weapon_Skill_1 != CritterProperty::SkillUnarmed &&
        wpn.Weapon_Skill_1 != CritterProperty::SkillMeleeWeapons) {
        // Атака не холодным оружием, остальные должны прибежать
        if (!IsHostile(cr.GetMap())) {
            SetHostile(cr.GetMap().GetLocation(), true);
            cr.SayMsg(SAY_SHOUT, TEXTMSG_TEXT, STR_GUARD_SHOUT);
        }
    }
    return false;
}

void t_Alarm(Critter player, const Item trigger, bool entered, uint8 dir)
{
    Map map = player.GetMap();
    Critter guard = map.GetNpc(NPC_ROLE_GUARD, FIND_ALL | FIND_ONLY_NPC, 0);
    if (!valid(guard) || guard.IsDead() || !entered || IsHostile(player.GetMap()))
        return;
    if (player.IsPlayer()) {
        if (player.NRWriKidnap != 2 && player.NRWriKidnap != 4) {
            NpcPlanes::AddAttackPlane(guard, 0, player);
            guard.SayMsg(SAY_SHOUT, TEXTMSG_TEXT, STR_GUARD_SHOUT);
            SetHostile(guard.GetMap().GetLocation(), true);
            Critter npc = map.GetNpc(NPC_ROLE_MARODEUR, FIND_LIFE | FIND_ONLY_NPC, 0);
            if (valid(npc))
                NpcPlanes::AddAttackPlane(npc, 0, player);
        }
    }
}
// Триггер, наступая на который игрок должен быть в снике и подходить ровно со спины
void t_CheckSneak(Critter player, const Item trigger, bool entered, uint8 dir)
{
    Map map = player.GetMap();
    Critter guard = map.GetNpc(NPC_ROLE_GUARD, FIND_ALL | FIND_ONLY_NPC, 0);
    if (!player.IsPlayer() || !valid(guard) || guard.IsDead() || !entered || IsHostile(player.GetMap()))
        return;

    uint8 questVar = player.NRWriKidnap;
    if (questVar == 2) {
        player.Wait(0);
        RunDialog(player, guard, true);
        return;
    }
    if (questVar == 1) {
        if (player.IsHide && (player.Dir == 2 || player.Dir == 3)) {
            guard.SayMsg(SAY_NORM, TEXTMSG_TEXT, 3354);
            return;
        }
    }
    if (questVar == 4)
        return;

    NpcPlanes::AddAttackPlane(guard, 0, player);
    guard.SayMsg(SAY_SHOUT, TEXTMSG_TEXT, STR_GUARD_SHOUT);
    SetHostile(guard.GetMap().GetLocation(), true);
    Critter npc = map.GetNpc(NPC_ROLE_MARODEUR, FIND_LIFE | FIND_ONLY_NPC, 0);
    if (valid(npc)) {
        NpcPlanes::AddAttackPlane(npc, 0, player);
    }
}

// Сын райта
void _WrightInit(Critter cr, bool firstTime)
{
    __EventCritterDead.SubscribeToCritter(cr, _WrightDead);
    cr.ReplicationTime = -1;
}

void _WrightDead(Critter cr, Critter killer)
{
    // Удаляем локацию, переключаем доступность переменной
    UpdateQuestStatus(cr.GetMap(), null);
    if (valid(killer) && killer.NRSalvatoreKill == 1)
        killer.NRSalvatoreKill = 2;
}

// Диалог с сыном райта
bool d_WeaponHand(Critter player, Critter npc)
{
    Item item = _CritGetItemHand(player);
    if (valid(item) && item.Type == ItemType::Weapon)
        return true;
    return false;
}

void dlg_WeaponHand(Critter player, Critter npc, string lexems)
{
    Item item = _CritGetItemHand(player);
    if (valid(item) && item.Type == ItemType::Weapon)
        lexems = "$weaponName@msg ITEM" + item.ProtoId * 100 + "@";
}

void r_GiveWeaponHand(Critter player, Critter npc)
{
    Item item = _CritGetItemHand(player);
    if (valid(item) && item.Type == ItemType::Weapon) {
        npc.AddItem(item.ProtoId, 1);
        FavoriteItem::SetFavoriteItemPid(npc, SLOT_HAND1, item.ProtoId);
        DeleteItem(item);
    }
}

// Озверевший Райт
void r_Fight(Critter player, Critter npc)
{
    if (valid(npc)) {
        npc.AddTimeEvent(cte_WrightAttack, REAL_SECOND(3), CTE_ATTACK);
        npc.IsUnlimitedAmmo = true;
    }
}

void r_WrightMerc(Critter player, Critter npc)
{
    if (!valid(npc))
        return;
    Merc::Merc2Player(player, npc);
    npc.MercAlwaysRun = true;
    npc.MercLoseDist = 0;
    npc.MercMasterDist = 2;
}

void _WrightInitMerc(Critter cr, bool firstTime)
{
    Merc::_MercInit(cr, firstTime);

    __EventGlobalMapProcess.SubscribeToCritter(cr, _WrightGlobalProcess);
}

bool _WrightGlobalProcess(int, Critter cr, Item, float, float, float, float, float, uint, bool)
{
    cr.SayMsg(SAY_NORM, TEXTMSG_DLG, DLGSTR(cr.DialogId, 1));
    DeleteNpc(cr);
    return false;
}

void UpdateQuestStatus(Map map, Critter cr)
{
    if (!valid(map))
        return;

    bool wrightAlive = (map.GetNpcCount(NPC_ROLE_WRIGHT, FIND_LIFE | FIND_ONLY_NPC) > 0);
    bool wrightDead = (map.GetNpcCount(NPC_ROLE_WRIGHT, FIND_DEAD | FIND_ONLY_NPC) > 0);
    bool marodeursAlive = (map.GetNpcCount(NPC_ROLE_MARODEUR, FIND_LIFE | FIND_ONLY_NPC) > 0);
    int status = 0;
    if (!wrightAlive && !wrightDead && marodeursAlive)
        status = 5;
    if (wrightAlive && !marodeursAlive)
        status = 6;
    if (!wrightAlive && !wrightDead && !marodeursAlive)
        status = 6;
    if (wrightDead && marodeursAlive)
        status = 7;
    if (wrightDead && !marodeursAlive)
        status = 8;

    Critter[] players = {};
    if (valid(cr))
        players.insertLast(cr);

    if (Obsolete::GetCritters(map, 0, FIND_ALL | FIND_ONLY_PLAYERS, players) > 0) {
        for (uint i = 0, l = players.length(); i < l; i++) {
            Critter player = players[i];
            if (player.NRWriKidnap != 0 && player.NRWriKidnap != 11)
                player.NRWriKidnap = status;
        }
    }

    if (wrightDead || !marodeursAlive || (!wrightDead && !wrightAlive))
        SavedDeferredCall(HOUR_TICKS(1), DeleteQuestLocation, map.Id);

    if (!marodeursAlive) {
        Location loc = map.GetLocation();
        if (valid(loc))
            loc.NRKidnapAllMarodeursDead;
    }
}

void DeleteQuestLocation(uint value)
{
    Map map = GetMap(value);
    if (valid(map)) {
        Location loc = map.GetLocation();
        if (valid(loc))
            loc.AutoGarbage = true;
    }
}

uint cte_WrightAttack(Critter cr, int identifier, uint& stage)
{
    Map map = cr.GetMap();
    AcceptAttack(map);
    uint marodeurs = map.GetNpcCount(NPC_ROLE_MARODEUR, FIND_LIFE | FIND_ONLY_NPC);
    Critter marodeur;
    for (uint i = 0, l = marodeurs; i < marodeurs; i++) {
        marodeur = map.GetNpc(NPC_ROLE_MARODEUR, FIND_LIFE | FIND_ONLY_NPC, i);
        if (valid(marodeur)) {
            EnemyStack::AddEnemyToStack(marodeur, cr.Id);
            EnemyStack::AddEnemyToStack(cr, marodeur.Id);
            NpcPlanes::AddAttackPlane(cr, 0, marodeur);
        }
    }
    return 0;
}
