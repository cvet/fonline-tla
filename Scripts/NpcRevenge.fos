namespace NpcRevenge
{

#if SERVER

// Author: rifleman17
// Скрипт для НПЦ-жителей города, не защищенных баунтихантерами
// Периодически, после того, как местные слишком часто умирали, НПЦ будут собираться вместе и принимать решение атаковать всех посетителей города.

///@ Property Critter PrivateServer mpos NpcRevengeNpcHex
///@ Property Critter PrivateServer int32 NpcRevengeCountWait

///@ Property Map PrivateServer uint8[] NpcRevengeData

#define MODE_NORMAL       (0) // Обычный режим
#define MODE_LEADER_CALLS (1) // Лидер призывает игроков
#define MODE_MEETING      (2) // Идет митинг
#define MODE_HOSTILE      (3) // Враждебный режим, все нпц атакуют любых игроков

#define MAX_LEADER_CALLS  (4)  // Максимальное число призывов лидера
#define MAX_DEADS_BASE    (1)  // Максимальное число убитых нпц по умолчанию
#define LEADER_RADIUS     (10) // Радиус области возле лидера. куда пойдут нпц

#define PLANE_MOVE2LEADER (24) // План на перемещение к лидеру в момент MODE_LEADER_CALLS
#define PLANE_WAITMEETING (25) // План на ожидание завершения лекции
#define CTE_CHECK_GAG     (26) // Идентификатор события поиска преград при движении.

#define DL                #(s)(Game.Log("NpcRevenge: " + s))
// #define DL #(s)

bool Map2Revenge(Map map, int leaderRole, TextPackName textMsg, int strCall, int strCallAns, int strFirst, int strLast, int strAns, int strKill, int strEnter)
{
    RevengeMapInfo rm = RevengeMapInfo(map.Id, leaderRole, textMsg, strCall, strCallAns, strFirst, strLast, strAns, strKill, strEnter);
    if (valid(rm)) {
        rm.Save();
        return true;
    }

    return false;
}

RevengeMapInfo RevengeFromMap(Map map)
{
    if (!valid(map)) {
        return null;
    }

    RevengeMapInfo rm = RevengeMapInfo(map);
    if (valid(rm) && rm.Exists()) {
        rm.Load();
        return rm;
    }

    return null;
}

int GetRevengeMode(Map map)
{
    RevengeMapInfo rm = RevengeFromMap(map);
    if (!valid(rm)) {
        return -1;
    }

    return rm.MapMode;
}

class RevengeMapInfo
{
    ident MapId;          // Карта, на которой происходят все события
    int DeadNpcToRevenge; // Максимальное число убитых на карте НПЦ, после которого местные становястя агрессивны по отношению к игроку.
    int DeadsCounter;     // Текущее число убитых на карте НПЦ.
    int MapMode;    // Режимы карты: обычный, идет сбор нпц вокруг лидера, идет митинг, враждебный
    int LeaderRole; // Номер роли нпц-лидера, который призывает всех местных жителей.
    // Текстовые реплики
    TextPackName TextMsg; // Номер текстового файла, в котором лежат реплики лидера.
    int StrCall;          // Номер строки, в которой лидер призывает местных.
    int StrCallAnswer;    // Ответы НПЦ на призывы лидера.
    int LeaderCalls;      // Счетчик призывов лидера.
    synctime LastActionTime; // Время последнего действия, совершенного лидером, например, произнесенной фразы

    int StrMeetingFirst;  // Первая фраза из монолога лидера во время митинга
    int StrMeetingLast;   // Последняя фраза из монолога лидера во время митинга
    int StrMeetingCur;    // Текущая активная фраза из монолога лидера
    int StrMeetingAnswer; // Строка ответа НПЦ на реплики лидера во время митинга

    int StrHostileKill;  // Строка, которую произносит НПЦ, убивший игрока во враждебном режиме.
    int StrHostileEnter; // Строка, которую произносят НПЦ при входе игрока в локацию

    RevengeMapInfo(Map map)
    {
        MapId = map.Id;
    }

    RevengeMapInfo(ident mapId, int leaderRole, TextPackName textMsg, int strCall, int strCallAns, int strFirst, int strLast, int strAns, int strKill,
                   int strEnter)
    {
        MapId = mapId;
        DeadNpcToRevenge = MAX_DEADS_BASE;
        DeadsCounter = 0;
        MapMode = MODE_NORMAL;
        LeaderRole = leaderRole;
        TextMsg = textMsg;
        StrCall = strCall;
        StrCallAnswer = strCallAns;
        LeaderCalls = 0;
        StrMeetingFirst = strFirst;
        StrMeetingLast = strLast;
        StrMeetingCur = 0;
        StrMeetingAnswer = strAns;
        StrHostileKill = strKill;
        StrHostileEnter = strEnter;
    }

    void SetMode(int mode)
    {
        switch (mode) {
        case MODE_NORMAL:
            if (MapMode != MODE_NORMAL) {
                DeadNpcToRevenge += 10;
            }
            break;
        case MODE_LEADER_CALLS:
            LeaderCalls = 0;
            LastActionTime = ZERO_SYNCTIME;
            break;
        case MODE_MEETING:
            LastActionTime = ZERO_SYNCTIME;
            StrMeetingCur = 0;
            break;
        case MODE_HOSTILE:
            LastActionTime = Game.SynchronizedTime; // Используем для последующих проверок, все ли НПЦ добрались домой
            break;
        default:
            break;
        }

        MapMode = mode;
        Save();
        SetEvents();
    }

    void SetEvents()
    {
        Map map = Game.GetMap(MapId);
        if (!valid(map)) {
            return;
        }

        map.OnCritterDead.Subscribe(_MapCritterDead);

        switch (MapMode) {
        case MODE_NORMAL:
            map.OnCritterIn.Unsubscribe(_MapInCritter);
            break;
        case MODE_LEADER_CALLS:
            map.StartTimeEvent(Time::Milliseconds(0), Time::Milliseconds(15000), _MapLoop_LeaderCalls);
            // Раз в 15 секунд
            break;
        case MODE_MEETING:
            map.StartTimeEvent(Time::Milliseconds(0), Time::Milliseconds(10000), _MapLoop_Meeting);
            // Раз в 10 секунд
            break;
        case MODE_HOSTILE:
            CancelPlanes(map);
            map.StartTimeEvent(Time::Milliseconds(0), Time::Milliseconds(60000), _MapLoop_CheckGag);
            // Раз в 60 секунд
            map.OnCritterIn.Subscribe(_MapInCritter);
            break;
        default:
            break;
        }
    }

    void CancelPlanes(Map map)
    {
        DL("cancel called");
        Critter[] critters = {};
        Critter cr;
        critters = map.GetCritters(CritterFindType::Npc);
        for (int i = 0; i < critters.length(); i++) {
            cr = critters[i];
            if (valid(cr)) {
                NpcPlanes::NpcPlane[] planes = {};
                NpcPlanes::GetPlanes(cr, AI_PLANE_WALK, planes);
                int erased = 0;
                for (int j = 0, len = planes.length(); j < len; j++) {
                    if (planes[j].Identifier == PLANE_MOVE2LEADER) {
                        if (NpcPlanes::ErasePlane(cr, j - erased)) {
                            erased++;
                        }
                    }
                }
            }
        }
    }

    // Serializator::Serializator
    void Save()
    {
        auto save = Serializator::Serializator();
        save.Set(MapId);
        save.Set(DeadNpcToRevenge);
        save.Set(DeadsCounter);
        save.Set(MapMode);
        save.Set(LeaderRole);
        save.Set(TextMsg);
        save.Set(StrCall);
        save.Set(StrCallAnswer);
        save.Set(LeaderCalls);
        save.Set(LastActionTime);
        save.Set(StrMeetingFirst);
        save.Set(StrMeetingLast);
        save.Set(StrMeetingCur);
        save.Set(StrMeetingAnswer);
        save.Set(StrHostileKill);
        save.Set(StrHostileEnter);
        Game.GetMap(MapId).NpcRevengeData = save.GetData();
    }

    void Load()
    {
        auto load = Serializator::Serializator();
        if (load.SetData(Game.GetMap(MapId).NpcRevengeData) == 0) {
            return;
        }

        load.Get(MapId);
        load.Get(DeadNpcToRevenge);
        load.Get(DeadsCounter);
        load.Get(MapMode);
        load.Get(LeaderRole);
        load.Get(TextMsg);
        load.Get(StrCall);
        load.Get(StrCallAnswer);
        load.Get(LeaderCalls);
        load.Get(LastActionTime);
        load.Get(StrMeetingFirst);
        load.Get(StrMeetingLast);
        load.Get(StrMeetingCur);
        load.Get(StrMeetingAnswer);
        load.Get(StrHostileKill);
        load.Get(StrHostileEnter);
    }

    bool Exists()
    {
        return Game.GetMap(MapId).NpcRevengeData.length() > 0;
    }

    void Erase()
    {
        Map map = Game.GetMap(MapId);
        if (!valid(map)) {
            return;
        }

        map.NpcRevengeData = array<uint8>();
        map.StopTimeEvent(_MapLoop_CheckGag);
        map.OnCritterIn.Unsubscribe(_MapInCritter);
        map.SetupScript(null);
    }
};

// События различных стадий
void _MapInCritter(Map map, Critter cr)
{
    if (cr.ControlledByPlayer) {
        int minDist = 50000;
        int idx = -1;
        int dist = 0;

        RevengeMapInfo rm = RevengeFromMap(map);
        if (!valid(rm) || rm.MapMode != MODE_HOSTILE) {
            return;
        }

        Critter[] critters = map.GetCritters(CritterFindType::NonDeadNpc);
        for (int i = 0; i < critters.length(); i++) {
            Critter npc = critters[i];
            if (IsLocalNpc(npc, map)) {
                npc.IsNoSupply = true;
                NpcPlanes::AddAttackPlane(npc, 0, cr.Id);
                dist = Game.GetDistance(cr, npc);
                if (dist < minDist) {
                    minDist = dist;
                    idx = i;
                }
            }
        }

        if (idx > 0) {
            DL("npc talk");
            Messaging::Say(critters[idx], rm.TextMsg, rm.StrHostileEnter);
        }
    }
}

// Если нпц загородили друг другу проход
void _MapLoop_CheckGag(Map map)
{
    DL("Checking gag");

    RevengeMapInfo rm = RevengeFromMap(map);
    if (rm.LastActionTime + Time::Minutes(3) < Game.SynchronizedTime) { // 3 минуты. Проверок будет 4 шт
        map.StopTimeEvent(_MapLoop_CheckGag);
    }

    Critter[] critters = map.GetCritters(CritterFindType::NonDeadNpc);
    for (int i = 0; i < critters.length(); i++) {
        Critter cr = critters[i];
        if (IsLocalNpc(cr, map) && !NpcPlanes::IsNoPlanes(cr)) {
            DL("try find");
            if (CritterGagHome(cr, map) && cr.CountTimeEvent(cte_CheckGag) == 0) {
                DL("Found gagging npc. Id: " + cr.Id);
                // Нпц имеет только один план, идти на домашнюю позицию
                // проход не найден
                // еще не задано событие проверки нужно ли смещение
                // сохраняем текущие координаты в NpcRevengeNpcHex
                cr.NpcRevengeNpcHex = cr.Hex;
                cr.StartTimeEvent(Time::Seconds(15), cte_CheckGag);
            }
        }
    }
}

void cte_CheckGag(Critter cr)
{
    DL("Checking gag");
    Map map = cr.GetMap();
    if (valid(map) && CritterGagHome(cr, map)) {
        if (cr.Hex == cr.NpcRevengeNpcHex) {
            DL("Gag: Move Random");
            MoveRandom::CritterMoveRandom(cr);
        }
    }
    cr.NpcRevengeCountWait = 0;
    return;
}

// Предположение: криттер застрял на дороге домой
bool CritterGagHome(Critter cr, Map map)
{
    NpcPlanes::NpcPlane[] planes = {};
    if (NpcPlanes::GetPlanes(cr, planes) == 1 && valid(planes[0]) && planes[0].Type == AI_PLANE_WALK && planes[0].Walk_Hex == cr.HomeHex &&
        planes[0].Walk_Dir == cr.HomeDir && map.GetPathLength(cr.Hex, cr.HomeHex, 0) == 0) {
        return true;
    }
    DL("no gag!");
    return false;
}

void _MapLoop_Meeting(Map map)
{
    RevengeMapInfo rm = RevengeFromMap(map);

    // Иногда MAP_LOOP происходит чаще, чем указано в SetLoopTime. Эта проверка, чтобы НПЦ не частил.
    if (rm.LastActionTime != ZERO_SYNCTIME && Game.SynchronizedTime < rm.LastActionTime + Time::Seconds(10)) {
        return;
    }

    if (!valid(rm)) {
        return;
    }

    auto leaders = map.GetCritters(CritterProperty::NpcRole, rm.LeaderRole, CritterFindType::NonDeadNpc);
    if (!leaders.isEmpty() && rm.StrMeetingFirst + rm.StrMeetingCur < rm.StrMeetingLast) {
        Critter leader = leaders[0];
        Messaging::SayShout(leader, rm.TextMsg, rm.StrMeetingFirst + rm.StrMeetingCur);
        rm.StrMeetingCur++;
        rm.Save();
        any[] values = {map.Id, leader.Hex.x, leader.Hex.y};
        Game.StartTimeEvent(Time::Seconds(10), MeetingAnswer, values);
        return;
    }

    // Лидер не найден, сразу переходим к стадии атаки
    map.StopTimeEvent(_MapLoop_Meeting); // Сначала сброс, затем новое присвоение уже в rm.SetMode
    rm.SetMode(MODE_HOSTILE);
}

void MeetingAnswer(any[] values)
{
    ident mapId = values[0];
    int hx = values[1];
    int hy = values[2];
    Map map = Game.GetMap(mapId);
    RevengeMapInfo rm = RevengeFromMap(map);
    if (valid(map) && valid(rm) && rm.MapMode == MODE_MEETING && valid(rm)) {
        Critter[] npc = map.GetCritters(mpos(hx, hy), LEADER_RADIUS, CritterFindType::NonDeadNpc);
        if (!npc.isEmpty()) {
            int i = Game.Random(0, npc.length() - 1);
            Critter cr = npc[i];
            if (IsLocalNpc(cr, map) && int(cr.NpcRole) != rm.LeaderRole) {
                Messaging::Say(cr, rm.TextMsg, rm.StrMeetingAnswer);
            }
        }
    }
}

void _MapLoop_LeaderCalls(Map map)
{
    RevengeMapInfo rm = RevengeFromMap(map);
    if (!valid(rm)) {
        return;
    }

    // Иногда MAP_LOOP происходит чаще, чем указано в SetLoopTime. Эта проверка, чтобы НПЦ не частил.
    if (rm.LastActionTime != ZERO_SYNCTIME && Game.SynchronizedTime < (rm.LastActionTime + Time::Seconds(15))) {
        return;
    }

    rm.LastActionTime = Game.SynchronizedTime;

    auto leaders = map.GetCritters(CritterProperty::NpcRole, rm.LeaderRole, CritterFindType::NonDeadNpc);
    if (!leaders.isEmpty()) {
        Critter leader = leaders[0];
        if (rm.LeaderCalls < MAX_LEADER_CALLS) {
            rm.LeaderCalls++;
            rm.Save();
            Messaging::SayShout(leader, rm.TextMsg, rm.StrCall); // Лидер кричит созывающую фразу

            Critter[] npc = map.GetCritters(CritterFindType::NonDeadNpc);
            for (int i = 0; i < npc.length(); i++) {
                Critter cr = npc[i];
                if (IsLocalNpc(cr, map) && NpcPlanes::IsNoPlanes(cr) && int(cr.NpcRole) != rm.LeaderRole) {
                    if (cr.BodyType != BodyTypes::Children && Game.Random(0, 5) == 0) { // Детей из реплик исключаем
                        Messaging::Say(cr, rm.TextMsg, rm.StrCallAnswer);               // Относительная частота произнесения
                    }

                    mpos hex = leader.Hex;
                    if (Entrance::GetFreeHex(map, LEADER_RADIUS, hex)) {
                        if (NpcPlanes::AddWalkPlane(cr,
                                                    0,
                                                    PLANE_MOVE2LEADER,
                                                    0,
                                                    hex,
                                                    Game.GetDirection(hex, leader.Hex),
                                                    ((Game.Random(1, 3) == 1) ? true : false),
                                                    Game.Random(0, 1))) {
                            NpcPlanes::AddMiscPlane(cr, 0, ZERO_SYNCTIME, NpcRevenge::plane_WaitMeeting);
                            cr.NpcRevengeCountWait = 0;
                        }
                    }
                }
            }
        }
        else {
            map.StopTimeEvent(_MapLoop_LeaderCalls); // Сначала сброс, затем новое присвоение уже в rm.SetMode
            rm.SetMode(MODE_MEETING);
        }
    }
    else {
        // Лидер не найден, сразу переходим к стадии атаки
        map.StopTimeEvent(_MapLoop_LeaderCalls); // Сначала сброс, затем новое присвоение уже в rm.SetMode
        rm.SetMode(MODE_HOSTILE);
    }
}

void plane_WaitMeeting(Critter cr)
{
    // Слишком долго ждали, значит, что-то пошло не так
    if (cr.NpcRevengeCountWait > 100) {
        return;
    }

    cr.NpcRevengeCountWait += 1;

    Map map = cr.GetMap();
    if (!valid(map)) {
        return;
    }

    RevengeMapInfo rm = RevengeFromMap(map);
    if (!valid(rm)) {
        return;
    }

    // Продолжаются призывы к сбору от лидера, либо идет митинг
    if (rm.MapMode == MODE_LEADER_CALLS || rm.MapMode == MODE_MEETING) {
        NpcPlanes::AddMiscPlane(cr, 0, Game.SynchronizedTime + Time::GameMinutes(1), NpcRevenge::plane_WaitMeeting);
    }
}

void _RevengeMapInit(Map map, bool firstTime)
{
    RevengeMapInfo rm = RevengeFromMap(map);
    if (!valid(rm)) {
        return;
    }

    rm.SetEvents();
}

// Признак, это местный НПЦ
bool IsLocalNpc(Critter cr, Map map)
{
    if (!valid(cr) || cr.ControlledByPlayer || !valid(map)) {
        return false;
    }
    return cr.HomeMapId == map.Id;
}

// Признак, все нпц на карте враждебны
bool IsHostileMap(Map map)
{
    if (!valid(map)) {
        return false;
    }
    RevengeMapInfo rm = RevengeFromMap(map);
    return valid(rm) && rm.MapMode == MODE_HOSTILE;
}

void _MapCritterDead(Map map, Critter cr, Critter killer)
{
    DL("smbdy dead");
    RevengeMapInfo rm = RevengeFromMap(map);
    if (!valid(rm)) {
        return;
    }
    if (IsLocalNpc(cr, map) && valid(killer) && killer.ControlledByPlayer) {
        rm.DeadsCounter++;
    }
    if (cr.ControlledByPlayer && IsLocalNpc(killer, map)) {
        rm.DeadsCounter--;
        if (rm.MapMode == MODE_HOSTILE) {
            Messaging::Say(killer, rm.TextMsg, rm.StrHostileKill, "$pname" + Obsolete::GetPlayerName(cr.Id));
        }
    }
    rm.Save();
    if (rm.DeadsCounter == 0 && rm.MapMode == MODE_HOSTILE) {
        rm.SetMode(MODE_NORMAL);
    }
    if (rm.DeadsCounter == rm.DeadNpcToRevenge && rm.MapMode == MODE_NORMAL) {
        rm.SetMode(MODE_LEADER_CALLS);
    }
}

// debug
void Revenge(Critter cr, int role, int, int)
{
    Map map = cr.GetMap();
    if (valid(RevengeFromMap(map))) {
        Messaging::Info(cr, "revenge already set");
        return;
    }
    Map2Revenge(map, role, TextPackName::Text, 7200, 7201, 7202, 7207, 7208, 7209, 7210);
    map.SetupScript(_RevengeMapInit);
    RevengeMapInfo rm = RevengeFromMap(map);
    rm.SetEvents();
}

void Erase(Critter cr, int role, int, int)
{
    Map map = cr.GetMap();
    RevengeMapInfo rm = RevengeFromMap(map);
    if (!valid(rm)) {
        Messaging::Info(cr, "revenge not set");
        return;
    }
    rm.Erase();
    map.SetupScript(null);
}

#endif

}
